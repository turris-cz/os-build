From 151859cff680d1f8582ea12d044c78c9ca22da2d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Tue, 17 Oct 2023 11:17:38 +0200
Subject: [PATCH] mvebu: patches-5.15: Backport Turris Omnia MCU support

---
 ...dd-preliminary-support-for-Turris-Om.patch |  822 +++++++++++
 ...urris-omnia-mcu-Add-support-for-MCU-.patch | 1273 +++++++++++++++++
 ...urris-omnia-mcu-Add-support-for-powe.patch |  446 ++++++
 ...urris-omnia-mcu-Add-support-for-MCU-.patch |  251 ++++
 ...urris-omnia-mcu-Add-support-for-MCU-.patch |  230 +++
 ...urris-omnia-mcu-Add-support-for-digi.patch |  564 ++++++++
 ...omnia-Add-MCU-system-controller-node.patch |   60 +
 ...mnia-Add-GPIO-key-node-for-front-but.patch |   45 +
 8 files changed, 3691 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.15/103-1-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-2-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-3-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-4-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-6-platform-cznic-turris-omnia-mcu-Add-support-for-digi.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-7-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-8-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch

diff --git a/target/linux/mvebu/patches-5.15/103-1-platform-cznic-Add-preliminary-support-for-Turris-Om.patch b/target/linux/mvebu/patches-5.15/103-1-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
new file mode 100644
index 0000000000..248fb0a920
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-1-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
@@ -0,0 +1,822 @@
+From 865fa6851cf71d5fc07f79c500451648b8021b8b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 3 Aug 2023 13:32:59 +0200
+Subject: [PATCH 1/8] platform: cznic: Add preliminary support for Turris Omnia
+ MCU
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add the basic skeleton for a new platform driver for the microcontroller
+found on the Turris Omnia board.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  81 +++++
+ drivers/platform/Kconfig                      |   2 +
+ drivers/platform/Makefile                     |   1 +
+ drivers/platform/cznic/Kconfig                |  26 ++
+ drivers/platform/cznic/Makefile               |   4 +
+ .../platform/cznic/turris-omnia-mcu-base.c    | 336 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  71 ++++
+ include/linux/turris-omnia-mcu-interface.h    | 212 +++++++++++
+ 8 files changed, 733 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+ create mode 100644 drivers/platform/cznic/Kconfig
+ create mode 100644 drivers/platform/cznic/Makefile
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-base.c
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu.h
+ create mode 100644 include/linux/turris-omnia-mcu-interface.h
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+new file mode 100644
+index 000000000000..4322724ad891
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -0,0 +1,81 @@
++What:		/sys/bus/i2c/devices/<mcu_device>/board_revision
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains board revision number.
++
++		Only available if board information is burned in the MCU (older
++		revisions have board information burned in the ATSHA204-A chip).
++
++		Format: %u.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/first_mac_address
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains device first MAC address. Each Turris Omnia is
++		allocated 3 MAC addresses. The two additional addresses are
++		computed from the first one by incrementing it.
++
++		Only available if board information is burned in the MCU (older
++		revisions have board information burned in the ATSHA204-A chip).
++
++		Format: %pM.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Newer versions of the microcontroller firmware report the
++		features they support. These can be read from this file. If the
++		MCU firmware is too old, this file reads 0x0.
++
++		Format: 0x%x.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_version_hash_application
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the version hash (commit hash) of the application
++		part of the microcontroller firmware.
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_version_hash_bootloader
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the version hash (commit hash) of the bootloader
++		part of the microcontroller firmware.
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/mcu_type
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the microcontroller type (STM32, GD32, MKL).
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/reset_selector
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the selected factory reset level, determined by
++		how long the rear reset button was held by the user during board
++		reset.
++
++		Format: %i.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/serial_number
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the 64 bit long board serial number in hexadecimal
++		format.
++
++		Only available if board information is burned in the MCU (older
++		revisions have board information burned in the ATSHA204-A chip).
++
++		Format: %016X.
+diff --git a/drivers/platform/Kconfig b/drivers/platform/Kconfig
+index 18fc6a08569e..9babfc946bfb 100644
+--- a/drivers/platform/Kconfig
++++ b/drivers/platform/Kconfig
+@@ -10,6 +10,8 @@ source "drivers/platform/goldfish/Kconfig"
+ 
+ source "drivers/platform/chrome/Kconfig"
+ 
++source "drivers/platform/cznic/Kconfig"
++
+ source "drivers/platform/mellanox/Kconfig"
+ 
+ source "drivers/platform/olpc/Kconfig"
+diff --git a/drivers/platform/Makefile b/drivers/platform/Makefile
+index 4de08ef4ec9d..ee37fb78ad46 100644
+--- a/drivers/platform/Makefile
++++ b/drivers/platform/Makefile
+@@ -9,4 +9,5 @@ obj-$(CONFIG_MIPS)		+= mips/
+ obj-$(CONFIG_OLPC_EC)		+= olpc/
+ obj-$(CONFIG_GOLDFISH)		+= goldfish/
+ obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
++obj-$(CONFIG_CZNIC_PLATFORMS)	+= cznic/
+ obj-$(CONFIG_SURFACE_PLATFORMS)	+= surface/
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+new file mode 100644
+index 000000000000..f8560ff9c1af
+--- /dev/null
++++ b/drivers/platform/cznic/Kconfig
+@@ -0,0 +1,26 @@
++# SPDX-License-Identifier: GPL-2.0-only
++#
++# For a description of the syntax of this configuration file,
++# see Documentation/kbuild/kconfig-language.rst.
++#
++
++menuconfig CZNIC_PLATFORMS
++	bool "Platform support for CZ.NIC's Turris hardware"
++	depends on MACH_ARMADA_38X || COMPILE_TEST
++	help
++	  Say Y here to be able to choose driver support for CZ.NIC's Turris
++	  devices. This option alone does not add any kernel code.
++
++if CZNIC_PLATFORMS
++
++config TURRIS_OMNIA_MCU
++	tristate "Turris Omnia MCU driver"
++	depends on MACH_ARMADA_38X || COMPILE_TEST
++	depends on I2C
++	help
++	  Say Y here to add support for the features implemented by the
++	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
++	  To compile this driver as a module, choose M here; the module will be
++	  called turris-omnia-mcu.
++
++endif # CZNIC_PLATFORMS
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+new file mode 100644
+index 000000000000..4d0a9586538c
+--- /dev/null
++++ b/drivers/platform/cznic/Makefile
+@@ -0,0 +1,4 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
++turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+new file mode 100644
+index 000000000000..894856dd8fea
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -0,0 +1,336 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/device.h>
++#include <linux/i2c.h>
++#include <linux/module.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/sysfs.h>
++
++#include "turris-omnia-mcu.h"
++
++#define OMNIA_FW_VERSION_LEN		20
++#define OMNIA_FW_VERSION_HEX_LEN	(2 * OMNIA_FW_VERSION_LEN + 1)
++#define OMNIA_BOARD_INFO_LEN		16
++
++static int omnia_get_version_hash(struct omnia_mcu *mcu, bool bootloader,
++				  u8 version[static OMNIA_FW_VERSION_HEX_LEN])
++{
++	u8 reply[OMNIA_FW_VERSION_LEN];
++	int err;
++
++	err = omnia_cmd_read(mcu->client, bootloader ? CMD_GET_FW_VERSION_BOOT :
++						       CMD_GET_FW_VERSION_APP,
++			     reply, sizeof(reply));
++	if (err)
++		return err;
++
++	version[OMNIA_FW_VERSION_HEX_LEN - 1] = '\0';
++	bin2hex(version, reply, OMNIA_FW_VERSION_LEN);
++
++	return 0;
++}
++
++static ssize_t fw_version_hash_show(struct device *dev, char *buf,
++				    bool bootloader)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	u8 version[OMNIA_FW_VERSION_HEX_LEN];
++	int err;
++
++	err = omnia_get_version_hash(mcu, bootloader, version);
++	if (err)
++		return err;
++
++	return sysfs_emit(buf, "%s\n", version);
++}
++
++static ssize_t fw_version_hash_application_show(struct device *dev,
++						struct device_attribute *a,
++						char *buf)
++{
++	return fw_version_hash_show(dev, buf, false);
++}
++static DEVICE_ATTR_RO(fw_version_hash_application);
++
++static ssize_t fw_version_hash_bootloader_show(struct device *dev,
++					       struct device_attribute *a,
++					       char *buf)
++{
++	return fw_version_hash_show(dev, buf, true);
++}
++static DEVICE_ATTR_RO(fw_version_hash_bootloader);
++
++static ssize_t fw_features_show(struct device *dev, struct device_attribute *a,
++				char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "0x%x\n", mcu->features);
++}
++static DEVICE_ATTR_RO(fw_features);
++
++static ssize_t mcu_type_show(struct device *dev, struct device_attribute *a,
++			     char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%s\n", mcu->type);
++}
++static DEVICE_ATTR_RO(mcu_type);
++
++static ssize_t reset_selector_show(struct device *dev,
++				   struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = omnia_cmd_read_u8(to_i2c_client(dev), CMD_GET_RESET);
++	if (ret < 0)
++		return ret;
++
++	return sysfs_emit(buf, "%d\n", ret);
++}
++static DEVICE_ATTR_RO(reset_selector);
++
++static ssize_t serial_number_show(struct device *dev,
++				  struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%016llX\n", mcu->board_serial_number);
++}
++static DEVICE_ATTR_RO(serial_number);
++
++static ssize_t first_mac_address_show(struct device *dev,
++				      struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%pM\n", mcu->board_first_mac);
++}
++static DEVICE_ATTR_RO(first_mac_address);
++
++static ssize_t board_revision_show(struct device *dev,
++				   struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%u\n", mcu->board_revision);
++}
++static DEVICE_ATTR_RO(board_revision);
++
++static struct attribute *omnia_mcu_base_attrs[] = {
++	&dev_attr_fw_version_hash_application.attr,
++	&dev_attr_fw_version_hash_bootloader.attr,
++	&dev_attr_fw_features.attr,
++	&dev_attr_mcu_type.attr,
++	&dev_attr_reset_selector.attr,
++	&dev_attr_serial_number.attr,
++	&dev_attr_first_mac_address.attr,
++	&dev_attr_board_revision.attr,
++	NULL
++};
++
++static umode_t omnia_mcu_base_attrs_visible(struct kobject *kobj,
++					    struct attribute *a, int n)
++{
++	struct device *dev = kobj_to_dev(kobj);
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	umode_t mode = a->mode;
++
++	if ((a == &dev_attr_serial_number.attr ||
++	     a == &dev_attr_first_mac_address.attr ||
++	     a == &dev_attr_board_revision.attr) &&
++	    !(mcu->features & FEAT_BOARD_INFO))
++		mode = 0;
++
++	return mode;
++}
++
++static const struct attribute_group omnia_mcu_base_group = {
++	.attrs = omnia_mcu_base_attrs,
++	.is_visible = omnia_mcu_base_attrs_visible,
++};
++
++static const struct attribute_group *omnia_mcu_groups[] = {
++	&omnia_mcu_base_group,
++	NULL
++};
++
++static void omnia_mcu_print_version_hash(struct omnia_mcu *mcu, bool bootloader)
++{
++	const char *type = bootloader ? "bootloader" : "application";
++	struct device *dev = &mcu->client->dev;
++	u8 version[OMNIA_FW_VERSION_HEX_LEN];
++	int err;
++
++	err = omnia_get_version_hash(mcu, bootloader, version);
++	if (err) {
++		dev_err(dev, "Cannot read MCU %s firmware version: %d\n", type,
++			err);
++		return;
++	}
++
++	dev_info(dev, "MCU %s firmware version hash: %s\n", type, version);
++}
++
++static const char *omnia_status_to_mcu_type(uint16_t status)
++{
++	switch (status & STS_MCU_TYPE_MASK) {
++	case STS_MCU_TYPE_STM32:
++		return "STM32";
++	case STS_MCU_TYPE_GD32:
++		return "GD32";
++	case STS_MCU_TYPE_MKL:
++		return "MKL";
++	default:
++		return "unknown";
++	}
++}
++
++static void omnia_info_missing_feature(struct device *dev, const char *feature)
++{
++	dev_info(dev,
++		 "Your board's MCU firmware does not support the %s feature.\n",
++		 feature);
++}
++
++static int omnia_mcu_read_features(struct omnia_mcu *mcu)
++{
++	static const struct {
++		uint16_t mask;
++		const char *name;
++	} features[] = {
++		{ FEAT_EXT_CMDS,		"extended control and status" },
++		{ FEAT_WDT_PING,		"watchdog pinging" },
++		{ FEAT_LED_STATE_EXT_MASK,	"peripheral LED pins reading" },
++		{ FEAT_NEW_INT_API,		"new interrupt API" },
++		{ FEAT_POWEROFF_WAKEUP,		"poweroff and wakeup" },
++	};
++	struct device *dev = &mcu->client->dev;
++	bool suggest_fw_upgrade = false;
++	unsigned int i;
++	int status;
++
++	/* status word holds MCU type, which we need below */
++	status = omnia_cmd_read_u16(mcu->client, CMD_GET_STATUS_WORD);
++	if (status < 0)
++		return status;
++
++	/* check whether MCU firmware supports the CMD_GET_FEAUTRES command */
++	if (status & STS_FEATURES_SUPPORTED) {
++		int features;
++
++		features = omnia_cmd_read_u16(mcu->client, CMD_GET_FEATURES);
++		if (features < 0)
++			return features;
++
++		mcu->features = features;
++	} else {
++		omnia_info_missing_feature(dev, "feature reading");
++		suggest_fw_upgrade = true;
++	}
++
++	mcu->type = omnia_status_to_mcu_type(status);
++	dev_info(dev, "MCU type %s%s\n", mcu->type,
++		 (mcu->features & FEAT_PERIPH_MCU) ?
++			", with peripheral resets wired" : "");
++
++	omnia_mcu_print_version_hash(mcu, true);
++
++	if (mcu->features & FEAT_BOOTLOADER)
++		dev_warn(dev,
++			 "MCU is running bootloader firmware. Was firmware upgrade interrupted?\n");
++	else
++		omnia_mcu_print_version_hash(mcu, false);
++
++	for (i = 0; i < ARRAY_SIZE(features); i++) {
++		if (mcu->features & features[i].mask)
++			continue;
++
++		omnia_info_missing_feature(dev, features[i].name);
++		suggest_fw_upgrade = true;
++	}
++
++	if (suggest_fw_upgrade)
++		dev_info(dev,
++			 "Consider upgrading MCU firmware with the omnia-mcutool utility.\n");
++
++	return 0;
++}
++
++static int omnia_mcu_read_board_info(struct omnia_mcu *mcu)
++{
++	u8 reply[1 + OMNIA_BOARD_INFO_LEN];
++	int err;
++
++	err = omnia_cmd_read(mcu->client, CMD_BOARD_INFO_GET, reply,
++			     sizeof(reply));
++	if (err)
++		return err;
++
++	if (reply[0] != OMNIA_BOARD_INFO_LEN)
++		return -EIO;
++
++	mcu->board_serial_number = get_unaligned_le64(&reply[1]);
++	memcpy(mcu->board_first_mac, &reply[9], ETH_ALEN);
++	mcu->board_revision = reply[15];
++
++	return 0;
++}
++
++static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id *)
++{
++	struct device *dev = &client->dev;
++	struct omnia_mcu *mcu;
++	int err;
++
++	if (!client->irq)
++		return dev_err_probe(dev, -EINVAL, "IRQ resource not found\n");
++
++	mcu = devm_kzalloc(dev, sizeof(*mcu), GFP_KERNEL);
++	if (!mcu)
++		return -ENOMEM;
++
++	mcu->client = client;
++	i2c_set_clientdata(client, mcu);
++
++	err = omnia_mcu_read_features(mcu);
++	if (err)
++		return dev_err_probe(dev, err,
++				     "Cannot determine MCU supported features\n");
++
++	if (mcu->features & FEAT_BOARD_INFO) {
++		err = omnia_mcu_read_board_info(mcu);
++		if (err)
++			return dev_err_probe(dev, err,
++					     "Cannot read board info\n");
++	}
++
++	return 0;
++}
++
++static const struct of_device_id of_omnia_mcu_match[] = {
++	{ .compatible = "cznic,turris-omnia-mcu" },
++	{}
++};
++
++static struct i2c_driver omnia_mcu_driver = {
++	.probe		= omnia_mcu_probe,
++	.driver		= {
++		.name	= "turris-omnia-mcu",
++		.of_match_table = of_omnia_mcu_match,
++		.dev_groups = omnia_mcu_groups,
++	},
++};
++
++module_i2c_driver(omnia_mcu_driver);
++
++MODULE_AUTHOR("Marek Behun <kabel@kernel.org>");
++MODULE_DESCRIPTION("CZ.NIC's Turris Omnia MCU");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+new file mode 100644
+index 000000000000..f18b745b223c
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -0,0 +1,71 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * CZ.NIC's Turris Omnia MCU driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#ifndef __TURRIS_OMNIA_MCU_H
++#define __TURRIS_OMNIA_MCU_H
++
++#include <linux/i2c.h>
++#include <linux/if_ether.h>
++#include <linux/types.h>
++#include <asm/byteorder.h>
++
++struct omnia_mcu {
++	struct i2c_client *client;
++	const char *type;
++	u16 features;
++
++	/* board information */
++	u64 board_serial_number;
++	u8 board_first_mac[ETH_ALEN];
++	u8 board_revision;
++};
++
++static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
++				 void *reply, unsigned int len)
++{
++	struct i2c_msg msgs[2];
++	int ret;
++
++	msgs[0].addr = client->addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &cmd;
++	msgs[1].addr = client->addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = len;
++	msgs[1].buf = reply;
++
++	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
++	if (ret < 0)
++		return ret;
++	if (ret != ARRAY_SIZE(msgs))
++		return -EIO;
++
++	return 0;
++}
++
++static inline int omnia_cmd_read_u16(const struct i2c_client *client, u8 cmd)
++{
++	__le16 reply;
++	int err;
++
++	err = omnia_cmd_read(client, cmd, &reply, sizeof(reply));
++
++	return err ?: le16_to_cpu(reply);
++}
++
++static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
++{
++	u8 reply;
++	int err;
++
++	err = omnia_cmd_read(client, cmd, &reply, sizeof(reply));
++
++	return err ?: reply;
++}
++
++#endif /* __TURRIS_OMNIA_MCU_H */
+diff --git a/include/linux/turris-omnia-mcu-interface.h b/include/linux/turris-omnia-mcu-interface.h
+new file mode 100644
+index 000000000000..4498590303d5
+--- /dev/null
++++ b/include/linux/turris-omnia-mcu-interface.h
+@@ -0,0 +1,212 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * CZ.NIC's Turris Omnia MCU I2C interface commands definitions
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#ifndef __TURRIS_OMNIA_MCU_INTERFACE_H
++#define __TURRIS_OMNIA_MCU_INTERFACE_H
++
++#include <linux/bits.h>
++
++enum omnia_commands_e {
++	CMD_GET_STATUS_WORD		= 0x01, /* slave sends status word back */
++	CMD_GENERAL_CONTROL		= 0x02,
++	CMD_LED_MODE			= 0x03, /* default/user */
++	CMD_LED_STATE			= 0x04, /* LED on/off */
++	CMD_LED_COLOR			= 0x05, /* LED number + RED + GREEN + BLUE */
++	CMD_USER_VOLTAGE		= 0x06,
++	CMD_SET_BRIGHTNESS		= 0x07,
++	CMD_GET_BRIGHTNESS		= 0x08,
++	CMD_GET_RESET			= 0x09,
++	CMD_GET_FW_VERSION_APP		= 0x0A, /* 20B git hash number */
++	CMD_SET_WATCHDOG_STATE		= 0x0B, /* 0 - disable
++						 * 1 - enable / ping
++						 * after boot watchdog is started
++						 * with 2 minutes timeout
++						 */
++
++	/* CMD_WATCHDOG_STATUS		= 0x0C, not implemented anymore */
++
++	CMD_GET_WATCHDOG_STATE		= 0x0D,
++	CMD_GET_FW_VERSION_BOOT		= 0x0E, /* 20B git hash number */
++	CMD_GET_FW_CHECKSUM		= 0x0F, /* 4B length, 4B checksum */
++
++	/* available if FEATURES_SUPPORTED bit set in status word */
++	CMD_GET_FEATURES		= 0x10,
++
++	/* available if EXT_CMD bit set in features */
++	CMD_GET_EXT_STATUS_DWORD	= 0x11,
++	CMD_EXT_CONTROL			= 0x12,
++	CMD_GET_EXT_CONTROL_STATUS	= 0x13,
++
++	/* available if NEW_INT_API bit set in features */
++	CMD_GET_INT_AND_CLEAR		= 0x14,
++	CMD_GET_INT_MASK		= 0x15,
++	CMD_SET_INT_MASK		= 0x16,
++
++	/* available if FLASHING bit set in features */
++	CMD_FLASH			= 0x19,
++
++	/* available if WDT_PING bit set in features */
++	CMD_SET_WDT_TIMEOUT		= 0x20,
++	CMD_GET_WDT_TIMELEFT		= 0x21,
++
++	/* available if POWEROFF_WAKEUP bit set in features */
++	CMD_SET_WAKEUP			= 0x22,
++	CMD_GET_UPTIME_AND_WAKEUP	= 0x23,
++	CMD_POWER_OFF			= 0x24,
++
++	/* available if TRNG bit set in features */
++	CMD_TRNG_COLLECT_ENTROPY	= 0x28,
++
++	/* available if CRYPTO bit set in features */
++	CMD_CRYPTO_GET_PUBLIC_KEY	= 0x29,
++	CMD_CRYPTO_SIGN_MESSAGE		= 0x2A,
++	CMD_CRYPTO_COLLECT_SIGNATURE	= 0x2B,
++
++	/* available if BOARD_INFO it set in features */
++	CMD_BOARD_INFO_GET		= 0x2C,
++	CMD_BOARD_INFO_BURN		= 0x2D,
++
++	/* available only at address 0x2b (led-controller) */
++	/* available only if LED_GAMMA_CORRECTION bit set in features */
++	CMD_SET_GAMMA_CORRECTION	= 0x30,
++	CMD_GET_GAMMA_CORRECTION	= 0x31,
++};
++
++enum omnia_flashing_commands_e {
++	FLASH_CMD_UNLOCK		= 0x01,
++	FLASH_CMD_SIZE_AND_CSUM		= 0x02,
++	FLASH_CMD_PROGRAM		= 0x03,
++	FLASH_CMD_RESET			= 0x04,
++};
++
++enum omnia_sts_word_e {
++	STS_MCU_TYPE_MASK			= GENMASK(1, 0),
++	STS_MCU_TYPE_STM32			= 0 << 0,
++	STS_MCU_TYPE_GD32			= 1 << 0,
++	STS_MCU_TYPE_MKL			= 2 << 0,
++	STS_FEATURES_SUPPORTED			= BIT(2),
++	STS_USER_REGULATOR_NOT_SUPPORTED	= BIT(3),
++	STS_CARD_DET				= BIT(4),
++	STS_MSATA_IND				= BIT(5),
++	STS_USB30_OVC				= BIT(6),
++	STS_USB31_OVC				= BIT(7),
++	STS_USB30_PWRON				= BIT(8),
++	STS_USB31_PWRON				= BIT(9),
++	STS_ENABLE_4V5				= BIT(10),
++	STS_BUTTON_MODE				= BIT(11),
++	STS_BUTTON_PRESSED			= BIT(12),
++	STS_BUTTON_COUNTER_MASK			= GENMASK(15, 13)
++};
++
++enum omnia_ctl_byte_e {
++	CTL_LIGHT_RST		= BIT(0),
++	CTL_HARD_RST		= BIT(1),
++	/* BIT(2) is currently reserved */
++	CTL_USB30_PWRON		= BIT(3),
++	CTL_USB31_PWRON		= BIT(4),
++	CTL_ENABLE_4V5		= BIT(5),
++	CTL_BUTTON_MODE		= BIT(6),
++	CTL_BOOTLOADER		= BIT(7)
++};
++
++enum omnia_features_e {
++	FEAT_PERIPH_MCU			= BIT(0),
++	FEAT_EXT_CMDS			= BIT(1),
++	FEAT_WDT_PING			= BIT(2),
++	FEAT_LED_STATE_EXT_MASK		= GENMASK(4, 3),
++	FEAT_LED_STATE_EXT		= 1 << 3,
++	FEAT_LED_STATE_EXT_V32		= 2 << 3,
++	FEAT_LED_GAMMA_CORRECTION	= BIT(5),
++	FEAT_NEW_INT_API		= BIT(6),
++	FEAT_BOOTLOADER			= BIT(7),
++	FEAT_FLASHING			= BIT(8),
++	FEAT_NEW_MESSAGE_API		= BIT(9),
++	FEAT_BRIGHTNESS_INT		= BIT(10),
++	FEAT_POWEROFF_WAKEUP		= BIT(11),
++	FEAT_CAN_OLD_MESSAGE_API	= BIT(12),
++	FEAT_TRNG			= BIT(13),
++	FEAT_CRYPTO			= BIT(14),
++	FEAT_BOARD_INFO			= BIT(15),
++};
++
++enum omnia_ext_sts_dword_e {
++	EXT_STS_SFP_nDET		= BIT(0),
++	EXT_STS_LED_STATES_MASK		= GENMASK(31, 12),
++	EXT_STS_WLAN0_MSATA_LED		= BIT(12),
++	EXT_STS_WLAN1_LED		= BIT(13),
++	EXT_STS_WLAN2_LED		= BIT(14),
++	EXT_STS_WPAN0_LED		= BIT(15),
++	EXT_STS_WPAN1_LED		= BIT(16),
++	EXT_STS_WPAN2_LED		= BIT(17),
++	EXT_STS_WAN_LED0		= BIT(18),
++	EXT_STS_WAN_LED1		= BIT(19),
++	EXT_STS_LAN0_LED0		= BIT(20),
++	EXT_STS_LAN0_LED1		= BIT(21),
++	EXT_STS_LAN1_LED0		= BIT(22),
++	EXT_STS_LAN1_LED1		= BIT(23),
++	EXT_STS_LAN2_LED0		= BIT(24),
++	EXT_STS_LAN2_LED1		= BIT(25),
++	EXT_STS_LAN3_LED0		= BIT(26),
++	EXT_STS_LAN3_LED1		= BIT(27),
++	EXT_STS_LAN4_LED0		= BIT(28),
++	EXT_STS_LAN4_LED1		= BIT(29),
++	EXT_STS_LAN5_LED0		= BIT(30),
++	EXT_STS_LAN5_LED1		= BIT(31),
++};
++
++enum omnia_ext_ctl_e {
++	EXT_CTL_nRES_MMC		= BIT(0),
++	EXT_CTL_nRES_LAN		= BIT(1),
++	EXT_CTL_nRES_PHY		= BIT(2),
++	EXT_CTL_nPERST0			= BIT(3),
++	EXT_CTL_nPERST1			= BIT(4),
++	EXT_CTL_nPERST2			= BIT(5),
++	EXT_CTL_PHY_SFP			= BIT(6),
++	EXT_CTL_PHY_SFP_AUTO		= BIT(7),
++	EXT_CTL_nVHV_CTRL		= BIT(8),
++};
++
++enum omnia_int_e {
++	INT_CARD_DET		= BIT(0),
++	INT_MSATA_IND		= BIT(1),
++	INT_USB30_OVC		= BIT(2),
++	INT_USB31_OVC		= BIT(3),
++	INT_BUTTON_PRESSED	= BIT(4),
++	INT_SFP_nDET		= BIT(5),
++	INT_BRIGHTNESS_CHANGED	= BIT(6),
++	INT_TRNG		= BIT(7),
++	INT_MESSAGE_SIGNED	= BIT(8),
++
++	INT_LED_STATES_MASK	= GENMASK(31, 12),
++	INT_WLAN0_MSATA_LED	= BIT(12),
++	INT_WLAN1_LED		= BIT(13),
++	INT_WLAN2_LED		= BIT(14),
++	INT_WPAN0_LED		= BIT(15),
++	INT_WPAN1_LED		= BIT(16),
++	INT_WPAN2_LED		= BIT(17),
++	INT_WAN_LED0		= BIT(18),
++	INT_WAN_LED1		= BIT(19),
++	INT_LAN0_LED0		= BIT(20),
++	INT_LAN0_LED1		= BIT(21),
++	INT_LAN1_LED0		= BIT(22),
++	INT_LAN1_LED1		= BIT(23),
++	INT_LAN2_LED0		= BIT(24),
++	INT_LAN2_LED1		= BIT(25),
++	INT_LAN3_LED0		= BIT(26),
++	INT_LAN3_LED1		= BIT(27),
++	INT_LAN4_LED0		= BIT(28),
++	INT_LAN4_LED1		= BIT(29),
++	INT_LAN5_LED0		= BIT(30),
++	INT_LAN5_LED1		= BIT(31),
++};
++
++enum omnia_cmd_poweroff_e {
++	CMD_POWER_OFF_POWERON_BUTTON	= BIT(0),
++	CMD_POWER_OFF_MAGIC		= 0xdead,
++};
++
++#endif /* __TURRIS_OMNIA_MCU_INTERFACE_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-2-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch b/target/linux/mvebu/patches-5.15/103-2-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
new file mode 100644
index 0000000000..438b3f5a07
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-2-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
@@ -0,0 +1,1273 @@
+From b2c4a09d6567a0ac841a50abc829c2dd16fec0af Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 11:58:51 +0200
+Subject: [PATCH 2/8] platform: cznic: turris-omnia-mcu: Add support for MCU
+ connected GPIOs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for GPIOs connected to the MCU on the Turris Omnia board.
+
+This includes:
+- front button pin
+- enable pins for USB regulators
+- MiniPCIe / mSATA card presence pins in MiniPCIe port 0
+- LED output pins from WAN ethernet PHY, LAN switch and MiniPCIe ports
+- on board revisions 32+ also various peripheral resets and another
+  voltage regulator enable pin
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |   16 +
+ drivers/platform/cznic/Kconfig                |   15 +
+ drivers/platform/cznic/Makefile               |    1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |    3 +-
+ .../platform/cznic/turris-omnia-mcu-gpio.c    | 1051 +++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |   62 +
+ 6 files changed, 1147 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-gpio.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+index 4322724ad891..91e107583edd 100644
+--- a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -22,6 +22,22 @@ Description:	(RO) Contains device first MAC address. Each Turris Omnia is
+ 
+ 		Format: %pM.
+ 
++What:		/sys/bus/i2c/devices/<mcu_device>/front_button_mode
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RW) The front button on the Turris Omnia router can be
++		configured either to change the intensity of all the LEDs on the
++		front panel, or to send the press event to the CPU as an
++		interrupt.
++
++		This file switches between these two modes:
++		- "mcu" makes the button press event be handled by the MCU to
++		  change the LEDs panel intensity.
++		- "cpu" makes the button press event be handled by the CPU.
++
++		Format: %s.
++
+ What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
+ Date:		May 2024
+ KernelVersion:	6.9
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index f8560ff9c1af..3a8c3edcd7e6 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -17,9 +17,24 @@ config TURRIS_OMNIA_MCU
+ 	tristate "Turris Omnia MCU driver"
+ 	depends on MACH_ARMADA_38X || COMPILE_TEST
+ 	depends on I2C
++	select GPIOLIB
++	select GPIOLIB_IRQCHIP
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
++	  The features include:
++	  - GPIO pins
++	    - to get front button press events (the front button can be
++	      configured either to generate press events to the CPU or to change
++	      front LEDs panel brightness)
++	    - to enable / disable USB port voltage regulators and to detect
++	      USB overcurrent
++	    - to detect MiniPCIe / mSATA card presence in MiniPCIe port 0
++	    - to configure resets of various peripherals on board revisions 32+
++	    - to enable / disable the VHV voltage regulator to the SOC in order
++	      to be able to program SOC's OTP on board revisions 32+
++	    - to get input from the LED output pins of the WAN ethernet PHY, LAN
++	      switch and MiniPCIe ports
+ 	  To compile this driver as a module, choose M here; the module will be
+ 	  called turris-omnia-mcu.
+ 
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index 4d0a9586538c..a6177f5b4fff 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -2,3 +2,4 @@
+ 
+ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index 894856dd8fea..8bb38b910f10 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -159,6 +159,7 @@ static const struct attribute_group omnia_mcu_base_group = {
+ 
+ static const struct attribute_group *omnia_mcu_groups[] = {
+ 	&omnia_mcu_base_group,
++	&omnia_mcu_gpio_group,
+ 	NULL
+ };
+ 
+@@ -312,7 +313,7 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 					     "Cannot read board info\n");
+ 	}
+ 
+-	return 0;
++	return omnia_mcu_register_gpiochip(mcu);
+ }
+ 
+ static const struct of_device_id of_omnia_mcu_match[] = {
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-gpio.c b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+new file mode 100644
+index 000000000000..ee5bd64a988f
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+@@ -0,0 +1,1051 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU GPIO and IRQ driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/bitops.h>
++#include <linux/bug.h>
++#include <linux/devm-helpers.h>
++#include <linux/gpio/driver.h>
++#include <linux/i2c.h>
++#include <linux/interrupt.h>
++#include <linux/mutex.h>
++#include <linux/sysfs.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/workqueue.h>
++#include <asm/unaligned.h>
++
++#include "turris-omnia-mcu.h"
++
++#define CMD_INT_ARG_LEN			8
++#define FRONT_BUTTON_RELEASE_DELAY	50 /* ms */
++
++static const char * const omnia_mcu_gpio_templates[64] = {
++	/* GPIOs with value read from the 16-bit wide status */
++	[4]  = "gpio%u.MiniPCIe0 Card Detect",
++	[5]  = "gpio%u.MiniPCIe0 mSATA Indicator",
++	[6]  = "gpio%u.Front USB3 port over-current",
++	[7]  = "gpio%u.Rear USB3 port over-current",
++	[8]  = "gpio%u.Front USB3 port power",
++	[9]  = "gpio%u.Rear USB3 port power",
++	[12] = "gpio%u.Front Button",
++
++	/* GPIOs with value read from the 32-bit wide extended status */
++	[16] = "gpio%u.SFP nDET",
++	[28] = "gpio%u.MiniPCIe0 LED",
++	[29] = "gpio%u.MiniPCIe1 LED",
++	[30] = "gpio%u.MiniPCIe2 LED",
++	[31] = "gpio%u.MiniPCIe0 PAN LED",
++	[32] = "gpio%u.MiniPCIe1 PAN LED",
++	[33] = "gpio%u.MiniPCIe2 PAN LED",
++	[34] = "gpio%u.WAN PHY LED0",
++	[35] = "gpio%u.WAN PHY LED1",
++	[36] = "gpio%u.LAN switch p0 LED0",
++	[37] = "gpio%u.LAN switch p0 LED1",
++	[38] = "gpio%u.LAN switch p1 LED0",
++	[39] = "gpio%u.LAN switch p1 LED1",
++	[40] = "gpio%u.LAN switch p2 LED0",
++	[41] = "gpio%u.LAN switch p2 LED1",
++	[42] = "gpio%u.LAN switch p3 LED0",
++	[43] = "gpio%u.LAN switch p3 LED1",
++	[44] = "gpio%u.LAN switch p4 LED0",
++	[45] = "gpio%u.LAN switch p4 LED1",
++	[46] = "gpio%u.LAN switch p5 LED0",
++	[47] = "gpio%u.LAN switch p5 LED1",
++
++	/* GPIOs with value read from the 16-bit wide extended control status */
++	[48] = "gpio%u.eMMC nRESET",
++	[49] = "gpio%u.LAN switch nRESET",
++	[50] = "gpio%u.WAN PHY nRESET",
++	[51] = "gpio%u.MiniPCIe0 nPERST",
++	[52] = "gpio%u.MiniPCIe1 nPERST",
++	[53] = "gpio%u.MiniPCIe2 nPERST",
++	[54] = "gpio%u.WAN PHY SFP mux",
++};
++
++#define _DEF_GPIO(_cmd, _ctl_cmd, _bit, _ctl_bit, _int_bit, _feat, _feat_mask) \
++	{								\
++		.cmd = _cmd,						\
++		.ctl_cmd = _ctl_cmd,					\
++		.bit = _bit,						\
++		.ctl_bit = _ctl_bit,					\
++		.int_bit = _int_bit,					\
++		.feat = _feat,						\
++		.feat_mask = _feat_mask,				\
++	}
++#define _DEF_GPIO_STS(_name) \
++	_DEF_GPIO(CMD_GET_STATUS_WORD, 0, STS_ ## _name, 0, INT_ ## _name, 0, 0)
++#define _DEF_GPIO_CTL(_name) \
++	_DEF_GPIO(CMD_GET_STATUS_WORD, CMD_GENERAL_CONTROL, STS_ ## _name, \
++		  CTL_ ## _name, 0, 0, 0)
++#define _DEF_GPIO_EXT_STS(_name, _feat) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_ ## _feat | FEAT_EXT_CMDS, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS)
++#define _DEF_GPIO_EXT_STS_LED(_name, _ledext) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_LED_STATE_ ## _ledext, \
++		  FEAT_LED_STATE_EXT_MASK)
++#define _DEF_GPIO_EXT_STS_LEDALL(_name) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_LED_STATE_EXT_MASK, 0)
++#define _DEF_GPIO_EXT_CTL(_name, _feat) \
++	_DEF_GPIO(CMD_GET_EXT_CONTROL_STATUS, CMD_EXT_CONTROL, \
++		  EXT_CTL_ ## _name, EXT_CTL_ ## _name, 0, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS)
++#define _DEF_INT(_name) \
++	_DEF_GPIO(0, 0, 0, 0, INT_ ## _name, 0, 0)
++
++static const struct omnia_gpio {
++	u8 cmd, ctl_cmd;
++	u32 bit, ctl_bit;
++	u32 int_bit;
++	u16 feat, feat_mask;
++} omnia_gpios[64] = {
++	/* GPIOs with value read from the 16-bit wide status */
++	[4]  = _DEF_GPIO_STS(CARD_DET),
++	[5]  = _DEF_GPIO_STS(MSATA_IND),
++	[6]  = _DEF_GPIO_STS(USB30_OVC),
++	[7]  = _DEF_GPIO_STS(USB31_OVC),
++	[8]  = _DEF_GPIO_CTL(USB30_PWRON),
++	[9]  = _DEF_GPIO_CTL(USB31_PWRON),
++
++	/* brightness changed interrupt, no GPIO */
++	[11] = _DEF_INT(BRIGHTNESS_CHANGED),
++
++	[12] = _DEF_GPIO_STS(BUTTON_PRESSED),
++
++	/* TRNG interrupt, no GPIO */
++	[13] = _DEF_INT(TRNG),
++
++	/* MESSAGE_SIGNED interrupt, no GPIO */
++	[14] = _DEF_INT(MESSAGE_SIGNED),
++
++	/* GPIOs with value read from the 32-bit wide extended status */
++	[16] = _DEF_GPIO_EXT_STS(SFP_nDET, PERIPH_MCU),
++	[28] = _DEF_GPIO_EXT_STS_LEDALL(WLAN0_MSATA_LED),
++	[29] = _DEF_GPIO_EXT_STS_LEDALL(WLAN1_LED),
++	[30] = _DEF_GPIO_EXT_STS_LEDALL(WLAN2_LED),
++	[31] = _DEF_GPIO_EXT_STS_LED(WPAN0_LED, EXT),
++	[32] = _DEF_GPIO_EXT_STS_LED(WPAN1_LED, EXT),
++	[33] = _DEF_GPIO_EXT_STS_LED(WPAN2_LED, EXT),
++	[34] = _DEF_GPIO_EXT_STS_LEDALL(WAN_LED0),
++	[35] = _DEF_GPIO_EXT_STS_LED(WAN_LED1, EXT_V32),
++	[36] = _DEF_GPIO_EXT_STS_LEDALL(LAN0_LED0),
++	[37] = _DEF_GPIO_EXT_STS_LEDALL(LAN0_LED1),
++	[38] = _DEF_GPIO_EXT_STS_LEDALL(LAN1_LED0),
++	[39] = _DEF_GPIO_EXT_STS_LEDALL(LAN1_LED1),
++	[40] = _DEF_GPIO_EXT_STS_LEDALL(LAN2_LED0),
++	[41] = _DEF_GPIO_EXT_STS_LEDALL(LAN2_LED1),
++	[42] = _DEF_GPIO_EXT_STS_LEDALL(LAN3_LED0),
++	[43] = _DEF_GPIO_EXT_STS_LEDALL(LAN3_LED1),
++	[44] = _DEF_GPIO_EXT_STS_LEDALL(LAN4_LED0),
++	[45] = _DEF_GPIO_EXT_STS_LEDALL(LAN4_LED1),
++	[46] = _DEF_GPIO_EXT_STS_LEDALL(LAN5_LED0),
++	[47] = _DEF_GPIO_EXT_STS_LEDALL(LAN5_LED1),
++
++	/* GPIOs with value read from the 16-bit wide extended control status */
++	[48] = _DEF_GPIO_EXT_CTL(nRES_MMC, PERIPH_MCU),
++	[49] = _DEF_GPIO_EXT_CTL(nRES_LAN, PERIPH_MCU),
++	[50] = _DEF_GPIO_EXT_CTL(nRES_PHY, PERIPH_MCU),
++	[51] = _DEF_GPIO_EXT_CTL(nPERST0, PERIPH_MCU),
++	[52] = _DEF_GPIO_EXT_CTL(nPERST1, PERIPH_MCU),
++	[53] = _DEF_GPIO_EXT_CTL(nPERST2, PERIPH_MCU),
++	[54] = _DEF_GPIO_EXT_CTL(PHY_SFP, PERIPH_MCU),
++};
++
++/* mapping from interrupts to indexes of GPIOs in the omnia_gpios array */
++static const u8 omnia_int_to_gpio_idx[32] = {
++	[__bf_shf(INT_CARD_DET)]		= 4,
++	[__bf_shf(INT_MSATA_IND)]		= 5,
++	[__bf_shf(INT_USB30_OVC)]		= 6,
++	[__bf_shf(INT_USB31_OVC)]		= 7,
++	[__bf_shf(INT_BUTTON_PRESSED)]		= 12,
++	[__bf_shf(INT_TRNG)]			= 13,
++	[__bf_shf(INT_MESSAGE_SIGNED)]		= 14,
++	[__bf_shf(INT_SFP_nDET)]		= 16,
++	[__bf_shf(INT_BRIGHTNESS_CHANGED)]	= 11,
++	[__bf_shf(INT_WLAN0_MSATA_LED)]		= 28,
++	[__bf_shf(INT_WLAN1_LED)]		= 29,
++	[__bf_shf(INT_WLAN2_LED)]		= 30,
++	[__bf_shf(INT_WPAN0_LED)]		= 31,
++	[__bf_shf(INT_WPAN1_LED)]		= 32,
++	[__bf_shf(INT_WPAN2_LED)]		= 33,
++	[__bf_shf(INT_WAN_LED0)]		= 34,
++	[__bf_shf(INT_WAN_LED1)]		= 35,
++	[__bf_shf(INT_LAN0_LED0)]		= 36,
++	[__bf_shf(INT_LAN0_LED1)]		= 37,
++	[__bf_shf(INT_LAN1_LED0)]		= 38,
++	[__bf_shf(INT_LAN1_LED1)]		= 39,
++	[__bf_shf(INT_LAN2_LED0)]		= 40,
++	[__bf_shf(INT_LAN2_LED1)]		= 41,
++	[__bf_shf(INT_LAN3_LED0)]		= 42,
++	[__bf_shf(INT_LAN3_LED1)]		= 43,
++	[__bf_shf(INT_LAN4_LED0)]		= 44,
++	[__bf_shf(INT_LAN4_LED1)]		= 45,
++	[__bf_shf(INT_LAN5_LED0)]		= 46,
++	[__bf_shf(INT_LAN5_LED1)]		= 47,
++};
++
++/* index of PHY_SFP GPIO in the omnia_gpios array */
++#define OMNIA_GPIO_PHY_SFP_OFFSET	54
++
++static int omnia_ctl_cmd_locked(struct omnia_mcu *mcu, u8 cmd, u16 val,
++				u16 mask)
++{
++	size_t len;
++	u8 buf[5];
++
++	buf[0] = cmd;
++
++	switch (cmd) {
++	case CMD_GENERAL_CONTROL:
++		buf[1] = val;
++		buf[2] = mask;
++		len = 3;
++		break;
++
++	case CMD_EXT_CONTROL:
++		put_unaligned_le16(val, &buf[1]);
++		put_unaligned_le16(mask, &buf[3]);
++		len = 5;
++		break;
++
++	default:
++		BUG();
++	}
++
++	return omnia_cmd_write(mcu->client, buf, len);
++}
++
++static int omnia_ctl_cmd(struct omnia_mcu *mcu, u8 cmd, u16 val, u16 mask)
++{
++	int err;
++
++	mutex_lock(&mcu->lock);
++	err = omnia_ctl_cmd_locked(mcu, cmd, val, mask);
++	mutex_unlock(&mcu->lock);
++
++	return err;
++}
++
++static int omnia_gpio_request(struct gpio_chip *gc, unsigned int offset)
++{
++	if (!omnia_gpios[offset].cmd)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int omnia_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET) {
++		int val;
++
++		mutex_lock(&mcu->lock);
++		val = omnia_cmd_read_bit(mcu->client,
++					 CMD_GET_EXT_CONTROL_STATUS,
++					 EXT_CTL_PHY_SFP_AUTO);
++		mutex_unlock(&mcu->lock);
++
++		if (val < 0)
++			return val;
++
++		if (val)
++			return GPIO_LINE_DIRECTION_IN;
++
++		return GPIO_LINE_DIRECTION_OUT;
++	}
++
++	if (omnia_gpios[offset].ctl_cmd)
++		return GPIO_LINE_DIRECTION_OUT;
++
++	return GPIO_LINE_DIRECTION_IN;
++}
++
++static int omnia_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET)
++		return omnia_ctl_cmd(mcu, CMD_EXT_CONTROL, EXT_CTL_PHY_SFP_AUTO,
++				     EXT_CTL_PHY_SFP_AUTO);
++
++	if (gpio->ctl_cmd)
++		return -ENOTSUPP;
++
++	return 0;
++}
++
++static int omnia_gpio_direction_output(struct gpio_chip *gc,
++				       unsigned int offset, int value)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u16 val, mask;
++
++	if (!gpio->ctl_cmd)
++		return -ENOTSUPP;
++
++	mask = gpio->ctl_bit;
++	val = value ? mask : 0;
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET)
++		mask |= EXT_CTL_PHY_SFP_AUTO;
++
++	return omnia_ctl_cmd(mcu, gpio->ctl_cmd, val, mask);
++}
++
++static int omnia_gpio_get(struct gpio_chip *gc, unsigned int offset)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	int ret;
++
++	/*
++	 * If firmware does not support the new interrupt API, we are informed
++	 * of every change of the status word by an interrupt from MCU and save
++	 * its value in the interrupt service routine. Simply return the saved
++	 * value.
++	 */
++	if (gpio->cmd == CMD_GET_STATUS_WORD &&
++	    !(mcu->features & FEAT_NEW_INT_API))
++		return !!(mcu->last_status & gpio->bit);
++
++	mutex_lock(&mcu->lock);
++
++	/*
++	 * If firmware does support the new interrupt API, we may have cached
++	 * the value of a GPIO in the interrupt service routine. If not, read
++	 * the relevant bit now.
++	 */
++	if (gpio->int_bit && (mcu->is_cached & gpio->int_bit))
++		ret = !!(mcu->cached & gpio->int_bit);
++	else
++		ret = omnia_cmd_read_bit(mcu->client, gpio->cmd, gpio->bit);
++
++	mutex_unlock(&mcu->lock);
++
++	return ret;
++}
++
++static int omnia_gpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,
++				   unsigned long *bits)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u32 sts_bits, ext_sts_bits, ext_ctl_bits;
++	int err, i;
++
++	sts_bits = 0;
++	ext_sts_bits = 0;
++	ext_ctl_bits = 0;
++
++	/* determine which bits to read from the 3 possible commands */
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].cmd == CMD_GET_STATUS_WORD)
++			sts_bits |= omnia_gpios[i].bit;
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_STATUS_DWORD)
++			ext_sts_bits |= omnia_gpios[i].bit;
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_CONTROL_STATUS)
++			ext_ctl_bits |= omnia_gpios[i].bit;
++	}
++
++	mutex_lock(&mcu->lock);
++
++	if (mcu->features & FEAT_NEW_INT_API) {
++		/* read relevant bits from status */
++		err = omnia_cmd_read_bits(mcu->client, CMD_GET_STATUS_WORD,
++					  sts_bits, &sts_bits);
++		if (err)
++			goto err_unlock;
++	} else {
++		/*
++		 * Use status word value cached in the interrupt service routine
++		 * if firmware does not support the new interrupt API.
++		 */
++		sts_bits = mcu->last_status;
++	}
++
++	/* read relevant bits from extended status */
++	err = omnia_cmd_read_bits(mcu->client, CMD_GET_EXT_STATUS_DWORD,
++				  ext_sts_bits, &ext_sts_bits);
++	if (err)
++		goto err_unlock;
++
++	/* read relevant bits from extended control */
++	err = omnia_cmd_read_bits(mcu->client, CMD_GET_EXT_CONTROL_STATUS,
++				  ext_ctl_bits, &ext_ctl_bits);
++	if (err)
++		goto err_unlock;
++
++	mutex_unlock(&mcu->lock);
++
++	/* assign relevant bits in result */
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].cmd == CMD_GET_STATUS_WORD)
++			__assign_bit(i, bits, sts_bits & omnia_gpios[i].bit);
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_STATUS_DWORD)
++			__assign_bit(i, bits, ext_sts_bits &
++					      omnia_gpios[i].bit);
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_CONTROL_STATUS)
++			__assign_bit(i, bits, ext_ctl_bits &
++					      omnia_gpios[i].bit);
++	}
++
++	return 0;
++
++err_unlock:
++	mutex_unlock(&mcu->lock);
++	return err;
++}
++
++static void omnia_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u16 val, mask;
++
++	if (!gpio->ctl_cmd)
++		return;
++
++	mask = gpio->ctl_bit;
++	val = value ? mask : 0;
++
++	omnia_ctl_cmd(mcu, gpio->ctl_cmd, val, mask);
++}
++
++static void omnia_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
++				    unsigned long *bits)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u16 ext_ctl, ext_ctl_mask;
++	u8 ctl, ctl_mask;
++	int i;
++
++	ctl = 0;
++	ctl_mask = 0;
++	ext_ctl = 0;
++	ext_ctl_mask = 0;
++
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].ctl_cmd == CMD_GENERAL_CONTROL) {
++			ctl_mask |= omnia_gpios[i].ctl_bit;
++			if (test_bit(i, bits))
++				ctl |= omnia_gpios[i].ctl_bit;
++		} else if (omnia_gpios[i].ctl_cmd == CMD_EXT_CONTROL) {
++			ext_ctl_mask |= omnia_gpios[i].ctl_bit;
++			if (test_bit(i, bits))
++				ext_ctl |= omnia_gpios[i].ctl_bit;
++		}
++	}
++
++	mutex_lock(&mcu->lock);
++
++	if (ctl_mask)
++		omnia_ctl_cmd_locked(mcu, CMD_GENERAL_CONTROL, ctl, ctl_mask);
++
++	if (ext_ctl_mask)
++		omnia_ctl_cmd_locked(mcu, CMD_EXT_CONTROL, ext_ctl,
++				     ext_ctl_mask);
++
++	mutex_unlock(&mcu->lock);
++}
++
++static bool omnia_gpio_available(struct omnia_mcu *mcu,
++				 const struct omnia_gpio *gpio)
++{
++	if (gpio->feat_mask)
++		return (mcu->features & gpio->feat_mask) == gpio->feat;
++
++	if (gpio->feat)
++		return mcu->features & gpio->feat;
++
++	return true;
++}
++
++static int omnia_gpio_init_valid_mask(struct gpio_chip *gc,
++				      unsigned long *valid_mask,
++				      unsigned int ngpios)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	unsigned int i;
++
++	for (i = 0; i < ngpios; i++) {
++		const struct omnia_gpio *gpio = &omnia_gpios[i];
++
++		if (gpio->cmd || gpio->int_bit)
++			__assign_bit(i, valid_mask,
++				     omnia_gpio_available(mcu, gpio));
++		else
++			__clear_bit(i, valid_mask);
++	}
++
++	return 0;
++}
++
++static void omnia_irq_shutdown(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	mcu->rising &= ~bit;
++	mcu->falling &= ~bit;
++}
++
++static void omnia_irq_mask(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	if (!omnia_gpios[hwirq].cmd)
++		mcu->rising &= ~bit;
++	mcu->mask &= ~bit;
++	gpiochip_disable_irq(gc, hwirq);
++}
++
++static void omnia_irq_unmask(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	gpiochip_enable_irq(gc, hwirq);
++	mcu->mask |= bit;
++	if (!omnia_gpios[hwirq].cmd)
++		mcu->rising |= bit;
++}
++
++static int omnia_irq_set_type(struct irq_data *d, unsigned int type)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	struct device *dev = &mcu->client->dev;
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	if (!(type & IRQ_TYPE_EDGE_BOTH)) {
++		dev_err(dev, "irq %u: unsupported type %u\n", d->irq, type);
++		return -EINVAL;
++	}
++
++	if (type & IRQ_TYPE_EDGE_RISING)
++		mcu->rising |= bit;
++	else
++		mcu->rising &= ~bit;
++
++	if (type & IRQ_TYPE_EDGE_FALLING)
++		mcu->falling |= bit;
++	else
++		mcu->falling &= ~bit;
++
++	return 0;
++}
++
++static void omnia_irq_bus_lock(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	/* nothing to do if MCU firmware does not support new interrupt API */
++	if (!(mcu->features & FEAT_NEW_INT_API))
++		return;
++
++	mutex_lock(&mcu->lock);
++}
++
++/**
++ * omnia_mask_interleave - Interleaves the bytes from @rising and @falling
++ *	@dst: the destination u8 array of interleaved bytes
++ *	@rising: rising mask
++ *	@falling: falling mask
++ *
++ * Interleaves the little-endian bytes from @rising and @falling words.
++ *
++ * If @rising = (r0, r1, r2, r3) and @falling = (f0, f1, f2, f3), the result is
++ * @dst = (r0, f0, r1, f1, r2, f2, r3, f3).
++ *
++ * The MCU receives interrupt mask and reports pending interrupt bitmap int this
++ * interleaved format. The rationale behind it is that the low-indexed bits are
++ * more important - in many cases, the user will be interested only in
++ * interrupts with indexes 0 to 7, and so the system can stop reading after
++ * first 2 bytes (r0, f0), to save time on the slow I2C bus.
++ *
++ * Feel free to remove this function and its inverse, omnia_mask_deinterleave,
++ * and use an appropriate bitmap_* function once such a function exists.
++ */
++static void omnia_mask_interleave(u8 *dst, u32 rising, u32 falling)
++{
++	int i;
++
++	for (i = 0; i < sizeof(u32); ++i) {
++		dst[2 * i] = rising >> (8 * i);
++		dst[2 * i + 1] = falling >> (8 * i);
++	}
++}
++
++/**
++ * omnia_mask_deinterleave - Deinterleaves the bytes into @rising and @falling
++ *	@src: the source u8 array containing the interleaved bytes
++ *	@rising: pointer where to store the rising mask gathered from @src
++ *	@falling: pointer where to store the falling mask gathered from @src
++ *
++ * This is the inverse function to omnia_mask_interleave.
++ */
++static void omnia_mask_deinterleave(const u8 *src, u32 *rising, u32 *falling)
++{
++	int i;
++
++	*rising = *falling = 0;
++
++	for (i = 0; i < sizeof(u32); ++i) {
++		*rising |= src[2 * i] << (8 * i);
++		*falling |= src[2 * i + 1] << (8 * i);
++	}
++}
++
++static void omnia_irq_bus_sync_unlock(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	struct device *dev = &mcu->client->dev;
++	u8 cmd[1 + CMD_INT_ARG_LEN];
++	u32 rising, falling;
++	int err;
++
++	/* nothing to do if MCU firmware does not support new interrupt API */
++	if (!(mcu->features & FEAT_NEW_INT_API))
++		return;
++
++	cmd[0] = CMD_SET_INT_MASK;
++
++	rising = mcu->rising & mcu->mask;
++	falling = mcu->falling & mcu->mask;
++
++	/* interleave the rising and falling bytes into the command arguments */
++	omnia_mask_interleave(&cmd[1], rising, falling);
++
++	dev_dbg(dev, "set int mask %8ph\n", &cmd[1]);
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err) {
++		dev_err(dev, "Cannot set mask: %d\n", err);
++		goto unlock;
++	}
++
++	/*
++	 * Remember which GPIOs have both rising and falling interrupts enabled.
++	 * For those we will cache their value so that .get() method is faster.
++	 * We also need to forget cached values of GPIOs that aren't cached
++	 * anymore.
++	 */
++	mcu->both = rising & falling;
++	mcu->is_cached &= mcu->both;
++
++unlock:
++	mutex_unlock(&mcu->lock);
++}
++
++static void omnia_irq_init_valid_mask(struct gpio_chip *gc,
++				      unsigned long *valid_mask,
++				      unsigned int ngpios)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	unsigned int i;
++
++	for (i = 0; i < ngpios; i++) {
++		const struct omnia_gpio *gpio = &omnia_gpios[i];
++
++		if (gpio->int_bit)
++			__assign_bit(i, valid_mask,
++				     omnia_gpio_available(mcu, gpio));
++		else
++			__clear_bit(i, valid_mask);
++	}
++}
++
++static int omnia_irq_init_hw(struct gpio_chip *gc)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u8 cmd[1 + CMD_INT_ARG_LEN] = {};
++
++	cmd[0] = CMD_SET_INT_MASK;
++
++	return omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++}
++
++/*
++ * Determine how many bytes we need to read from the reply to the
++ * CMD_GET_INT_AND_CLEAR command in order to retrieve all unmasked interrupts.
++ */
++static size_t omnia_irq_compute_pending_length(u32 rising, u32 falling)
++{
++	size_t rlen = 0, flen = 0;
++
++	if (rising)
++		rlen = ((__fls(rising) >> 3) << 1) + 1;
++
++	if (falling)
++		flen = ((__fls(falling) >> 3) << 1) + 2;
++
++	return max(rlen, flen);
++}
++
++static bool omnia_irq_read_pending_new(struct omnia_mcu *mcu,
++				       unsigned long *pending)
++{
++	struct device *dev = &mcu->client->dev;
++	u8 reply[CMD_INT_ARG_LEN] = {};
++	u32 rising, falling;
++	size_t len;
++	int err;
++
++	len = omnia_irq_compute_pending_length(mcu->rising & mcu->mask,
++					       mcu->falling & mcu->mask);
++	if (!len)
++		return false;
++
++	mutex_lock(&mcu->lock);
++
++	err = omnia_cmd_read(mcu->client, CMD_GET_INT_AND_CLEAR, reply,
++			     len);
++	if (err) {
++		mutex_unlock(&mcu->lock);
++		dev_err(dev, "Cannot read pending IRQs: %d\n", err);
++		return false;
++	}
++
++	/* deinterleave the reply bytes into rising and falling */
++	omnia_mask_deinterleave(reply, &rising, &falling);
++
++	rising &= mcu->mask;
++	falling &= mcu->mask;
++	*pending = rising | falling;
++
++	/* cache values for GPIOs that have both edges enabled */
++	mcu->is_cached &= ~(rising & falling);
++	mcu->is_cached |= mcu->both & (rising ^ falling);
++	mcu->cached = (mcu->cached | rising) & ~falling;
++
++	mutex_unlock(&mcu->lock);
++
++	return true;
++}
++
++static int omnia_read_status_word_old_fw(struct omnia_mcu *mcu, u16 *status)
++{
++	int ret;
++
++	ret = omnia_cmd_read_u16(mcu->client, CMD_GET_STATUS_WORD);
++	if (ret < 0)
++		return ret;
++
++	/*
++	 * Old firmware has a bug wherein it never resets the USB port
++	 * overcurrent bits back to zero. Ignore them.
++	 */
++	*status = ret & ~(STS_USB30_OVC | STS_USB31_OVC);
++
++	return 0;
++}
++
++static void button_release_emul_fn(struct work_struct *work)
++{
++	struct omnia_mcu *mcu = container_of(to_delayed_work(work),
++					     struct omnia_mcu,
++					     button_release_emul_work);
++
++	mcu->button_pressed_emul = false;
++	generic_handle_irq(mcu->client->irq);
++}
++
++static void fill_int_from_sts(u32 *rising, u32 *falling, u16 rising_sts,
++			      u16 falling_sts, u16 sts_bit, u32 int_bit)
++{
++	if (rising_sts & sts_bit)
++		*rising |= int_bit;
++	if (falling_sts & sts_bit)
++		*falling |= int_bit;
++}
++
++static bool omnia_irq_read_pending_old(struct omnia_mcu *mcu,
++				       unsigned long *pending)
++{
++	struct device *dev = &mcu->client->dev;
++	u16 status, rising_sts, falling_sts;
++	u32 rising, falling;
++	int ret;
++
++	mutex_lock(&mcu->lock);
++
++	ret = omnia_read_status_word_old_fw(mcu, &status);
++	if (ret < 0) {
++		mutex_unlock(&mcu->lock);
++		dev_err(dev, "Cannot read pending IRQs: %d\n", ret);
++		return false;
++	}
++
++	/*
++	 * The old firmware triggers an interrupt whenever status word changes,
++	 * but does not inform about which bits rose or fell. We need to compute
++	 * this here by comparing with the last status word value.
++	 *
++	 * The STS_BUTTON_PRESSED bit needs special handling, because the old
++	 * firmware clears the STS_BUTTON_PRESSED bit on successful completion
++	 * of the CMD_GET_STATUS_WORD command, resulting in another interrupt:
++	 * - first we get an interrupt, we read the status word where
++	 *   STS_BUTTON_PRESSED is present,
++	 * - MCU clears the STS_BUTTON_PRESSED bit because we read the status
++	 *   word,
++	 * - we get another interrupt because the status word changed again
++	 *   (STS_BUTTON_PRESSED was cleared).
++	 *
++	 * The gpiolib-cdev, gpiolib-sysfs and gpio-keys input driver all call
++	 * the gpiochip's .get() method after an edge event on a requested GPIO
++	 * occurs.
++	 *
++	 * We ensure that the .get() method reads 1 for the button GPIO for some
++	 * time.
++	 */
++
++	if (status & STS_BUTTON_PRESSED) {
++		mcu->button_pressed_emul = true;
++		mod_delayed_work(system_wq, &mcu->button_release_emul_work,
++				 msecs_to_jiffies(FRONT_BUTTON_RELEASE_DELAY));
++	} else if (mcu->button_pressed_emul) {
++		status |= STS_BUTTON_PRESSED;
++	}
++
++	rising_sts = ~mcu->last_status & status;
++	falling_sts = mcu->last_status & ~status;
++
++	mcu->last_status = status;
++
++	/*
++	 * Fill in the relevant interrupt bits from status bits for CARD_DET,
++	 * MSATA_IND and BUTTON_PRESSED.
++	 */
++	rising = 0;
++	falling = 0;
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_CARD_DET, INT_CARD_DET);
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_MSATA_IND, INT_MSATA_IND);
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_BUTTON_PRESSED, INT_BUTTON_PRESSED);
++
++	/* Use only bits that are enabled */
++	rising &= mcu->rising & mcu->mask;
++	falling &= mcu->falling & mcu->mask;
++	*pending = rising | falling;
++
++	mutex_unlock(&mcu->lock);
++
++	return true;
++}
++
++static bool omnia_irq_read_pending(struct omnia_mcu *mcu,
++				   unsigned long *pending)
++{
++	if (mcu->features & FEAT_NEW_INT_API)
++		return omnia_irq_read_pending_new(mcu, pending);
++	else
++		return omnia_irq_read_pending_old(mcu, pending);
++}
++
++static irqreturn_t omnia_irq_thread_handler(int irq, void *dev_id)
++{
++	struct omnia_mcu *mcu = dev_id;
++	struct irq_domain *domain;
++	unsigned long pending;
++	int i;
++
++	if (!omnia_irq_read_pending(mcu, &pending))
++		return IRQ_NONE;
++
++	domain = mcu->gc.irq.domain;
++
++	for_each_set_bit(i, &pending, 32) {
++		unsigned int nested_irq;
++
++		nested_irq = irq_find_mapping(domain, omnia_int_to_gpio_idx[i]);
++
++		handle_nested_irq(nested_irq);
++	}
++
++	return IRQ_RETVAL(pending);
++}
++
++static const char * const front_button_modes[2] = { "mcu", "cpu" };
++
++static ssize_t front_button_mode_show(struct device *dev,
++				      struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	int val;
++
++	if (mcu->features & FEAT_NEW_INT_API) {
++		val = omnia_cmd_read_bit(mcu->client, CMD_GET_STATUS_WORD,
++					 STS_BUTTON_MODE);
++		if (val < 0)
++			return val;
++	} else {
++		val = !!(mcu->last_status & STS_BUTTON_MODE);
++	}
++
++	return sysfs_emit(buf, "%s\n", front_button_modes[val]);
++}
++
++static ssize_t front_button_mode_store(struct device *dev,
++				       struct device_attribute *a,
++				       const char *buf, size_t count)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	u8 mask, val;
++	int err, i;
++
++	mask = CTL_BUTTON_MODE;
++
++	i = sysfs_match_string(front_button_modes, buf);
++	if (i < 0)
++		return i;
++
++	val = i ? mask : 0;
++	err = omnia_ctl_cmd_locked(mcu, CMD_GENERAL_CONTROL, val, mask);
++	if (err)
++		return err;
++
++	return count;
++}
++static DEVICE_ATTR_RW(front_button_mode);
++
++static struct attribute *omnia_mcu_gpio_attrs[] = {
++	&dev_attr_front_button_mode.attr,
++	NULL
++};
++
++const struct attribute_group omnia_mcu_gpio_group = {
++	.attrs = omnia_mcu_gpio_attrs,
++};
++
++static void omnia_mcu_mutex_destroy(void *lock)
++{
++	mutex_destroy(lock);
++}
++
++int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu)
++{
++	bool new_api = mcu->features & FEAT_NEW_INT_API;
++	struct device *dev = &mcu->client->dev;
++	unsigned long irqflags;
++	int err;
++
++	mutex_init(&mcu->lock);
++	err = devm_add_action_or_reset(dev, omnia_mcu_mutex_destroy,
++				       &mcu->lock);
++	if (err)
++		return err;
++
++	mcu->gc.request = omnia_gpio_request;
++	mcu->gc.get_direction = omnia_gpio_get_direction;
++	mcu->gc.direction_input = omnia_gpio_direction_input;
++	mcu->gc.direction_output = omnia_gpio_direction_output;
++	mcu->gc.get = omnia_gpio_get;
++	mcu->gc.get_multiple = omnia_gpio_get_multiple;
++	mcu->gc.set = omnia_gpio_set;
++	mcu->gc.set_multiple = omnia_gpio_set_multiple;
++	mcu->gc.init_valid_mask = omnia_gpio_init_valid_mask;
++	mcu->gc.can_sleep = true;
++	mcu->gc.names = omnia_mcu_gpio_templates;
++	mcu->gc.base = -1;
++	mcu->gc.ngpio = ARRAY_SIZE(omnia_gpios);
++	mcu->gc.label = "Turris Omnia MCU GPIOs";
++	mcu->gc.parent = dev;
++	mcu->gc.owner = THIS_MODULE;
++
++	mcu->ic.name = "Turris Omnia MCU interrupts";
++	mcu->ic.irq_shutdown = omnia_irq_shutdown;
++	mcu->ic.irq_mask = omnia_irq_mask;
++	mcu->ic.irq_unmask = omnia_irq_unmask;
++	mcu->ic.irq_set_type = omnia_irq_set_type;
++	mcu->ic.irq_bus_lock = omnia_irq_bus_lock;
++	mcu->ic.irq_bus_sync_unlock = omnia_irq_bus_sync_unlock;
++
++	mcu->gc.irq.chip = &mcu->ic;
++	/* This will let us handle the parent IRQ in the driver */
++	mcu->gc.irq.parent_handler = NULL;
++	mcu->gc.irq.num_parents = 0;
++	mcu->gc.irq.parents = NULL;
++	mcu->gc.irq.default_type = IRQ_TYPE_NONE;
++	mcu->gc.irq.handler = handle_bad_irq;
++	mcu->gc.irq.threaded = true;
++	if (new_api)
++		mcu->gc.irq.init_hw = omnia_irq_init_hw;
++	mcu->gc.irq.init_valid_mask = omnia_irq_init_valid_mask;
++
++	err = devm_gpiochip_add_data(dev, &mcu->gc, mcu);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot add GPIO chip\n");
++
++	/*
++	 * Before requesting the interrupt, if firmware does not support the new
++	 * interrupt API, we need to cache the value of the status word, so that
++	 * when it changes, we may compare the new value with the cached one in
++	 * the interrupt handler.
++	 */
++	if (!new_api) {
++		err = omnia_read_status_word_old_fw(mcu, &mcu->last_status);
++		if (err < 0)
++			return dev_err_probe(dev, err,
++					     "Cannot read status word\n");
++
++		INIT_DELAYED_WORK(&mcu->button_release_emul_work,
++				  button_release_emul_fn);
++	}
++
++	irqflags = IRQF_ONESHOT;
++	if (new_api)
++		irqflags |= IRQF_TRIGGER_LOW;
++	else
++		irqflags |= IRQF_TRIGGER_FALLING;
++
++	err = devm_request_threaded_irq(dev, mcu->client->irq, NULL,
++					omnia_irq_thread_handler, irqflags,
++					"turris-omnia-mcu", mcu);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot request IRQ\n");
++
++	if (!new_api) {
++		/*
++		 * The button_release_emul_work has to be initialized before the
++		 * thread is requested, and on driver remove it needs to be
++		 * canceled before the thread is freed. Therefore we can't use
++		 * devm_delayed_work_autocancel() directly, because the order
++		 *   devm_delayed_work_autocancel();
++		 *   devm_request_threaded_irq();
++		 * would cause improper release order:
++		 *   free_irq();
++		 *   cancel_delayed_work_sync();
++		 * Instead we first initialize the work above, and only now
++		 * after IRQ is requested we add the work devm action.
++		 */
++		err = devm_add_action(dev, devm_delayed_work_drop,
++				      &mcu->button_release_emul_work);
++		if (err)
++			return err;
++	}
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index f18b745b223c..778d2d06b3e6 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -8,9 +8,13 @@
+ #ifndef __TURRIS_OMNIA_MCU_H
+ #define __TURRIS_OMNIA_MCU_H
+ 
++#include <linux/bitops.h>
++#include <linux/gpio/driver.h>
+ #include <linux/i2c.h>
+ #include <linux/if_ether.h>
++#include <linux/mutex.h>
+ #include <linux/types.h>
++#include <linux/workqueue.h>
+ #include <asm/byteorder.h>
+ 
+ struct omnia_mcu {
+@@ -22,8 +26,28 @@ struct omnia_mcu {
+ 	u64 board_serial_number;
+ 	u8 board_first_mac[ETH_ALEN];
+ 	u8 board_revision;
++
++	/* GPIO chip */
++	struct gpio_chip gc;
++	struct irq_chip ic;
++	struct mutex lock;
++	u32 mask, rising, falling, both, cached, is_cached;
++	/* Old MCU firmware handling needs the following */
++	struct delayed_work button_release_emul_work;
++	u16 last_status;
++	bool button_pressed_emul;
+ };
+ 
++static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
++				  size_t len)
++{
++	int ret;
++
++	ret = i2c_master_send(client, cmd, len);
++
++	return ret < 0 ? ret : 0;
++}
++
+ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
+ 				 void *reply, unsigned int len)
+ {
+@@ -48,6 +72,40 @@ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
+ 	return 0;
+ }
+ 
++/* Returns 0 on success */
++static inline int omnia_cmd_read_bits(const struct i2c_client *client, u8 cmd,
++				      u32 bits, u32 *dst)
++{
++	__le32 reply;
++	int err;
++
++	if (!bits) {
++		*dst = 0;
++		return 0;
++	}
++
++	err = omnia_cmd_read(client, cmd, &reply, (__fls(bits) >> 3) + 1);
++	if (err)
++		return err;
++
++	*dst = le32_to_cpu(reply) & bits;
++
++	return 0;
++}
++
++static inline int omnia_cmd_read_bit(const struct i2c_client *client, u8 cmd,
++				     u32 bit)
++{
++	u32 reply;
++	int err;
++
++	err = omnia_cmd_read_bits(client, cmd, bit, &reply);
++	if (err)
++		return err;
++
++	return !!reply;
++}
++
+ static inline int omnia_cmd_read_u16(const struct i2c_client *client, u8 cmd)
+ {
+ 	__le16 reply;
+@@ -68,4 +126,8 @@ static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
+ 	return err ?: reply;
+ }
+ 
++extern const struct attribute_group omnia_mcu_gpio_group;
++
++int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
++
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-3-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch b/target/linux/mvebu/patches-5.15/103-3-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
new file mode 100644
index 0000000000..58b52975c7
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-3-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
@@ -0,0 +1,446 @@
+From 1a72f0785939089456965e0f807387728d17d58c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 12:16:25 +0200
+Subject: [PATCH 3/8] platform: cznic: turris-omnia-mcu: Add support for
+ poweroff and wakeup
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for true board poweroff (MCU can disable all unnecessary
+voltage regulators) and wakeup at a specified time, implemented via a
+RTC driver so that the rtcwake utility can be used to configure it.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  16 +
+ drivers/platform/cznic/Kconfig                |   4 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |   5 +
+ .../cznic/turris-omnia-mcu-sys-off-wakeup.c   | 277 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  22 ++
+ 6 files changed, 325 insertions(+)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+index 91e107583edd..b2c667f9bf48 100644
+--- a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -38,6 +38,22 @@ Description:	(RW) The front button on the Turris Omnia router can be
+ 
+ 		Format: %s.
+ 
++What:		/sys/bus/i2c/devices/<mcu_device>/front_button_poweron
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RW) Newer versions of the microcontroller firmware of the
++		Turris Omnia router support powering off the router into true
++		low power mode. The router can be powered on by pressing the
++		front button.
++
++		This file configures whether front button power on is enabled.
++
++		This file is present only if the power off feature is supported
++		by the firmware.
++
++		Format: %i.
++
+ What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
+ Date:		May 2024
+ KernelVersion:	6.9
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index 3a8c3edcd7e6..0a752aa654fa 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -19,10 +19,14 @@ config TURRIS_OMNIA_MCU
+ 	depends on I2C
+ 	select GPIOLIB
+ 	select GPIOLIB_IRQCHIP
++	select RTC_CLASS
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
+ 	  The features include:
++	  - board poweroff into true low power mode (with voltage regulators
++	    disabled) and the ability to configure wake up from this mode (via
++	    rtcwake)
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+ 	      configured either to generate press events to the CPU or to change
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index a6177f5b4fff..6f1470d1f673 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -3,3 +3,4 @@
+ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index 8bb38b910f10..c2ff72fbad23 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -160,6 +160,7 @@ static const struct attribute_group omnia_mcu_base_group = {
+ static const struct attribute_group *omnia_mcu_groups[] = {
+ 	&omnia_mcu_base_group,
+ 	&omnia_mcu_gpio_group,
++	&omnia_mcu_poweroff_group,
+ 	NULL
+ };
+ 
+@@ -313,6 +314,10 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 					     "Cannot read board info\n");
+ 	}
+ 
++	err = omnia_mcu_register_sys_off_and_wakeup(mcu);
++	if (err)
++		return err;
++
+ 	return omnia_mcu_register_gpiochip(mcu);
+ }
+ 
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c b/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+new file mode 100644
+index 000000000000..a4a5cfede8f1
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+@@ -0,0 +1,277 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU system off and RTC wakeup driver
++ *
++ * This is not a true RTC driver (in the sense that it does not provide a
++ * real-time clock), rather the MCU implements a wakeup from powered off state
++ * at a specified time relative to MCU boot, and we expose this feature via RTC
++ * alarm, so that it can be used via the rtcwake command, which is the standard
++ * Linux command for this.
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/crc32.h>
++#include <linux/delay.h>
++#include <linux/i2c.h>
++#include <linux/reboot.h>
++#include <linux/rtc.h>
++#include <linux/sysfs.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++
++#include "turris-omnia-mcu.h"
++
++static int omnia_get_uptime_wakeup(const struct i2c_client *client, u32 *uptime,
++				   u32 *wakeup)
++{
++	__le32 reply[2];
++	int err;
++
++	err = omnia_cmd_read(client, CMD_GET_UPTIME_AND_WAKEUP, reply,
++			     sizeof(reply));
++	if (err)
++		return err;
++
++	if (uptime)
++		*uptime = le32_to_cpu(reply[0]);
++
++	if (wakeup)
++		*wakeup = le32_to_cpu(reply[1]);
++
++	return 0;
++}
++
++static int omnia_read_time(struct device *dev, struct rtc_time *tm)
++{
++	u32 uptime;
++	int err;
++
++	err = omnia_get_uptime_wakeup(to_i2c_client(dev), &uptime, NULL);
++	if (err)
++		return err;
++
++	rtc_time64_to_tm(uptime, tm);
++
++	return 0;
++}
++
++static int omnia_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++	u32 wakeup;
++	int err;
++
++	err = omnia_get_uptime_wakeup(client, NULL, &wakeup);
++	if (err)
++		return err;
++
++	alrm->enabled = !!wakeup;
++	rtc_time64_to_tm(wakeup ?: mcu->rtc_alarm, &alrm->time);
++
++	return 0;
++}
++
++static int omnia_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++
++	mcu->rtc_alarm = rtc_tm_to_time64(&alrm->time);
++
++	if (alrm->enabled)
++		return omnia_cmd_write_u32(client, CMD_SET_WAKEUP,
++					   mcu->rtc_alarm);
++
++	return 0;
++}
++
++static int omnia_alarm_irq_enable(struct device *dev, unsigned int enabled)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++
++	return omnia_cmd_write_u32(client, CMD_SET_WAKEUP,
++				   enabled ? mcu->rtc_alarm : 0);
++}
++
++static const struct rtc_class_ops omnia_rtc_ops = {
++	.read_time		= omnia_read_time,
++	.read_alarm		= omnia_read_alarm,
++	.set_alarm		= omnia_set_alarm,
++	.alarm_irq_enable	= omnia_alarm_irq_enable,
++};
++
++static struct omnia_mcu *omnia_power_off_mcu_ptr;
++
++static void omnia_power_off(void)
++{
++	struct omnia_mcu *mcu = omnia_power_off_mcu_ptr;
++	__be32 tmp;
++	u8 cmd[9];
++	u16 arg;
++	int err;
++
++	if (mcu->front_button_poweron)
++		arg = CMD_POWER_OFF_POWERON_BUTTON;
++	else
++		arg = 0;
++
++	cmd[0] = CMD_POWER_OFF;
++	put_unaligned_le16(CMD_POWER_OFF_MAGIC, &cmd[1]);
++	put_unaligned_le16(arg, &cmd[3]);
++
++	/*
++	 * Although all values from and to MCU are passed in little-endian, the
++	 * MCU's CRC unit uses big-endian CRC32 polynomial (0x04c11db7), so we
++	 * need to use crc32_be() here.
++	 */
++	tmp = cpu_to_be32(get_unaligned_le32(&cmd[1]));
++	put_unaligned_le32(crc32_be(0xffffffff, (void *)&tmp, sizeof(tmp)),
++			   &cmd[5]);
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err)
++		dev_err(&mcu->client->dev,
++			"Unable to send the poweroff command: %d\n", err);
++}
++
++static int omnia_restart(struct notifier_block *nb, unsigned long reboot_mode,
++			 void *restart_cmd)
++{
++	struct omnia_mcu *mcu = container_of(nb, struct omnia_mcu, restart_nb);
++	u8 cmd[3];
++	int err;
++
++	cmd[0] = CMD_GENERAL_CONTROL;
++
++	if (reboot_mode == REBOOT_HARD)
++		cmd[1] = cmd[2] = CTL_HARD_RST;
++	else
++		cmd[1] = cmd[2] = CTL_LIGHT_RST;
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err)
++		dev_err(&mcu->client->dev,
++			"Unable to send the restart command: %d\n", err);
++
++	/*
++	 * MCU needs a little bit to process the I2C command, otherwise it will
++	 * do a light reset based on SOC SYSRES_OUT pin.
++	 */
++	mdelay(1);
++
++	return NOTIFY_DONE;
++}
++
++static ssize_t front_button_poweron_show(struct device *dev,
++					 struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%d\n", mcu->front_button_poweron);
++}
++
++static ssize_t front_button_poweron_store(struct device *dev,
++					  struct device_attribute *a,
++					  const char *buf, size_t count)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	bool val;
++	int err;
++
++	err = kstrtobool(buf, &val);
++	if (err)
++		return err;
++
++	mcu->front_button_poweron = val;
++
++	return count;
++}
++static DEVICE_ATTR_RW(front_button_poweron);
++
++static struct attribute *omnia_mcu_poweroff_attrs[] = {
++	&dev_attr_front_button_poweron.attr,
++	NULL
++};
++
++static umode_t poweroff_attrs_visible(struct kobject *kobj, struct attribute *a,
++				      int n)
++{
++	struct device *dev = kobj_to_dev(kobj);
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	if (mcu->features & FEAT_POWEROFF_WAKEUP)
++		return a->mode;
++
++	return 0;
++}
++
++const struct attribute_group omnia_mcu_poweroff_group = {
++	.attrs = omnia_mcu_poweroff_attrs,
++	.is_visible = poweroff_attrs_visible,
++};
++
++static void omnia_mcu_unregister_restart(void *ptr)
++{
++	struct omnia_mcu *mcu = ptr;
++
++	unregister_restart_handler(&mcu->restart_nb);
++}
++
++static void omnia_mcu_unregister_poweroff(void *ptr)
++{
++	struct omnia_mcu *mcu = ptr;
++
++	pm_power_off = mcu->prev_pm_power_off;
++}
++
++int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	int err;
++
++	/* MCU restart is always available */
++	mcu->restart_nb.notifier_call = omnia_restart;
++	mcu->restart_nb.priority = 0;
++	err = register_restart_handler(&mcu->restart_nb);
++	if (err)
++		return dev_err_probe(dev, err,
++				     "Cannot register system restart handler\n");
++
++	err = devm_add_action_or_reset(dev, omnia_mcu_unregister_restart, mcu);
++	if (err)
++		return err;
++
++	/*
++	 * Poweroff and wakeup are available only if POWEROFF_WAKEUP feature is
++	 * present.
++	 */
++	if (!(mcu->features & FEAT_POWEROFF_WAKEUP))
++		return 0;
++
++	omnia_power_off_mcu_ptr = mcu;
++	mcu->prev_pm_power_off = pm_power_off;
++	pm_power_off = omnia_power_off;
++
++	err = devm_add_action_or_reset(dev, omnia_mcu_unregister_poweroff, mcu);
++	if (err)
++		return err;
++
++	mcu->rtcdev = devm_rtc_allocate_device(dev);
++	if (IS_ERR(mcu->rtcdev))
++		return dev_err_probe(dev, PTR_ERR(mcu->rtcdev),
++				     "Cannot allocate RTC device\n");
++
++	mcu->rtcdev->ops = &omnia_rtc_ops;
++	mcu->rtcdev->range_max = U32_MAX;
++
++	err = devm_rtc_register_device(mcu->rtcdev);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot register RTC device\n");
++
++	mcu->front_button_poweron = true;
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index 778d2d06b3e6..7df650972778 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -13,9 +13,11 @@
+ #include <linux/i2c.h>
+ #include <linux/if_ether.h>
+ #include <linux/mutex.h>
++#include <linux/rtc.h>
+ #include <linux/types.h>
+ #include <linux/workqueue.h>
+ #include <asm/byteorder.h>
++#include <asm/unaligned.h>
+ 
+ struct omnia_mcu {
+ 	struct i2c_client *client;
+@@ -36,6 +38,13 @@ struct omnia_mcu {
+ 	struct delayed_work button_release_emul_work;
+ 	u16 last_status;
+ 	bool button_pressed_emul;
++
++	/* RTC device for configuring wake-up */
++	struct rtc_device *rtcdev;
++	u32 rtc_alarm;
++	bool front_button_poweron;
++	struct notifier_block restart_nb;
++	void (*prev_pm_power_off)(void);
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -48,6 +57,17 @@ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++static inline int omnia_cmd_write_u32(const struct i2c_client *client, u8 cmd,
++				      u32 val)
++{
++	u8 buf[5];
++
++	buf[0] = cmd;
++	put_unaligned_le32(val, &buf[1]);
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
+ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
+ 				 void *reply, unsigned int len)
+ {
+@@ -127,7 +147,9 @@ static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
+ }
+ 
+ extern const struct attribute_group omnia_mcu_gpio_group;
++extern const struct attribute_group omnia_mcu_poweroff_group;
+ 
+ int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
++int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
+ 
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-4-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch b/target/linux/mvebu/patches-5.15/103-4-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
new file mode 100644
index 0000000000..0acde399bd
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-4-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
@@ -0,0 +1,251 @@
+From f901e6662635b8a4a9e6977559ec4496a691a7e0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 12:21:40 +0200
+Subject: [PATCH 4/8] platform: cznic: turris-omnia-mcu: Add support for MCU
+ watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for the watchdog mechanism provided by the MCU.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/platform/cznic/Kconfig                |   2 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |   4 +
+ .../cznic/turris-omnia-mcu-watchdog.c         | 122 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  24 ++++
+ 5 files changed, 153 insertions(+)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index 0a752aa654fa..e2649cdecc38 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -20,6 +20,7 @@ config TURRIS_OMNIA_MCU
+ 	select GPIOLIB
+ 	select GPIOLIB_IRQCHIP
+ 	select RTC_CLASS
++	select WATCHDOG_CORE
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
+@@ -27,6 +28,7 @@ config TURRIS_OMNIA_MCU
+ 	  - board poweroff into true low power mode (with voltage regulators
+ 	    disabled) and the ability to configure wake up from this mode (via
+ 	    rtcwake)
++	  - MCU watchdog
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+ 	      configured either to generate press events to the CPU or to change
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index 6f1470d1f673..a43997a12d74 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -4,3 +4,4 @@ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-watchdog.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index c2ff72fbad23..b136635a175b 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -318,6 +318,10 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 	if (err)
+ 		return err;
+ 
++	err = omnia_mcu_register_watchdog(mcu);
++	if (err)
++		return err;
++
+ 	return omnia_mcu_register_gpiochip(mcu);
+ }
+ 
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-watchdog.c b/drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+new file mode 100644
+index 000000000000..6685166bc4c7
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+@@ -0,0 +1,122 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU watchdog driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/moduleparam.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/watchdog.h>
++
++#include "turris-omnia-mcu.h"
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++static int omnia_wdt_start(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 1);
++}
++
++static int omnia_wdt_stop(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 0);
++}
++
++static int omnia_wdt_ping(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 1);
++}
++
++static int omnia_wdt_set_timeout(struct watchdog_device *wdt,
++				 unsigned int timeout)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u16(mcu->client, CMD_SET_WDT_TIMEOUT,
++				   timeout * 10);
++}
++
++static unsigned int omnia_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++	int ret;
++
++	ret = omnia_cmd_read_u16(mcu->client, CMD_GET_WDT_TIMELEFT);
++	if (ret < 0) {
++		dev_err(&mcu->client->dev, "Cannot get watchdog timeleft: %d\n",
++			ret);
++		return 0;
++	}
++
++	return ret / 10;
++}
++
++static const struct watchdog_info omnia_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Turris Omnia MCU Watchdog",
++};
++
++static const struct watchdog_ops omnia_wdt_ops = {
++	.owner		= THIS_MODULE,
++	.start		= omnia_wdt_start,
++	.stop		= omnia_wdt_stop,
++	.ping		= omnia_wdt_ping,
++	.set_timeout	= omnia_wdt_set_timeout,
++	.get_timeleft	= omnia_wdt_get_timeleft,
++};
++
++int omnia_mcu_register_watchdog(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	int ret;
++
++	if (!(mcu->features & FEAT_WDT_PING))
++		return 0;
++
++	mcu->wdt.info = &omnia_wdt_info;
++	mcu->wdt.ops = &omnia_wdt_ops;
++	mcu->wdt.parent = dev;
++	mcu->wdt.min_timeout = 1;
++	mcu->wdt.max_timeout = 6553; /* 65535 deciseconds */
++
++	mcu->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&mcu->wdt, timeout, dev);
++
++	watchdog_set_drvdata(&mcu->wdt, mcu);
++
++	omnia_wdt_set_timeout(&mcu->wdt, mcu->wdt.timeout);
++
++	ret = omnia_cmd_read_u8(mcu->client, CMD_GET_WATCHDOG_STATE);
++	if (ret < 0)
++		return dev_err_probe(dev, ret,
++				     "Cannot get MCU watchdog state\n");
++
++	if (ret)
++		set_bit(WDOG_HW_RUNNING, &mcu->wdt.status);
++
++	watchdog_set_nowayout(&mcu->wdt, nowayout);
++	watchdog_stop_on_reboot(&mcu->wdt);
++	ret = devm_watchdog_register_device(dev, &mcu->wdt);
++	if (ret)
++		return dev_err_probe(dev, ret,
++				     "Cannot register MCU watchdog\n");
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index 7df650972778..e7a2af0919ae 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -15,6 +15,7 @@
+ #include <linux/mutex.h>
+ #include <linux/rtc.h>
+ #include <linux/types.h>
++#include <linux/watchdog.h>
+ #include <linux/workqueue.h>
+ #include <asm/byteorder.h>
+ #include <asm/unaligned.h>
+@@ -45,6 +46,9 @@ struct omnia_mcu {
+ 	bool front_button_poweron;
+ 	struct notifier_block restart_nb;
+ 	void (*prev_pm_power_off)(void);
++
++	/* MCU watchdog */
++	struct watchdog_device wdt;
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -57,6 +61,25 @@ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++static inline int omnia_cmd_write_u8(const struct i2c_client *client, u8 cmd,
++				     u8 val)
++{
++	u8 buf[2] = { cmd, val };
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
++static inline int omnia_cmd_write_u16(const struct i2c_client *client, u8 cmd,
++				      u16 val)
++{
++	u8 buf[3];
++
++	buf[0] = cmd;
++	put_unaligned_le16(val, &buf[1]);
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
+ static inline int omnia_cmd_write_u32(const struct i2c_client *client, u8 cmd,
+ 				      u32 val)
+ {
+@@ -151,5 +174,6 @@ extern const struct attribute_group omnia_mcu_poweroff_group;
+ 
+ int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
+ int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
++int omnia_mcu_register_watchdog(struct omnia_mcu *mcu);
+ 
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch b/target/linux/mvebu/patches-5.15/103-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
new file mode 100644
index 0000000000..6fdd284d09
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
@@ -0,0 +1,230 @@
+From df2c6ddda0125b4a66c1964c6b2c53f02110b927 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 17 Jan 2024 14:03:14 +0100
+Subject: [PATCH 5/8] platform: cznic: turris-omnia-mcu: Add support for MCU
+ provided TRNG
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for true random number generator provided by the MCU.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/platform/cznic/Kconfig                |   2 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |   6 +-
+ .../platform/cznic/turris-omnia-mcu-gpio.c    |   2 +-
+ .../platform/cznic/turris-omnia-mcu-trng.c    | 100 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |   8 ++
+ 6 files changed, 117 insertions(+), 2 deletions(-)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-trng.c
+
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index e2649cdecc38..750d5f47dba8 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -19,6 +19,7 @@ config TURRIS_OMNIA_MCU
+ 	depends on I2C
+ 	select GPIOLIB
+ 	select GPIOLIB_IRQCHIP
++	select HW_RANDOM
+ 	select RTC_CLASS
+ 	select WATCHDOG_CORE
+ 	help
+@@ -28,6 +29,7 @@ config TURRIS_OMNIA_MCU
+ 	  - board poweroff into true low power mode (with voltage regulators
+ 	    disabled) and the ability to configure wake up from this mode (via
+ 	    rtcwake)
++	  - true random number generator (if available on the MCU)
+ 	  - MCU watchdog
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index a43997a12d74..8fd4c6cbcb1b 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -4,4 +4,5 @@ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-trng.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-watchdog.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index b136635a175b..d96c1366a73b 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -322,7 +322,11 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 	if (err)
+ 		return err;
+ 
+-	return omnia_mcu_register_gpiochip(mcu);
++	err = omnia_mcu_register_gpiochip(mcu);
++	if (err)
++		return err;
++
++	return omnia_mcu_register_trng(mcu);
+ }
+ 
+ static const struct of_device_id of_omnia_mcu_match[] = {
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-gpio.c b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+index ee5bd64a988f..bc58301cb8b8 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-gpio.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+@@ -160,7 +160,7 @@ static const struct omnia_gpio {
+ };
+ 
+ /* mapping from interrupts to indexes of GPIOs in the omnia_gpios array */
+-static const u8 omnia_int_to_gpio_idx[32] = {
++const u8 omnia_int_to_gpio_idx[32] = {
+ 	[__bf_shf(INT_CARD_DET)]		= 4,
+ 	[__bf_shf(INT_MSATA_IND)]		= 5,
+ 	[__bf_shf(INT_USB30_OVC)]		= 6,
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-trng.c b/drivers/platform/cznic/turris-omnia-mcu-trng.c
+new file mode 100644
+index 000000000000..fff9ef5e7e11
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-trng.c
+@@ -0,0 +1,100 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU TRNG driver
++ *
++ * 2024 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/completion.h>
++#include <linux/devm-helpers.h>
++#include <linux/irqdomain.h>
++#include <linux/minmax.h>
++#include <linux/module.h>
++#include <linux/string.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++
++#include "turris-omnia-mcu.h"
++
++#define CMD_TRNG_MAX_ENTROPY_LEN	64
++
++static irqreturn_t omnia_trng_irq_handler(int irq, void *dev_id)
++{
++	struct omnia_mcu *mcu = dev_id;
++
++	complete(&mcu->trng_completion);
++
++	return IRQ_HANDLED;
++}
++
++static int omnia_trng_read(struct hwrng *rng, void *data, size_t max, bool wait)
++{
++	struct omnia_mcu *mcu = (struct omnia_mcu *)rng->priv;
++	u8 reply[1 + CMD_TRNG_MAX_ENTROPY_LEN];
++	int err, bytes;
++
++	if (!wait && !completion_done(&mcu->trng_completion))
++		return 0;
++
++	do {
++		if (wait_for_completion_interruptible(&mcu->trng_completion))
++			return -EINTR;
++
++		err = omnia_cmd_read(mcu->client, CMD_TRNG_COLLECT_ENTROPY,
++				     reply, sizeof(reply));
++		if (err)
++			return err;
++
++		bytes = min3((size_t)reply[0], max,
++			     (size_t)CMD_TRNG_MAX_ENTROPY_LEN);
++	} while (wait && !bytes);
++
++	memcpy(data, &reply[1], bytes);
++
++	return bytes;
++}
++
++static void omnia_mcu_irq_destroy_mapping(void *res)
++{
++	irq_dispose_mapping((unsigned int)(unsigned long)res);
++}
++
++int omnia_mcu_register_trng(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	unsigned int irq;
++	u8 irq_idx;
++	int err;
++
++	if (!(mcu->features & FEAT_TRNG))
++		return 0;
++
++	irq_idx = omnia_int_to_gpio_idx[__bf_shf(INT_TRNG)];
++	irq = irq_create_mapping(mcu->gc.irq.domain, irq_idx);
++	if (!irq)
++		return dev_err_probe(dev, -ENXIO, "Cannot map TRNG IRQ\n");
++
++	err = devm_add_action_or_reset(dev, omnia_mcu_irq_destroy_mapping,
++				       (void *)irq);
++	if (err)
++		return err;
++
++	init_completion(&mcu->trng_completion);
++
++	err = devm_request_threaded_irq(dev, irq, NULL, omnia_trng_irq_handler,
++					IRQF_ONESHOT, "turris-omnia-mcu-trng",
++					mcu);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot request TRNG IRQ\n");
++
++	mcu->trng.name = "turris-omnia-mcu-trng";
++	mcu->trng.read = omnia_trng_read;
++	mcu->trng.priv = (unsigned long)mcu;
++
++	err = devm_hwrng_register(dev, &mcu->trng);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot register TRNG\n");
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index e7a2af0919ae..d83c2bdf63b8 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -9,7 +9,9 @@
+ #define __TURRIS_OMNIA_MCU_H
+ 
+ #include <linux/bitops.h>
++#include <linux/completion.h>
+ #include <linux/gpio/driver.h>
++#include <linux/hw_random.h>
+ #include <linux/i2c.h>
+ #include <linux/if_ether.h>
+ #include <linux/mutex.h>
+@@ -49,6 +51,10 @@ struct omnia_mcu {
+ 
+ 	/* MCU watchdog */
+ 	struct watchdog_device wdt;
++
++	/* true random number generator */
++	struct hwrng trng;
++	struct completion trng_completion;
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -169,11 +175,13 @@ static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
+ 	return err ?: reply;
+ }
+ 
++extern const u8 omnia_int_to_gpio_idx[32];
+ extern const struct attribute_group omnia_mcu_gpio_group;
+ extern const struct attribute_group omnia_mcu_poweroff_group;
+ 
+ int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
+ int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
++int omnia_mcu_register_trng(struct omnia_mcu *mcu);
+ int omnia_mcu_register_watchdog(struct omnia_mcu *mcu);
+ 
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-6-platform-cznic-turris-omnia-mcu-Add-support-for-digi.patch b/target/linux/mvebu/patches-5.15/103-6-platform-cznic-turris-omnia-mcu-Add-support-for-digi.patch
new file mode 100644
index 0000000000..6dc58d90cf
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-6-platform-cznic-turris-omnia-mcu-Add-support-for-digi.patch
@@ -0,0 +1,564 @@
+From dd9748f8530aed1f396500f798af498ca2f6522d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 21 Feb 2024 16:46:21 +0100
+Subject: [PATCH 6/8] platform: cznic: turris-omnia-mcu: Add support for
+ digital message signing via debugfs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for digital message signing with private key stored in the
+MCU. Boards with MKL MCUs have a NIST256p ECDSA private key created
+when manufactured. The private key is not readable from the MCU, but
+MCU allows for signing messages with it and retrieving the public key.
+
+As described in a similar commit 50524d787de3 ("firmware:
+turris-mox-rwtm: support ECDSA signatures via debugfs"):
+  The optimal solution would be to register an akcipher provider via
+  kernel's crypto API, but crypto API does not yet support accessing
+  akcipher API from userspace (and probably won't for some time, see
+  https://www.spinics.net/lists/linux-crypto/msg38388.html).
+
+Therefore we add support for accessing this signature generation
+mechanism via debugfs for now, so that userspace can access it.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../ABI/testing/debugfs-turris-omnia-mcu      |  13 +
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  13 +
+ drivers/platform/cznic/Kconfig                |   2 +
+ drivers/platform/cznic/Makefile               |  12 +-
+ .../platform/cznic/turris-omnia-mcu-base.c    |  45 ++-
+ .../platform/cznic/turris-omnia-mcu-debugfs.c | 259 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  40 ++-
+ 7 files changed, 373 insertions(+), 11 deletions(-)
+ create mode 100644 Documentation/ABI/testing/debugfs-turris-omnia-mcu
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-debugfs.c
+
+diff --git a/Documentation/ABI/testing/debugfs-turris-omnia-mcu b/Documentation/ABI/testing/debugfs-turris-omnia-mcu
+new file mode 100644
+index 000000000000..2f9b3b765a6d
+--- /dev/null
++++ b/Documentation/ABI/testing/debugfs-turris-omnia-mcu
+@@ -0,0 +1,13 @@
++What:		/sys/kernel/debug/turris-omnia-mcu/do_sign
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:
++
++		======= ===========================================================
++		(Write) Message to sign with the ECDSA private key stored in MCU.
++		        The message must be exactly 32 bytes long (since this is
++		        intended to be a SHA-256 hash).
++		(Read)  The resulting signature, 64 bytes. This contains the R and
++			S values of the ECDSA signature, both in big-endian format.
++		======= ===========================================================
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+index b2c667f9bf48..f856e02551ee 100644
+--- a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -90,6 +90,19 @@ Description:	(RO) Contains the microcontroller type (STM32, GD32, MKL).
+ 
+ 		Format: %s.
+ 
++What:		/sys/bus/i2c/devices/<mcu_device>/public_key
++Date:		May 2024
++KernelVersion:	6.9
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains board ECDSA public key.
++
++		Only available if MCU supports signing messages with the ECDSA
++		algorithm. If so, the board has a private key stored in the MCU
++		that was generated during manufacture and cannot be retrieved
++		from the MCU.
++
++		Format: %s.
++
+ What:		/sys/bus/i2c/devices/<mcu_device>/reset_selector
+ Date:		May 2024
+ KernelVersion:	6.9
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index 750d5f47dba8..2d45495c0a2d 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -30,6 +30,8 @@ config TURRIS_OMNIA_MCU
+ 	    disabled) and the ability to configure wake up from this mode (via
+ 	    rtcwake)
+ 	  - true random number generator (if available on the MCU)
++	  - ECDSA message signing with board private key (if available on the
++	    MCU)
+ 	  - MCU watchdog
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index 8fd4c6cbcb1b..22ac5075b750 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -1,8 +1,10 @@
+ # SPDX-License-Identifier: GPL-2.0-only
+ 
+ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+-turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+-turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+-turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
+-turris-omnia-mcu-objs		+= turris-omnia-mcu-trng.o
+-turris-omnia-mcu-objs		+= turris-omnia-mcu-watchdog.o
++turris-omnia-mcu-objs-y		:= turris-omnia-mcu-base.o
++turris-omnia-mcu-objs-y		+= turris-omnia-mcu-gpio.o
++turris-omnia-mcu-objs-y		+= turris-omnia-mcu-sys-off-wakeup.o
++turris-omnia-mcu-objs-y		+= turris-omnia-mcu-trng.o
++turris-omnia-mcu-objs-y		+= turris-omnia-mcu-watchdog.o
++turris-omnia-mcu-objs-$(CONFIG_DEBUG_FS) += turris-omnia-mcu-debugfs.o
++turris-omnia-mcu-objs		:= $(turris-omnia-mcu-objs-y)
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index d96c1366a73b..0e6129a95754 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -124,6 +124,16 @@ static ssize_t board_revision_show(struct device *dev,
+ }
+ static DEVICE_ATTR_RO(board_revision);
+ 
++static ssize_t public_key_show(struct device *dev, struct device_attribute *a,
++			       char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%*phN\n", OMNIA_MCU_CRYPTO_PUBLIC_KEY_LEN,
++			  mcu->board_public_key);
++}
++static DEVICE_ATTR_RO(public_key);
++
+ static struct attribute *omnia_mcu_base_attrs[] = {
+ 	&dev_attr_fw_version_hash_application.attr,
+ 	&dev_attr_fw_version_hash_bootloader.attr,
+@@ -133,6 +143,7 @@ static struct attribute *omnia_mcu_base_attrs[] = {
+ 	&dev_attr_serial_number.attr,
+ 	&dev_attr_first_mac_address.attr,
+ 	&dev_attr_board_revision.attr,
++	&dev_attr_public_key.attr,
+ 	NULL
+ };
+ 
+@@ -148,6 +159,9 @@ static umode_t omnia_mcu_base_attrs_visible(struct kobject *kobj,
+ 	     a == &dev_attr_board_revision.attr) &&
+ 	    !(mcu->features & FEAT_BOARD_INFO))
+ 		mode = 0;
++	else if (a == &dev_attr_public_key.attr &&
++		 !(mcu->features & FEAT_CRYPTO))
++		mode = 0;
+ 
+ 	return mode;
+ }
+@@ -286,6 +300,24 @@ static int omnia_mcu_read_board_info(struct omnia_mcu *mcu)
+ 	return 0;
+ }
+ 
++static int omnia_mcu_read_public_key(struct omnia_mcu *mcu)
++{
++	u8 reply[1 + OMNIA_MCU_CRYPTO_PUBLIC_KEY_LEN];
++	int err;
++
++	err = omnia_cmd_read(mcu->client, CMD_CRYPTO_GET_PUBLIC_KEY, reply,
++			     sizeof(reply));
++	if (err)
++		return err;
++
++	if (reply[0] != OMNIA_MCU_CRYPTO_PUBLIC_KEY_LEN)
++		return -EIO;
++
++	memcpy(mcu->board_public_key, &reply[1], sizeof(mcu->board_public_key));
++
++	return 0;
++}
++
+ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id *)
+ {
+ 	struct device *dev = &client->dev;
+@@ -314,6 +346,13 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 					     "Cannot read board info\n");
+ 	}
+ 
++	if (mcu->features & FEAT_CRYPTO) {
++		err = omnia_mcu_read_public_key(mcu);
++		if (err)
++			return dev_err_probe(dev, err,
++					     "Cannot read board public key\n");
++	}
++
+ 	err = omnia_mcu_register_sys_off_and_wakeup(mcu);
+ 	if (err)
+ 		return err;
+@@ -326,7 +365,11 @@ static int omnia_mcu_probe(struct i2c_client *client, const struct i2c_device_id
+ 	if (err)
+ 		return err;
+ 
+-	return omnia_mcu_register_trng(mcu);
++	err = omnia_mcu_register_trng(mcu);
++	if (err)
++		return err;
++
++	return omnia_mcu_register_debugfs(mcu);
+ }
+ 
+ static const struct of_device_id of_omnia_mcu_match[] = {
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-debugfs.c b/drivers/platform/cznic/turris-omnia-mcu-debugfs.c
+new file mode 100644
+index 000000000000..47d1b4a67a25
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-debugfs.c
+@@ -0,0 +1,259 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU ECDSA message signing via debugfs
++ *
++ * 2024 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/completion.h>
++#include <linux/debugfs.h>
++#include <linux/devm-helpers.h>
++#include <linux/irqdomain.h>
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/string.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/uaccess.h>
++
++#include "turris-omnia-mcu.h"
++
++#define CMD_CRYPTO_SIGN_MESSAGE_LEN	32
++
++enum {
++	SIGN_STATE_CLOSED	= 0,
++	SIGN_STATE_OPEN		= 1,
++	SIGN_STATE_REQUESTED	= 2,
++	SIGN_STATE_COLLECTED	= 3,
++};
++
++static irqreturn_t omnia_msg_signed_irq_handler(int irq, void *dev_id)
++{
++	u8 reply[1 + OMNIA_MCU_CRYPTO_SIGNATURE_LEN];
++	struct omnia_mcu *mcu = dev_id;
++	int err;
++
++	err = omnia_cmd_read(mcu->client, CMD_CRYPTO_COLLECT_SIGNATURE, reply,
++			     sizeof(reply));
++	if (!err && reply[0] != OMNIA_MCU_CRYPTO_SIGNATURE_LEN)
++		err = -EIO;
++
++	mutex_lock(&mcu->sign_lock);
++
++	if (mcu->sign_state == SIGN_STATE_REQUESTED) {
++		mcu->sign_err = err;
++		if (!err)
++			memcpy(mcu->signature, &reply[1],
++			       OMNIA_MCU_CRYPTO_SIGNATURE_LEN);
++		mcu->sign_state = SIGN_STATE_COLLECTED;
++		complete(&mcu->msg_signed_completion);
++	}
++
++	mutex_unlock(&mcu->sign_lock);
++
++	return IRQ_HANDLED;
++}
++
++static int do_sign_open(struct inode *inode, struct file *file)
++{
++	struct omnia_mcu *mcu = inode->i_private;
++
++	mutex_lock(&mcu->sign_lock);
++
++	/* do_sign is allowed to be opened only once */
++	if (mcu->sign_state != SIGN_STATE_CLOSED) {
++		mutex_unlock(&mcu->sign_lock);
++		return -EBUSY;
++	}
++
++	mcu->sign_state = SIGN_STATE_OPEN;
++
++	file->private_data = mcu;
++
++	mutex_unlock(&mcu->sign_lock);
++
++	return nonseekable_open(inode, file);
++}
++
++static int do_sign_release(struct inode *inode, struct file *file)
++{
++	struct omnia_mcu *mcu = file->private_data;
++
++	mutex_lock(&mcu->sign_lock);
++
++	mcu->sign_state = SIGN_STATE_CLOSED;
++
++	/* forget signature on release even if it was not read, for security */
++	memzero_explicit(mcu->signature, sizeof(mcu->signature));
++
++	mutex_unlock(&mcu->sign_lock);
++
++	return 0;
++}
++
++static ssize_t do_sign_read(struct file *file, char __user *buf, size_t len,
++			    loff_t *ppos)
++{
++	struct omnia_mcu *mcu = file->private_data;
++
++	/* only allow read of one whole signature */
++	if (len != sizeof(mcu->signature))
++		return -EINVAL;
++
++	mutex_lock(&mcu->sign_lock);
++	if (mcu->sign_state != SIGN_STATE_REQUESTED &&
++	    mcu->sign_state != SIGN_STATE_COLLECTED) {
++		mutex_unlock(&mcu->sign_lock);
++		return -ENODATA;
++	}
++	mutex_unlock(&mcu->sign_lock);
++
++	if (wait_for_completion_interruptible(&mcu->msg_signed_completion))
++		return -EINTR;
++
++	mutex_lock(&mcu->sign_lock);
++
++	mcu->sign_state = SIGN_STATE_OPEN;
++
++	if (mcu->sign_err) {
++		mutex_unlock(&mcu->sign_lock);
++		return mcu->sign_err;
++	}
++
++	if (copy_to_user(buf, mcu->signature, len)) {
++		mutex_unlock(&mcu->sign_lock);
++		return -EFAULT;
++	}
++
++	/* on read forget the signature, for security */
++	memzero_explicit(mcu->signature, sizeof(mcu->signature));
++
++	mutex_unlock(&mcu->sign_lock);
++
++	return len;
++}
++
++static ssize_t do_sign_write(struct file *file, const char __user *buf,
++			     size_t len, loff_t *ppos)
++{
++	u8 cmd[1 + CMD_CRYPTO_SIGN_MESSAGE_LEN], reply;
++	struct omnia_mcu *mcu = file->private_data;
++	int err;
++
++	/*
++	 * the input is a SHA-256 hash of a message to sign, so exactly
++	 * 32 bytes have to be read
++	 */
++	if (len != CMD_CRYPTO_SIGN_MESSAGE_LEN)
++		return -EINVAL;
++
++	cmd[0] = CMD_CRYPTO_SIGN_MESSAGE;
++
++	if (copy_from_user(&cmd[1], buf, len))
++		return -EFAULT;
++
++	mutex_lock(&mcu->sign_lock);
++
++	if (mcu->sign_state != SIGN_STATE_OPEN) {
++		mutex_unlock(&mcu->sign_lock);
++		return -EBUSY;
++	}
++
++	err = omnia_cmd_write_read(mcu->client, cmd, sizeof(cmd), &reply, 1);
++	if (err) {
++		mutex_unlock(&mcu->sign_lock);
++		return err;
++	}
++
++	if (reply)
++		mcu->sign_state = SIGN_STATE_REQUESTED;
++
++	mutex_unlock(&mcu->sign_lock);
++
++	return reply ? len : -EBUSY;
++}
++
++static const struct file_operations do_sign_fops = {
++	.owner		= THIS_MODULE,
++	.open		= do_sign_open,
++	.read		= do_sign_read,
++	.write		= do_sign_write,
++	.release	= do_sign_release,
++	.llseek		= no_llseek,
++};
++
++static void omnia_mcu_irq_destroy_mapping(void *res)
++{
++	irq_dispose_mapping((unsigned int)(unsigned long)res);
++}
++
++static void omnia_mcu_mutex_destroy(void *lock)
++{
++	mutex_destroy(lock);
++}
++
++static void omnia_mcu_debugfs_dir_recursive_drop(void *res)
++{
++	debugfs_remove_recursive(res);
++}
++
++int omnia_mcu_register_debugfs(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	struct dentry *root, *entry;
++	unsigned int irq;
++	u8 irq_idx;
++	int err;
++
++	if (!(mcu->features & FEAT_CRYPTO))
++		return 0;
++
++	irq_idx = omnia_int_to_gpio_idx[__bf_shf(INT_MESSAGE_SIGNED)];
++	irq = irq_create_mapping(mcu->gc.irq.domain, irq_idx);
++	if (!irq)
++		return dev_err_probe(dev, -ENXIO,
++				     "Cannot map MESSAGE_SIGNED IRQ\n");
++
++	err = devm_add_action_or_reset(dev, omnia_mcu_irq_destroy_mapping,
++				       (void *)irq);
++	if (err)
++		return err;
++
++	mutex_init(&mcu->sign_lock);
++	err = devm_add_action_or_reset(dev, omnia_mcu_mutex_destroy,
++				       &mcu->sign_lock);
++	if (err)
++		return err;
++
++	mcu->sign_state = 0;
++
++	init_completion(&mcu->msg_signed_completion);
++
++	err = devm_request_threaded_irq(dev, irq, NULL,
++					omnia_msg_signed_irq_handler,
++					IRQF_ONESHOT,
++					"turris-omnia-mcu-debugfs", mcu);
++	if (err)
++		return dev_err_probe(dev, err,
++				     "Cannot request MESSAGE_SIGNED IRQ\n");
++
++	root = debugfs_create_dir("turris-omnia-mcu", NULL);
++	if (IS_ERR(root))
++		return dev_err_probe(dev, PTR_ERR(root),
++				     "Cannot create debugfs dir\n");
++
++	err = devm_add_action_or_reset(dev,
++				       omnia_mcu_debugfs_dir_recursive_drop,
++				       root);
++	if (err)
++		return err;
++
++	entry = debugfs_create_file_unsafe("do_sign", 0600, root, mcu,
++					   &do_sign_fops);
++	if (IS_ERR(entry))
++		return dev_err_probe(dev, PTR_ERR(entry),
++				     "Cannot create debugfs entry\n");
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index d83c2bdf63b8..a3c5f6ed8f21 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -22,6 +22,9 @@
+ #include <asm/byteorder.h>
+ #include <asm/unaligned.h>
+ 
++#define OMNIA_MCU_CRYPTO_PUBLIC_KEY_LEN	33
++#define OMNIA_MCU_CRYPTO_SIGNATURE_LEN	64
++
+ struct omnia_mcu {
+ 	struct i2c_client *client;
+ 	const char *type;
+@@ -31,6 +34,7 @@ struct omnia_mcu {
+ 	u64 board_serial_number;
+ 	u8 board_first_mac[ETH_ALEN];
+ 	u8 board_revision;
++	u8 board_public_key[OMNIA_MCU_CRYPTO_PUBLIC_KEY_LEN];
+ 
+ 	/* GPIO chip */
+ 	struct gpio_chip gc;
+@@ -55,6 +59,16 @@ struct omnia_mcu {
+ 	/* true random number generator */
+ 	struct hwrng trng;
+ 	struct completion trng_completion;
++
++#ifdef CONFIG_DEBUG_FS
++	/* MCU ECDSA message signing via debugfs */
++	struct dentry *debugfs_root;
++	struct completion msg_signed_completion;
++	struct mutex sign_lock;
++	unsigned int sign_state;
++	u8 signature[OMNIA_MCU_CRYPTO_SIGNATURE_LEN];
++	int sign_err;
++#endif
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -97,19 +111,20 @@ static inline int omnia_cmd_write_u32(const struct i2c_client *client, u8 cmd,
+ 	return omnia_cmd_write(client, buf, sizeof(buf));
+ }
+ 
+-static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
+-				 void *reply, unsigned int len)
++static inline int omnia_cmd_write_read(const struct i2c_client *client,
++				       void *cmd, unsigned int cmd_len,
++				       void *reply, unsigned int reply_len)
+ {
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+ 
+ 	msgs[0].addr = client->addr;
+ 	msgs[0].flags = 0;
+-	msgs[0].len = 1;
+-	msgs[0].buf = &cmd;
++	msgs[0].len = cmd_len;
++	msgs[0].buf = cmd;
+ 	msgs[1].addr = client->addr;
+ 	msgs[1].flags = I2C_M_RD;
+-	msgs[1].len = len;
++	msgs[1].len = reply_len;
+ 	msgs[1].buf = reply;
+ 
+ 	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+@@ -121,6 +136,12 @@ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
+ 	return 0;
+ }
+ 
++static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd,
++				 void *reply, unsigned int len)
++{
++	return omnia_cmd_write_read(client, &cmd, 1, reply, len);
++}
++
+ /* Returns 0 on success */
+ static inline int omnia_cmd_read_bits(const struct i2c_client *client, u8 cmd,
+ 				      u32 bits, u32 *dst)
+@@ -184,4 +205,13 @@ int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
+ int omnia_mcu_register_trng(struct omnia_mcu *mcu);
+ int omnia_mcu_register_watchdog(struct omnia_mcu *mcu);
+ 
++#ifdef CONFIG_DEBUG_FS
++int omnia_mcu_register_debugfs(struct omnia_mcu *mcu);
++#else
++static inline int omnia_mcu_register_debugfs(struct omnia_mcu *mcu)
++{
++	return 0;
++}
++#endif
++
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.43.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-7-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch b/target/linux/mvebu/patches-5.15/103-7-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
new file mode 100644
index 0000000000..765359dbbc
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-7-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
@@ -0,0 +1,60 @@
+From 6021be3e190392bf25de436b553fbb2c956266c2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 8 Aug 2023 14:27:21 +0200
+Subject: [PATCH 7/8] ARM: dts: turris-omnia: Add MCU system-controller node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Turris Omnia's MCU provides various features that can be configured over
+I2C at address 0x2a. Add device-tree node.
+
+Fixes: 26ca8b52d6e1 ("ARM: dts: add support for Turris Omnia")
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dts | 22 ++++++++++++++++++-
+ 1 file changed, 21 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+index 764cda6c324f..657c86a6069e 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+@@ -187,7 +187,22 @@ i2c@0 {
+ 			#size-cells = <0>;
+ 			reg = <0>;
+ 
+-			/* STM32F0 command interface at address 0x2a */
++			mcu: system-controller@2a {
++				compatible = "cznic,turris-omnia-mcu";
++				reg = <0x2a>;
++
++				pinctrl-names = "default";
++				pinctrl-0 = <&mcu_pins>;
++
++				interrupt-parent = <&gpio1>;
++				interrupts = <11 IRQ_TYPE_NONE>;
++
++				gpio-controller;
++				#gpio-cells = <2>;
++
++				interrupt-controller;
++				#interrupt-cells = <2>;
++			};
+ 
+ 			led-controller@2b {
+ 				compatible = "cznic,turris-omnia-leds";
+@@ -469,6 +484,11 @@ fixed-link {
+ };
+ 
+ &pinctrl {
++	mcu_pins: mcu-pins {
++		marvell,pins = "mpp43";
++		marvell,function = "gpio";
++	};
++
+ 	pcawan_pins: pcawan-pins {
+ 		marvell,pins = "mpp46";
+ 		marvell,function = "gpio";
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-8-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch b/target/linux/mvebu/patches-5.15/103-8-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch
new file mode 100644
index 0000000000..7ff5ad9374
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-8-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch
@@ -0,0 +1,45 @@
+From fb05d6e709894abf1f9c1ad0ce38635d56847e59 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 23 Aug 2023 16:33:42 +0200
+Subject: [PATCH 8/8] ARM: dts: turris-omnia: Add GPIO key node for front
+ button
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now that we have the MCU device-tree node, which acts as a GPIO
+controller, add GPIO key node for the front button.
+
+Fixes: 26ca8b52d6e1 ("ARM: dts: add support for Turris Omnia")
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dts | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+index 657c86a6069e..60b6923d79ec 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+@@ -108,6 +108,19 @@ sfp: sfp {
+ 		 */
+ 		status = "disabled";
+ 	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		front-button {
++			label = "Front Button";
++			linux,code = <KEY_VENDOR>;
++			linux,can-disable;
++			gpios = <&mcu 12 GPIO_ACTIVE_HIGH>;
++			/* debouncing is done by the microcontroller */
++			debounce-interval = <0>;
++		};
++	};
+ };
+ 
+ &bm {
+-- 
+2.41.0
+
-- 
2.43.0

