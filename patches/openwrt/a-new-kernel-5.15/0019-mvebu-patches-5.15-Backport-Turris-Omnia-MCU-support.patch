From c001db548b9d9d7e7637882f87b77f438b3ef469 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Tue, 17 Oct 2023 11:17:38 +0200
Subject: [PATCH 2/3] mvebu: patches-5.15: Backport Turris Omnia MCU support

---
 ...-add-cznic-turris-omnia-ctrl-binding.patch |  107 ++
 ...dd-preliminary-support-for-Turris-Om.patch |  706 ++++++++++
 ...urris-omnia-mcu-Add-support-for-MCU-.patch | 1234 +++++++++++++++++
 ...urris-omnia-mcu-Add-support-for-powe.patch |  447 ++++++
 ...urris-omnia-mcu-Add-support-for-MCU-.patch |  261 ++++
 ...omnia-Add-MCU-system-controller-node.patch |   60 +
 ...mnia-Add-GPIO-key-node-for-front-but.patch |   45 +
 7 files changed, 2860 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-1-dt-bindings-arm-add-cznic-turris-omnia-ctrl-binding.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-2-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-3-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-4-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-6-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
 create mode 100644 target/linux/mvebu/patches-5.15/103-v6.7-7-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch

diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-1-dt-bindings-arm-add-cznic-turris-omnia-ctrl-binding.patch b/target/linux/mvebu/patches-5.15/103-v6.7-1-dt-bindings-arm-add-cznic-turris-omnia-ctrl-binding.patch
new file mode 100644
index 0000000000..4567967830
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-1-dt-bindings-arm-add-cznic-turris-omnia-ctrl-binding.patch
@@ -0,0 +1,107 @@
+From 4871568e4a89cd90155b0fbea7878983798619b5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 22 Aug 2023 13:26:38 +0200
+Subject: [PATCH 09/17] dt-bindings: arm: add cznic,turris-omnia-ctrl binding
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add binding for cznic,turris-omnia-ctrl, the device-tree node
+representing the system-controller features provided by the MCU on the
+Turris Omnia router.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ ...bindings/arm/cznic,turris-omnia-ctrl.yaml  | 67 +++++++++++++++++++
+ MAINTAINERS                                   |  1 +
+ 2 files changed, 68 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml
+
+diff --git a/Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml b/Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml
+new file mode 100644
+index 000000000000..ea1fd0117bb8
+--- /dev/null
++++ b/Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml
+@@ -0,0 +1,67 @@
++# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/arm/cznic,turris-omnia-ctrl.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: CZ.NIC's Turris Omnia MCU
++
++maintainers:
++  - Marek Behún <kabel@kernel.org>
++
++description:
++  The MCU on Turris Omnia acts as a system controller providing additional
++  GPIOs, interrupts, watchdog, system power off and wakeup configuration.
++
++properties:
++  compatible:
++    const: cznic,turris-omnia-ctrl
++
++  reg:
++    description: MCU I2C slave address
++    maxItems: 1
++
++  interrupts:
++    maxItems: 1
++
++  interrupt-controller: true
++
++  '#interrupt-cells':
++    const: 2
++
++  gpio-controller: true
++
++  '#gpio-cells':
++    const: 2
++
++required:
++  - compatible
++  - reg
++  - interrupts
++  - interrupt-controller
++  - gpio-controller
++
++additionalProperties: false
++
++examples:
++  - |
++    #include <dt-bindings/interrupt-controller/irq.h>
++
++    i2c {
++        #address-cells = <1>;
++        #size-cells = <0>;
++
++        system-controller@2a {
++            compatible = "cznic,turris-omnia-ctrl";
++            reg = <0x2a>;
++
++            interrupt-parent = <&gpio1>;
++            interrupts = <11 IRQ_TYPE_NONE>;
++
++            gpio-controller;
++            #gpio-cells = <2>;
++
++            interrupt-controller;
++            #interrupt-cells = <2>;
++        };
++    };
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 9216b9c85ce9..4776eaec2b23 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1896,6 +1896,7 @@ W:	https://www.turris.cz/
+ F:	Documentation/ABI/testing/debugfs-moxtet
+ F:	Documentation/ABI/testing/sysfs-bus-moxtet-devices
+ F:	Documentation/ABI/testing/sysfs-firmware-turris-mox-rwtm
++F:	Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml
+ F:	Documentation/devicetree/bindings/bus/moxtet.txt
+ F:	Documentation/devicetree/bindings/firmware/cznic,turris-mox-rwtm.txt
+ F:	Documentation/devicetree/bindings/gpio/gpio-moxtet.txt
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-2-platform-cznic-Add-preliminary-support-for-Turris-Om.patch b/target/linux/mvebu/patches-5.15/103-v6.7-2-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
new file mode 100644
index 0000000000..cbd97c17ed
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-2-platform-cznic-Add-preliminary-support-for-Turris-Om.patch
@@ -0,0 +1,706 @@
+From d5d372ebcb7855880aefcd4a4f427df30c9439e3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 3 Aug 2023 13:32:59 +0200
+Subject: [PATCH 10/17] platform: cznic: Add preliminary support for Turris
+ Omnia MCU
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add the basic skeleton for a new platform driver for the microcontroller
+found on the Turris Omnia board.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  45 ++++
+ MAINTAINERS                                   |   3 +
+ drivers/platform/Kconfig                      |   2 +
+ drivers/platform/Makefile                     |   1 +
+ drivers/platform/cznic/Kconfig                |  26 ++
+ drivers/platform/cznic/Makefile               |   4 +
+ .../platform/cznic/turris-omnia-mcu-base.c    | 254 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  65 +++++
+ include/linux/turris-omnia-mcu-interface.h    | 194 +++++++++++++
+ 9 files changed, 594 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+ create mode 100644 drivers/platform/cznic/Kconfig
+ create mode 100644 drivers/platform/cznic/Makefile
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-base.c
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu.h
+ create mode 100644 include/linux/turris-omnia-mcu-interface.h
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+new file mode 100644
+index 000000000000..72cdf0cfce3e
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -0,0 +1,45 @@
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Newer versions of the microcontroller firmware report the
++		features they support. These can be read from this file. If the
++		MCU firmware is too old, this file reads 0x0.
++
++		Format: 0x%x.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_version_hash_application
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the version hash (commit hash) of the application
++		part of the microcontroller firmware.
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/fw_version_hash_bootloader
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the version hash (commit hash) of the bootloader
++		part of the microcontroller firmware.
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/mcu_type
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the microcontroller type (STM32, GD32, MKL).
++
++		Format: %s.
++
++What:		/sys/bus/i2c/devices/<mcu_device>/reset_selector
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RO) Contains the selected factory reset level, determined by
++		how long the rear reset button was held by the user during board
++		reset.
++
++		Format: %i.
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 4776eaec2b23..eab0181c9b10 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1894,6 +1894,7 @@ M:	Marek Behún <kabel@kernel.org>
+ S:	Maintained
+ W:	https://www.turris.cz/
+ F:	Documentation/ABI/testing/debugfs-moxtet
++F:	Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+ F:	Documentation/ABI/testing/sysfs-bus-moxtet-devices
+ F:	Documentation/ABI/testing/sysfs-firmware-turris-mox-rwtm
+ F:	Documentation/devicetree/bindings/arm/cznic,turris-omnia-ctrl.yaml
+@@ -1907,10 +1908,12 @@ F:	drivers/firmware/turris-mox-rwtm.c
+ F:	drivers/leds/leds-turris-omnia.c
+ F:	drivers/mailbox/armada-37xx-rwtm-mailbox.c
+ F:	drivers/gpio/gpio-moxtet.c
++F:	drivers/platform/cznic/
+ F:	drivers/watchdog/armada_37xx_wdt.c
+ F:	include/dt-bindings/bus/moxtet.h
+ F:	include/linux/armada-37xx-rwtm-mailbox.h
+ F:	include/linux/moxtet.h
++F:	include/linux/turris-omnia-mcu-interface.h
+ 
+ ARM/EZX SMARTPHONES (A780, A910, A1200, E680, ROKR E2 and ROKR E6)
+ M:	Robert Jarzmik <robert.jarzmik@free.fr>
+diff --git a/drivers/platform/Kconfig b/drivers/platform/Kconfig
+index 18fc6a08569e..9babfc946bfb 100644
+--- a/drivers/platform/Kconfig
++++ b/drivers/platform/Kconfig
+@@ -10,6 +10,8 @@ source "drivers/platform/goldfish/Kconfig"
+ 
+ source "drivers/platform/chrome/Kconfig"
+ 
++source "drivers/platform/cznic/Kconfig"
++
+ source "drivers/platform/mellanox/Kconfig"
+ 
+ source "drivers/platform/olpc/Kconfig"
+diff --git a/drivers/platform/Makefile b/drivers/platform/Makefile
+index 4de08ef4ec9d..ee37fb78ad46 100644
+--- a/drivers/platform/Makefile
++++ b/drivers/platform/Makefile
+@@ -9,4 +9,5 @@ obj-$(CONFIG_MIPS)		+= mips/
+ obj-$(CONFIG_OLPC_EC)		+= olpc/
+ obj-$(CONFIG_GOLDFISH)		+= goldfish/
+ obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
++obj-$(CONFIG_CZNIC_PLATFORMS)	+= cznic/
+ obj-$(CONFIG_SURFACE_PLATFORMS)	+= surface/
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+new file mode 100644
+index 000000000000..f8560ff9c1af
+--- /dev/null
++++ b/drivers/platform/cznic/Kconfig
+@@ -0,0 +1,26 @@
++# SPDX-License-Identifier: GPL-2.0-only
++#
++# For a description of the syntax of this configuration file,
++# see Documentation/kbuild/kconfig-language.rst.
++#
++
++menuconfig CZNIC_PLATFORMS
++	bool "Platform support for CZ.NIC's Turris hardware"
++	depends on MACH_ARMADA_38X || COMPILE_TEST
++	help
++	  Say Y here to be able to choose driver support for CZ.NIC's Turris
++	  devices. This option alone does not add any kernel code.
++
++if CZNIC_PLATFORMS
++
++config TURRIS_OMNIA_MCU
++	tristate "Turris Omnia MCU driver"
++	depends on MACH_ARMADA_38X || COMPILE_TEST
++	depends on I2C
++	help
++	  Say Y here to add support for the features implemented by the
++	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
++	  To compile this driver as a module, choose M here; the module will be
++	  called turris-omnia-mcu.
++
++endif # CZNIC_PLATFORMS
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+new file mode 100644
+index 000000000000..4d0a9586538c
+--- /dev/null
++++ b/drivers/platform/cznic/Makefile
+@@ -0,0 +1,4 @@
++# SPDX-License-Identifier: GPL-2.0-only
++
++obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
++turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+new file mode 100644
+index 000000000000..5495e0a029d7
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -0,0 +1,254 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/device.h>
++#include <linux/i2c.h>
++#include <linux/module.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/sysfs.h>
++
++#include "turris-omnia-mcu.h"
++
++#define OMNIA_FW_VERSION_LEN		20
++#define OMNIA_FW_VERSION_HEX_LEN	(2 * OMNIA_FW_VERSION_LEN + 1)
++
++static int omnia_get_version_hash(struct omnia_mcu *mcu, bool bootloader,
++				  u8 version[static OMNIA_FW_VERSION_HEX_LEN])
++{
++	u8 reply[OMNIA_FW_VERSION_LEN];
++	int err;
++
++	err = omnia_cmd_read(mcu->client, bootloader ? CMD_GET_FW_VERSION_BOOT :
++						       CMD_GET_FW_VERSION_APP,
++			     reply, sizeof(reply));
++	if (err)
++		return err;
++
++	version[OMNIA_FW_VERSION_HEX_LEN - 1] = '\0';
++	bin2hex(version, reply, OMNIA_FW_VERSION_LEN);
++
++	return 0;
++}
++
++static ssize_t fw_version_hash_show(struct device *dev, char *buf,
++				    bool bootloader)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	u8 version[OMNIA_FW_VERSION_HEX_LEN];
++	int err;
++
++	err = omnia_get_version_hash(mcu, bootloader, version);
++	if (err)
++		return err;
++
++	return sysfs_emit(buf, "%s\n", version);
++}
++
++static ssize_t fw_version_hash_application_show(struct device *dev,
++						struct device_attribute *a,
++						char *buf)
++{
++	return fw_version_hash_show(dev, buf, false);
++}
++static DEVICE_ATTR_RO(fw_version_hash_application);
++
++static ssize_t fw_version_hash_bootloader_show(struct device *dev,
++					       struct device_attribute *a,
++					       char *buf)
++{
++	return fw_version_hash_show(dev, buf, true);
++}
++static DEVICE_ATTR_RO(fw_version_hash_bootloader);
++
++static ssize_t fw_features_show(struct device *dev, struct device_attribute *a,
++				char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "0x%x\n", mcu->features);
++}
++static DEVICE_ATTR_RO(fw_features);
++
++static ssize_t mcu_type_show(struct device *dev, struct device_attribute *a,
++			     char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%s\n", mcu->type);
++}
++static DEVICE_ATTR_RO(mcu_type);
++
++static ssize_t reset_selector_show(struct device *dev,
++				   struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = omnia_cmd_read_u8(to_i2c_client(dev), CMD_GET_RESET);
++	if (ret < 0)
++		return ret;
++
++	return sysfs_emit(buf, "%d\n", ret);
++}
++static DEVICE_ATTR_RO(reset_selector);
++
++static struct attribute *omnia_mcu_attrs[] = {
++	&dev_attr_fw_version_hash_application.attr,
++	&dev_attr_fw_version_hash_bootloader.attr,
++	&dev_attr_fw_features.attr,
++	&dev_attr_mcu_type.attr,
++	&dev_attr_reset_selector.attr,
++	NULL
++};
++ATTRIBUTE_GROUPS(omnia_mcu);
++
++static void omnia_mcu_print_version_hash(struct omnia_mcu *mcu, bool bootloader)
++{
++	const char *type = bootloader ? "bootloader" : "application";
++	struct device *dev = &mcu->client->dev;
++	u8 version[OMNIA_FW_VERSION_HEX_LEN];
++	int err;
++
++	err = omnia_get_version_hash(mcu, bootloader, version);
++	if (err) {
++		dev_err(dev, "Cannot read MCU %s firmware version: %d\n", type,
++			err);
++		return;
++	}
++
++	dev_info(dev, "MCU %s firmware version hash: %s\n", type, version);
++}
++
++static const char *omnia_status_to_mcu_type(uint16_t status)
++{
++	switch (status & STS_MCU_TYPE_MASK) {
++	case STS_MCU_TYPE_STM32:
++		return "STM32";
++	case STS_MCU_TYPE_GD32:
++		return "GD32";
++	case STS_MCU_TYPE_MKL:
++		return "MKL";
++	default:
++		return "unknown";
++	}
++}
++
++static void omnia_info_missing_feature(struct device *dev, const char *feature)
++{
++	dev_info(dev,
++		 "Your board's MCU firmware does not support the %s feature.\n",
++		 feature);
++}
++
++static int omnia_mcu_read_features(struct omnia_mcu *mcu)
++{
++	static const struct {
++		uint16_t mask;
++		const char *name;
++	} features[] = {
++		{ FEAT_EXT_CMDS,		"extended control and status" },
++		{ FEAT_WDT_PING,		"watchdog pinging" },
++		{ FEAT_LED_STATE_EXT_MASK,	"peripheral LED pins reading" },
++		{ FEAT_NEW_INT_API,		"new interrupt API" },
++		{ FEAT_POWEROFF_WAKEUP,		"poweroff and wakeup" },
++	};
++	struct device *dev = &mcu->client->dev;
++	bool suggest_fw_upgrade = false;
++	unsigned i;
++	int status;
++
++	/* status word holds MCU type, which we need below */
++	status = omnia_cmd_read_u16(mcu->client, CMD_GET_STATUS_WORD);
++	if (status < 0)
++		return status;
++
++	/* check whether MCU firmware supports the CMD_GET_FEAUTRES command */
++	if (status & STS_FEATURES_SUPPORTED) {
++		int features;
++
++		features = omnia_cmd_read_u16(mcu->client, CMD_GET_FEATURES);
++		if (features < 0)
++			return features;
++
++		mcu->features = features;
++	} else {
++		omnia_info_missing_feature(dev, "feature reading");
++		suggest_fw_upgrade = true;
++	}
++
++	mcu->type = omnia_status_to_mcu_type(status);
++	dev_info(dev, "MCU type %s%s\n", mcu->type,
++		 (mcu->features & FEAT_PERIPH_MCU) ?
++			", with peripheral resets wired" : "");
++
++	omnia_mcu_print_version_hash(mcu, true);
++
++	if (mcu->features & FEAT_BOOTLOADER)
++		dev_warn(dev,
++			 "MCU is running bootloader firmware. Was firmware upgrade interrupted?\n");
++	else
++		omnia_mcu_print_version_hash(mcu, false);
++
++	for (i = 0; i < ARRAY_SIZE(features); i++) {
++		if (mcu->features & features[i].mask)
++			continue;
++
++		omnia_info_missing_feature(dev, features[i].name);
++		suggest_fw_upgrade = true;
++	}
++
++	if (suggest_fw_upgrade)
++		dev_info(dev,
++			 "Consider upgrading MCU firmware with the omnia-mcutool utility.\n");
++
++	return 0;
++}
++
++static int omnia_mcu_probe(struct i2c_client *client,
++			   const struct i2c_device_id *id)
++{
++	struct device *dev = &client->dev;
++	struct omnia_mcu *mcu;
++	int err;
++
++	if (!client->irq)
++		return dev_err_probe(dev, -EINVAL, "IRQ resource not found\n");
++
++	mcu = devm_kzalloc(dev, sizeof(*mcu), GFP_KERNEL);
++	if (!mcu)
++		return -ENOMEM;
++
++	mcu->client = client;
++	i2c_set_clientdata(client, mcu);
++
++	err = omnia_mcu_read_features(mcu);
++	if (err)
++		return dev_err_probe(dev, err,
++				     "Cannot determine MCU supported features\n");
++
++	return 0;
++}
++
++static const struct of_device_id of_omnia_mcu_match[] = {
++	{ .compatible = "cznic,turris-omnia-ctrl" },
++	{}
++};
++
++static struct i2c_driver omnia_mcu_driver = {
++	.probe		= omnia_mcu_probe,
++	.driver		= {
++		.name	= "turris-omnia-mcu",
++		.of_match_table = of_omnia_mcu_match,
++		.dev_groups = omnia_mcu_groups,
++	},
++};
++
++module_i2c_driver(omnia_mcu_driver);
++
++MODULE_AUTHOR("Marek Behun <kabel@kernel.org>");
++MODULE_DESCRIPTION("CZ.NIC's Turris Omnia MCU");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+new file mode 100644
+index 000000000000..ee7c7cf34243
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -0,0 +1,65 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * CZ.NIC's Turris Omnia MCU driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#ifndef __TURRIS_OMNIA_MCU_H
++#define __TURRIS_OMNIA_MCU_H
++
++#include <linux/i2c.h>
++#include <linux/types.h>
++#include <asm/byteorder.h>
++
++struct omnia_mcu {
++	struct i2c_client *client;
++	const char *type;
++	u16 features;
++};
++
++static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd, void *reply,
++				 unsigned int len)
++{
++	struct i2c_msg msgs[2];
++	int ret;
++
++	msgs[0].addr = client->addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &cmd;
++	msgs[1].addr = client->addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = len;
++	msgs[1].buf = reply;
++
++	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
++	if (ret < 0)
++		return ret;
++	if (ret != ARRAY_SIZE(msgs))
++		return -EIO;
++
++	return 0;
++}
++
++static inline int omnia_cmd_read_u16(const struct i2c_client *client, u8 cmd)
++{
++	u16 reply;
++	int err;
++
++	err = omnia_cmd_read(client, cmd, &reply, sizeof(reply));
++
++	return err ?: le16_to_cpu(reply);
++}
++
++static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
++{
++	u8 reply;
++	int err;
++
++	err = omnia_cmd_read(client, cmd, &reply, sizeof(reply));
++
++	return err ?: reply;
++}
++
++#endif /* __TURRIS_OMNIA_MCU_H */
+diff --git a/include/linux/turris-omnia-mcu-interface.h b/include/linux/turris-omnia-mcu-interface.h
+new file mode 100644
+index 000000000000..1d426f8c209e
+--- /dev/null
++++ b/include/linux/turris-omnia-mcu-interface.h
+@@ -0,0 +1,194 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * CZ.NIC's Turris Omnia MCU I2C interface commands definitions
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#ifndef __TURRIS_OMNIA_MCU_INTERFACE_H
++#define __TURRIS_OMNIA_MCU_INTERFACE_H
++
++#include <linux/bits.h>
++
++enum omnia_commands_e {
++	CMD_GET_STATUS_WORD		= 0x01, /* slave sends status word back */
++	CMD_GENERAL_CONTROL		= 0x02,
++	CMD_LED_MODE			= 0x03, /* default/user */
++	CMD_LED_STATE			= 0x04, /* LED on/off */
++	CMD_LED_COLOR			= 0x05, /* LED number + RED + GREEN + BLUE */
++	CMD_USER_VOLTAGE		= 0x06,
++	CMD_SET_BRIGHTNESS		= 0x07,
++	CMD_GET_BRIGHTNESS		= 0x08,
++	CMD_GET_RESET			= 0x09,
++	CMD_GET_FW_VERSION_APP		= 0x0A, /* 20B git hash number */
++	CMD_SET_WATCHDOG_STATE		= 0x0B, /* 0 - disable
++						 * 1 - enable / ping
++						 * after boot watchdog is started
++						 * with 2 minutes timeout
++						 */
++
++	/* CMD_WATCHDOG_STATUS		= 0x0C, not implemented anymore */
++
++	CMD_GET_WATCHDOG_STATE		= 0x0D,
++	CMD_GET_FW_VERSION_BOOT		= 0x0E, /* 20B git hash number */
++	CMD_GET_FW_CHECKSUM		= 0x0F, /* 4B length, 4B checksum */
++
++	/* available if FEATURES_SUPPORTED bit set in status word */
++	CMD_GET_FEATURES		= 0x10,
++
++	/* available if EXT_CMD bit set in features */
++	CMD_GET_EXT_STATUS_DWORD	= 0x11,
++	CMD_EXT_CONTROL			= 0x12,
++	CMD_GET_EXT_CONTROL_STATUS	= 0x13,
++
++	/* available if NEW_INT_API bit set in features */
++	CMD_GET_INT_AND_CLEAR		= 0x14,
++	CMD_GET_INT_MASK		= 0x15,
++	CMD_SET_INT_MASK		= 0x16,
++
++	/* available if FLASHING bit set in features */
++	CMD_FLASH			= 0x19,
++
++	/* available if WDT_PING bit set in features */
++	CMD_SET_WDT_TIMEOUT		= 0x20,
++	CMD_GET_WDT_TIMELEFT		= 0x21,
++
++	/* available if POWEROFF_WAKEUP bit set in features */
++	CMD_SET_WAKEUP			= 0x22,
++	CMD_GET_UPTIME_AND_WAKEUP	= 0x23,
++	CMD_POWER_OFF			= 0x24,
++
++	/* available only at address 0x2b (led-controller) */
++	/* available only if LED_GAMMA_CORRECTION bit set in features */
++	CMD_SET_GAMMA_CORRECTION	= 0x30,
++	CMD_GET_GAMMA_CORRECTION	= 0x31,
++};
++
++enum omnia_flashing_commands_e {
++	FLASH_CMD_UNLOCK		= 0x01,
++	FLASH_CMD_SIZE_AND_CSUM		= 0x02,
++	FLASH_CMD_PROGRAM		= 0x03,
++	FLASH_CMD_RESET			= 0x04,
++};
++
++enum omnia_sts_word_e {
++	STS_MCU_TYPE_MASK			= GENMASK(1, 0),
++	STS_MCU_TYPE_STM32			= 0 << 0,
++	STS_MCU_TYPE_GD32			= 1 << 0,
++	STS_MCU_TYPE_MKL			= 2 << 0,
++	STS_FEATURES_SUPPORTED			= BIT(2),
++	STS_USER_REGULATOR_NOT_SUPPORTED	= BIT(3),
++	STS_CARD_DET				= BIT(4),
++	STS_MSATA_IND				= BIT(5),
++	STS_USB30_OVC				= BIT(6),
++	STS_USB31_OVC				= BIT(7),
++	STS_USB30_PWRON				= BIT(8),
++	STS_USB31_PWRON				= BIT(9),
++	STS_ENABLE_4V5				= BIT(10),
++	STS_BUTTON_MODE				= BIT(11),
++	STS_BUTTON_PRESSED			= BIT(12),
++	STS_BUTTON_COUNTER_MASK			= GENMASK(15, 13)
++};
++
++enum omnia_ctl_byte_e {
++	CTL_LIGHT_RST		= BIT(0),
++	CTL_HARD_RST		= BIT(1),
++	/* BIT(2) is currently reserved */
++	CTL_USB30_PWRON		= BIT(3),
++	CTL_USB31_PWRON		= BIT(4),
++	CTL_ENABLE_4V5		= BIT(5),
++	CTL_BUTTON_MODE		= BIT(6),
++	CTL_BOOTLOADER		= BIT(7)
++};
++
++enum omnia_features_e {
++	FEAT_PERIPH_MCU			= BIT(0),
++	FEAT_EXT_CMDS			= BIT(1),
++	FEAT_WDT_PING			= BIT(2),
++	FEAT_LED_STATE_EXT_MASK		= GENMASK(4, 3),
++	FEAT_LED_STATE_EXT		= 1 << 3,
++	FEAT_LED_STATE_EXT_V32		= 2 << 3,
++	FEAT_LED_GAMMA_CORRECTION	= BIT(5),
++	FEAT_NEW_INT_API		= BIT(6),
++	FEAT_BOOTLOADER			= BIT(7),
++	FEAT_FLASHING			= BIT(8),
++	FEAT_NEW_MESSAGE_API		= BIT(9),
++	FEAT_BRIGHTNESS_INT		= BIT(10),
++	FEAT_POWEROFF_WAKEUP		= BIT(11),
++};
++
++enum omnia_ext_sts_dword_e {
++	EXT_STS_SFP_nDET		= BIT(0),
++	EXT_STS_LED_STATES_MASK		= GENMASK(31, 12),
++	EXT_STS_WLAN0_MSATA_LED		= BIT(12),
++	EXT_STS_WLAN1_LED		= BIT(13),
++	EXT_STS_WLAN2_LED		= BIT(14),
++	EXT_STS_WPAN0_LED		= BIT(15),
++	EXT_STS_WPAN1_LED		= BIT(16),
++	EXT_STS_WPAN2_LED		= BIT(17),
++	EXT_STS_WAN_LED0		= BIT(18),
++	EXT_STS_WAN_LED1		= BIT(19),
++	EXT_STS_LAN0_LED0		= BIT(20),
++	EXT_STS_LAN0_LED1		= BIT(21),
++	EXT_STS_LAN1_LED0		= BIT(22),
++	EXT_STS_LAN1_LED1		= BIT(23),
++	EXT_STS_LAN2_LED0		= BIT(24),
++	EXT_STS_LAN2_LED1		= BIT(25),
++	EXT_STS_LAN3_LED0		= BIT(26),
++	EXT_STS_LAN3_LED1		= BIT(27),
++	EXT_STS_LAN4_LED0		= BIT(28),
++	EXT_STS_LAN4_LED1		= BIT(29),
++	EXT_STS_LAN5_LED0		= BIT(30),
++	EXT_STS_LAN5_LED1		= BIT(31),
++};
++
++enum omnia_ext_ctl_e {
++	EXT_CTL_nRES_MMC		= BIT(0),
++	EXT_CTL_nRES_LAN		= BIT(1),
++	EXT_CTL_nRES_PHY		= BIT(2),
++	EXT_CTL_nPERST0			= BIT(3),
++	EXT_CTL_nPERST1			= BIT(4),
++	EXT_CTL_nPERST2			= BIT(5),
++	EXT_CTL_PHY_SFP			= BIT(6),
++	EXT_CTL_PHY_SFP_AUTO		= BIT(7),
++	EXT_CTL_nVHV_CTRL		= BIT(8),
++};
++
++enum omnia_int_e {
++	INT_CARD_DET		= BIT(0),
++	INT_MSATA_IND		= BIT(1),
++	INT_USB30_OVC		= BIT(2),
++	INT_USB31_OVC		= BIT(3),
++	INT_BUTTON_PRESSED	= BIT(4),
++	INT_SFP_nDET		= BIT(5),
++	INT_BRIGHTNESS_CHANGED	= BIT(6),
++
++	INT_LED_STATES_MASK	= GENMASK(31, 12),
++	INT_WLAN0_MSATA_LED	= BIT(12),
++	INT_WLAN1_LED		= BIT(13),
++	INT_WLAN2_LED		= BIT(14),
++	INT_WPAN0_LED		= BIT(15),
++	INT_WPAN1_LED		= BIT(16),
++	INT_WPAN2_LED		= BIT(17),
++	INT_WAN_LED0		= BIT(18),
++	INT_WAN_LED1		= BIT(19),
++	INT_LAN0_LED0		= BIT(20),
++	INT_LAN0_LED1		= BIT(21),
++	INT_LAN1_LED0		= BIT(22),
++	INT_LAN1_LED1		= BIT(23),
++	INT_LAN2_LED0		= BIT(24),
++	INT_LAN2_LED1		= BIT(25),
++	INT_LAN3_LED0		= BIT(26),
++	INT_LAN3_LED1		= BIT(27),
++	INT_LAN4_LED0		= BIT(28),
++	INT_LAN4_LED1		= BIT(29),
++	INT_LAN5_LED0		= BIT(30),
++	INT_LAN5_LED1		= BIT(31),
++};
++
++enum omnia_cmd_poweroff_e {
++	CMD_POWER_OFF_POWERON_BUTTON	= BIT(0),
++	CMD_POWER_OFF_MAGIC		= 0xdead,
++};
++
++#endif /* __TURRIS_OMNIA_MCU_INTERFACE_H */
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-3-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch b/target/linux/mvebu/patches-5.15/103-v6.7-3-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
new file mode 100644
index 0000000000..38b263b249
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-3-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
@@ -0,0 +1,1234 @@
+From 2a1e9e8b32d6b8413443e5ebfb11f6019cc463d3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 11:58:51 +0200
+Subject: [PATCH 11/17] platform: cznic: turris-omnia-mcu: Add support for MCU
+ connected GPIOs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for GPIOs connected to the MCU on the Turris Omnia board.
+
+This includes:
+- front button pin
+- enable pins for USB regulators
+- MiniPCIe / mSATA card presence pins in MiniPCIe port 0
+- LED output pins from WAN ethernet PHY, LAN switch and MiniPCIe ports
+- on board revisions 32+ also various peripheral resets and another
+  voltage regulator enable pin
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  16 +
+ drivers/platform/cznic/Kconfig                |  15 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |  21 +-
+ .../platform/cznic/turris-omnia-mcu-gpio.c    | 989 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  63 +-
+ 6 files changed, 1103 insertions(+), 2 deletions(-)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-gpio.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+index 72cdf0cfce3e..e635ba45ef9a 100644
+--- a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -1,3 +1,19 @@
++What:		/sys/bus/i2c/devices/<mcu_device>/front_button_mode
++Date:		November 2023
++KernelVersion:	6.7
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RW) The front button on the Turris Omnia router can be
++		configured either to change the intensity of all the LEDs on the
++		front panel, or to send the press event to the CPU as an
++		interrupt.
++
++		This file switches between these two modes:
++		- "mcu" makes the button press event be handled by the MCU to
++		  change the LEDs panel intensity.
++		- "cpu" makes the button press event be handled by the CPU.
++
++		Format: %s.
++
+ What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
+ Date:		November 2023
+ KernelVersion:	6.7
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index f8560ff9c1af..3a8c3edcd7e6 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -17,9 +17,24 @@ config TURRIS_OMNIA_MCU
+ 	tristate "Turris Omnia MCU driver"
+ 	depends on MACH_ARMADA_38X || COMPILE_TEST
+ 	depends on I2C
++	select GPIOLIB
++	select GPIOLIB_IRQCHIP
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
++	  The features include:
++	  - GPIO pins
++	    - to get front button press events (the front button can be
++	      configured either to generate press events to the CPU or to change
++	      front LEDs panel brightness)
++	    - to enable / disable USB port voltage regulators and to detect
++	      USB overcurrent
++	    - to detect MiniPCIe / mSATA card presence in MiniPCIe port 0
++	    - to configure resets of various peripherals on board revisions 32+
++	    - to enable / disable the VHV voltage regulator to the SOC in order
++	      to be able to program SOC's OTP on board revisions 32+
++	    - to get input from the LED output pins of the WAN ethernet PHY, LAN
++	      switch and MiniPCIe ports
+ 	  To compile this driver as a module, choose M here; the module will be
+ 	  called turris-omnia-mcu.
+ 
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index 4d0a9586538c..a6177f5b4fff 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -2,3 +2,4 @@
+ 
+ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index 5495e0a029d7..272e0b0496d6 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -104,7 +104,16 @@ static struct attribute *omnia_mcu_attrs[] = {
+ 	&dev_attr_reset_selector.attr,
+ 	NULL
+ };
+-ATTRIBUTE_GROUPS(omnia_mcu);
++
++static const struct attribute_group omnia_mcu_base_group = {
++	.attrs = omnia_mcu_attrs,
++};
++
++static const struct attribute_group *omnia_mcu_groups[] = {
++	&omnia_mcu_base_group,
++	&omnia_mcu_gpio_group,
++	NULL
++};
+ 
+ static void omnia_mcu_print_version_hash(struct omnia_mcu *mcu, bool bootloader)
+ {
+@@ -230,6 +239,15 @@ static int omnia_mcu_probe(struct i2c_client *client,
+ 		return dev_err_probe(dev, err,
+ 				     "Cannot determine MCU supported features\n");
+ 
++	return omnia_mcu_register_gpiochip(mcu);
++}
++
++static int omnia_mcu_remove(struct i2c_client *client)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++
++	omnia_mcu_unregister_gpiochip(mcu);
++
+ 	return 0;
+ }
+ 
+@@ -240,6 +258,7 @@ static const struct of_device_id of_omnia_mcu_match[] = {
+ 
+ static struct i2c_driver omnia_mcu_driver = {
+ 	.probe		= omnia_mcu_probe,
++	.remove		= omnia_mcu_remove,
+ 	.driver		= {
+ 		.name	= "turris-omnia-mcu",
+ 		.of_match_table = of_omnia_mcu_match,
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-gpio.c b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+new file mode 100644
+index 000000000000..4d66965bdcd1
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-gpio.c
+@@ -0,0 +1,989 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU GPIO and IRQ driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/bitops.h>
++#include <linux/bug.h>
++#include <linux/gpio/driver.h>
++#include <linux/i2c.h>
++#include <linux/interrupt.h>
++#include <linux/mutex.h>
++#include <linux/sysfs.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/workqueue.h>
++#include <asm/unaligned.h>
++
++#include "turris-omnia-mcu.h"
++
++#define CMD_INT_ARG_LEN			8
++#define FRONT_BUTTON_RELEASE_DELAY	50 /* ms */
++
++static const char * const omnia_mcu_gpio_templates[64] = {
++	/* GPIOs with value read from the 16-bit wide status */
++	[4]  = "gpio%u.MiniPCIe0 Card Detect",
++	[5]  = "gpio%u.MiniPCIe0 mSATA Indicator",
++	[6]  = "gpio%u.Front USB3 port over-current",
++	[7]  = "gpio%u.Rear USB3 port over-current",
++	[8]  = "gpio%u.Front USB3 port power",
++	[9]  = "gpio%u.Rear USB3 port power",
++	[12] = "gpio%u.Front Button",
++
++	/* GPIOs with value read from the 32-bit wide extended status */
++	[16] = "gpio%u.SFP nDET",
++	[28] = "gpio%u.MiniPCIe0 LED",
++	[29] = "gpio%u.MiniPCIe1 LED",
++	[30] = "gpio%u.MiniPCIe2 LED",
++	[31] = "gpio%u.MiniPCIe0 PAN LED",
++	[32] = "gpio%u.MiniPCIe1 PAN LED",
++	[33] = "gpio%u.MiniPCIe2 PAN LED",
++	[34] = "gpio%u.WAN PHY LED0",
++	[35] = "gpio%u.WAN PHY LED1",
++	[36] = "gpio%u.LAN switch p0 LED0",
++	[37] = "gpio%u.LAN switch p0 LED1",
++	[38] = "gpio%u.LAN switch p1 LED0",
++	[39] = "gpio%u.LAN switch p1 LED1",
++	[40] = "gpio%u.LAN switch p2 LED0",
++	[41] = "gpio%u.LAN switch p2 LED1",
++	[42] = "gpio%u.LAN switch p3 LED0",
++	[43] = "gpio%u.LAN switch p3 LED1",
++	[44] = "gpio%u.LAN switch p4 LED0",
++	[45] = "gpio%u.LAN switch p4 LED1",
++	[46] = "gpio%u.LAN switch p5 LED0",
++	[47] = "gpio%u.LAN switch p5 LED1",
++
++	/* GPIOs with value read from the 16-bit wide extended control status */
++	[48] = "gpio%u.eMMC nRESET",
++	[49] = "gpio%u.LAN switch nRESET",
++	[50] = "gpio%u.WAN PHY nRESET",
++	[51] = "gpio%u.MiniPCIe0 nPERST",
++	[52] = "gpio%u.MiniPCIe1 nPERST",
++	[53] = "gpio%u.MiniPCIe2 nPERST",
++	[54] = "gpio%u.WAN PHY SFP mux",
++};
++
++#define _DEF_GPIO(_cmd, _ctl_cmd, _bit, _ctl_bit, _int_bit, _feat, _feat_mask) \
++	{								\
++		.cmd = _cmd,						\
++		.ctl_cmd = _ctl_cmd,					\
++		.bit = _bit,						\
++		.ctl_bit = _ctl_bit,					\
++		.int_bit = _int_bit,					\
++		.feat = _feat,						\
++		.feat_mask = _feat_mask,				\
++	}
++#define _DEF_GPIO_STS(_name) \
++	_DEF_GPIO(CMD_GET_STATUS_WORD, 0, STS_ ## _name, 0, INT_ ## _name, 0, 0)
++#define _DEF_GPIO_CTL(_name) \
++	_DEF_GPIO(CMD_GET_STATUS_WORD, CMD_GENERAL_CONTROL, STS_ ## _name, \
++		  CTL_ ## _name, 0, 0, 0)
++#define _DEF_GPIO_EXT_STS(_name, _feat) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_ ## _feat | FEAT_EXT_CMDS, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS)
++#define _DEF_GPIO_EXT_STS_LED(_name, _ledext) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_LED_STATE_ ## _ledext, \
++		  FEAT_LED_STATE_EXT_MASK)
++#define _DEF_GPIO_EXT_STS_LEDALL(_name) \
++	_DEF_GPIO(CMD_GET_EXT_STATUS_DWORD, 0, EXT_STS_ ## _name, 0, \
++		  INT_ ## _name, FEAT_LED_STATE_EXT_MASK, 0)
++#define _DEF_GPIO_EXT_CTL(_name, _feat) \
++	_DEF_GPIO(CMD_GET_EXT_CONTROL_STATUS, CMD_EXT_CONTROL, \
++		  EXT_CTL_ ## _name, EXT_CTL_ ## _name, 0, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS, \
++		  FEAT_ ## _feat | FEAT_EXT_CMDS)
++#define _DEF_INT(_name) \
++	_DEF_GPIO(0, 0, 0, 0, INT_ ## _name, 0, 0)
++
++static const struct omnia_gpio {
++	u8 cmd, ctl_cmd;
++	u32 bit, ctl_bit;
++	u32 int_bit;
++	u16 feat, feat_mask;
++} omnia_gpios[64] = {
++	/* GPIOs with value read from the 16-bit wide status */
++	[4]  = _DEF_GPIO_STS(CARD_DET),
++	[5]  = _DEF_GPIO_STS(MSATA_IND),
++	[6]  = _DEF_GPIO_STS(USB30_OVC),
++	[7]  = _DEF_GPIO_STS(USB31_OVC),
++	[8]  = _DEF_GPIO_CTL(USB30_PWRON),
++	[9]  = _DEF_GPIO_CTL(USB31_PWRON),
++
++	/* brightness changed interrupt, no GPIO */
++	[11] = _DEF_INT(BRIGHTNESS_CHANGED),
++
++	[12] = _DEF_GPIO_STS(BUTTON_PRESSED),
++
++	/* GPIOs with value read from the 32-bit wide extended status */
++	[16] = _DEF_GPIO_EXT_STS(SFP_nDET, PERIPH_MCU),
++	[28] = _DEF_GPIO_EXT_STS_LEDALL(WLAN0_MSATA_LED),
++	[29] = _DEF_GPIO_EXT_STS_LEDALL(WLAN1_LED),
++	[30] = _DEF_GPIO_EXT_STS_LEDALL(WLAN2_LED),
++	[31] = _DEF_GPIO_EXT_STS_LED(WPAN0_LED, EXT),
++	[32] = _DEF_GPIO_EXT_STS_LED(WPAN1_LED, EXT),
++	[33] = _DEF_GPIO_EXT_STS_LED(WPAN2_LED, EXT),
++	[34] = _DEF_GPIO_EXT_STS_LEDALL(WAN_LED0),
++	[35] = _DEF_GPIO_EXT_STS_LED(WAN_LED1, EXT_V32),
++	[36] = _DEF_GPIO_EXT_STS_LEDALL(LAN0_LED0),
++	[37] = _DEF_GPIO_EXT_STS_LEDALL(LAN0_LED1),
++	[38] = _DEF_GPIO_EXT_STS_LEDALL(LAN1_LED0),
++	[39] = _DEF_GPIO_EXT_STS_LEDALL(LAN1_LED1),
++	[40] = _DEF_GPIO_EXT_STS_LEDALL(LAN2_LED0),
++	[41] = _DEF_GPIO_EXT_STS_LEDALL(LAN2_LED1),
++	[42] = _DEF_GPIO_EXT_STS_LEDALL(LAN3_LED0),
++	[43] = _DEF_GPIO_EXT_STS_LEDALL(LAN3_LED1),
++	[44] = _DEF_GPIO_EXT_STS_LEDALL(LAN4_LED0),
++	[45] = _DEF_GPIO_EXT_STS_LEDALL(LAN4_LED1),
++	[46] = _DEF_GPIO_EXT_STS_LEDALL(LAN5_LED0),
++	[47] = _DEF_GPIO_EXT_STS_LEDALL(LAN5_LED1),
++
++	/* GPIOs with value read from the 16-bit wide extended control status */
++	[48] = _DEF_GPIO_EXT_CTL(nRES_MMC, PERIPH_MCU),
++	[49] = _DEF_GPIO_EXT_CTL(nRES_LAN, PERIPH_MCU),
++	[50] = _DEF_GPIO_EXT_CTL(nRES_PHY, PERIPH_MCU),
++	[51] = _DEF_GPIO_EXT_CTL(nPERST0, PERIPH_MCU),
++	[52] = _DEF_GPIO_EXT_CTL(nPERST1, PERIPH_MCU),
++	[53] = _DEF_GPIO_EXT_CTL(nPERST2, PERIPH_MCU),
++	[54] = _DEF_GPIO_EXT_CTL(PHY_SFP, PERIPH_MCU),
++};
++
++/* mapping from interrupts to indexes of GPIOs in the omnia_gpios array */
++static const u8 omnia_int_to_gpio_idx[32] = {
++	[__bf_shf(INT_CARD_DET)]		= 4,
++	[__bf_shf(INT_MSATA_IND)]		= 5,
++	[__bf_shf(INT_USB30_OVC)]		= 6,
++	[__bf_shf(INT_USB31_OVC)]		= 7,
++	[__bf_shf(INT_BUTTON_PRESSED)]		= 12,
++	[__bf_shf(INT_SFP_nDET)]		= 16,
++	[__bf_shf(INT_BRIGHTNESS_CHANGED)]	= 11,
++	[__bf_shf(INT_WLAN0_MSATA_LED)]		= 28,
++	[__bf_shf(INT_WLAN1_LED)]		= 29,
++	[__bf_shf(INT_WLAN2_LED)]		= 30,
++	[__bf_shf(INT_WPAN0_LED)]		= 31,
++	[__bf_shf(INT_WPAN1_LED)]		= 32,
++	[__bf_shf(INT_WPAN2_LED)]		= 33,
++	[__bf_shf(INT_WAN_LED0)]		= 34,
++	[__bf_shf(INT_WAN_LED1)]		= 35,
++	[__bf_shf(INT_LAN0_LED0)]		= 36,
++	[__bf_shf(INT_LAN0_LED1)]		= 37,
++	[__bf_shf(INT_LAN1_LED0)]		= 38,
++	[__bf_shf(INT_LAN1_LED1)]		= 39,
++	[__bf_shf(INT_LAN2_LED0)]		= 40,
++	[__bf_shf(INT_LAN2_LED1)]		= 41,
++	[__bf_shf(INT_LAN3_LED0)]		= 42,
++	[__bf_shf(INT_LAN3_LED1)]		= 43,
++	[__bf_shf(INT_LAN4_LED0)]		= 44,
++	[__bf_shf(INT_LAN4_LED1)]		= 45,
++	[__bf_shf(INT_LAN5_LED0)]		= 46,
++	[__bf_shf(INT_LAN5_LED1)]		= 47,
++};
++
++/* index of PHY_SFP GPIO in the omnia_gpios array */
++#define OMNIA_GPIO_PHY_SFP_OFFSET	54
++
++static int omnia_ctl_cmd_locked(struct omnia_mcu *mcu, u8 cmd, u16 val,
++				u16 mask)
++{
++	size_t len;
++	u8 buf[5];
++
++	buf[0] = cmd;
++
++	switch (cmd) {
++	case CMD_GENERAL_CONTROL:
++		buf[1] = val;
++		buf[2] = mask;
++		len = 3;
++		break;
++
++	case CMD_EXT_CONTROL:
++		put_unaligned_le16(val, &buf[1]);
++		put_unaligned_le16(mask, &buf[3]);
++		len = 5;
++		break;
++
++	default:
++		BUG();
++	}
++
++	return omnia_cmd_write(mcu->client, buf, len);
++}
++
++static int omnia_ctl_cmd(struct omnia_mcu *mcu, u8 cmd, u16 val, u16 mask)
++{
++	int err;
++
++	mutex_lock(&mcu->lock);
++	err = omnia_ctl_cmd_locked(mcu, cmd, val, mask);
++	mutex_unlock(&mcu->lock);
++
++	return err;
++}
++
++static int omnia_gpio_request(struct gpio_chip *gc, unsigned int offset)
++{
++	if (!omnia_gpios[offset].cmd)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int omnia_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET) {
++		int val;
++
++		mutex_lock(&mcu->lock);
++		val = omnia_cmd_read_bit(mcu->client,
++					 CMD_GET_EXT_CONTROL_STATUS,
++					 EXT_CTL_PHY_SFP_AUTO);
++		mutex_unlock(&mcu->lock);
++
++		if (val < 0)
++			return val;
++
++		if (val)
++			return GPIO_LINE_DIRECTION_IN;
++
++		return GPIO_LINE_DIRECTION_OUT;
++	}
++
++	if (omnia_gpios[offset].ctl_cmd)
++		return GPIO_LINE_DIRECTION_OUT;
++
++	return GPIO_LINE_DIRECTION_IN;
++}
++
++static int omnia_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET)
++		return omnia_ctl_cmd(mcu, CMD_EXT_CONTROL, EXT_CTL_PHY_SFP_AUTO,
++				     EXT_CTL_PHY_SFP_AUTO);
++
++	if (gpio->ctl_cmd)
++		return -ENOTSUPP;
++
++	return 0;
++}
++
++static int omnia_gpio_direction_output(struct gpio_chip *gc,
++				       unsigned int offset, int value)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u16 val, mask;
++
++	if (!gpio->ctl_cmd)
++		return -ENOTSUPP;
++
++	mask = gpio->ctl_bit;
++	val = value ? mask : 0;
++
++	if (offset == OMNIA_GPIO_PHY_SFP_OFFSET)
++		mask |= EXT_CTL_PHY_SFP_AUTO;
++
++	return omnia_ctl_cmd(mcu, gpio->ctl_cmd, val, mask);
++}
++
++static int omnia_gpio_get(struct gpio_chip *gc, unsigned int offset)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	int ret;
++
++	/*
++	 * If firmware does not support the new interrupt API, we are informed
++	 * of every change of the status word by an interrupt from MCU and save
++	 * its value in the interrupt service routine. Simply return the saved
++	 * value.
++	 */
++	if (gpio->cmd == CMD_GET_STATUS_WORD &&
++	    !(mcu->features & FEAT_NEW_INT_API))
++		return !!(mcu->last_status & gpio->bit);
++
++	mutex_lock(&mcu->lock);
++
++	/*
++	 * If firmware does support the new interrupt API, we may have cached
++	 * the value of a GPIO in the interrupt service routine. If not, read
++	 * the relevant bit now.
++	 */
++	if (gpio->int_bit && (mcu->is_cached & gpio->int_bit))
++		ret = !!(mcu->cached & gpio->int_bit);
++	else
++		ret = omnia_cmd_read_bit(mcu->client, gpio->cmd, gpio->bit);
++
++	mutex_unlock(&mcu->lock);
++
++	return ret;
++}
++
++static int omnia_gpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,
++				   unsigned long *bits)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u32 sts_bits, ext_sts_bits, ext_ctl_bits;
++	int err, i;
++
++	sts_bits = 0;
++	ext_sts_bits = 0;
++	ext_ctl_bits = 0;
++
++	/* determine which bits to read from the 3 possible commands */
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].cmd == CMD_GET_STATUS_WORD)
++			sts_bits |= omnia_gpios[i].bit;
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_STATUS_DWORD)
++			ext_sts_bits |= omnia_gpios[i].bit;
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_CONTROL_STATUS)
++			ext_ctl_bits |= omnia_gpios[i].bit;
++	}
++
++	mutex_lock(&mcu->lock);
++
++	if (mcu->features & FEAT_NEW_INT_API) {
++		/* read relevant bits from status */
++		err = omnia_cmd_read_bits(mcu->client, CMD_GET_STATUS_WORD,
++					  sts_bits, &sts_bits);
++		if (err)
++			goto err_unlock;
++	} else {
++		/*
++		 * Use status word value cached in the interrupt service routine
++		 * if firmware does not support the new interrupt API.
++		 */
++		sts_bits = mcu->last_status;
++	}
++
++	/* read relevant bits from extended status */
++	err = omnia_cmd_read_bits(mcu->client, CMD_GET_EXT_STATUS_DWORD,
++				  ext_sts_bits, &ext_sts_bits);
++	if (err)
++		goto err_unlock;
++
++	/* read relevant bits from extended control */
++	err = omnia_cmd_read_bits(mcu->client, CMD_GET_EXT_CONTROL_STATUS,
++				  ext_ctl_bits, &ext_ctl_bits);
++	if (err)
++		goto err_unlock;
++
++	mutex_unlock(&mcu->lock);
++
++	/* assign relevant bits in result */
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].cmd == CMD_GET_STATUS_WORD)
++			__assign_bit(i, bits, sts_bits & omnia_gpios[i].bit);
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_STATUS_DWORD)
++			__assign_bit(i, bits, ext_sts_bits &
++					      omnia_gpios[i].bit);
++		else if (omnia_gpios[i].cmd == CMD_GET_EXT_CONTROL_STATUS)
++			__assign_bit(i, bits, ext_ctl_bits &
++					      omnia_gpios[i].bit);
++	}
++
++	return 0;
++
++err_unlock:
++	mutex_unlock(&mcu->lock);
++	return err;
++}
++
++static void omnia_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
++{
++	const struct omnia_gpio *gpio = &omnia_gpios[offset];
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	struct device *dev = &mcu->client->dev;
++	u16 val, mask;
++	int err;
++
++	if (!gpio->ctl_cmd)
++		return;
++
++	mask = gpio->ctl_bit;
++	val = value ? mask : 0;
++
++	err = omnia_ctl_cmd(mcu, gpio->ctl_cmd, val, mask);
++	if (err)
++		dev_err(dev, "Cannot set GPIO %u: %d\n", offset, err);
++}
++
++static void omnia_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
++				    unsigned long *bits)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	struct device *dev = &mcu->client->dev;
++	u16 ext_ctl, ext_ctl_mask;
++	u8 ctl, ctl_mask;
++	int err = 0, i;
++
++	ctl = 0;
++	ctl_mask = 0;
++	ext_ctl = 0;
++	ext_ctl_mask = 0;
++
++	for_each_set_bit(i, mask, ARRAY_SIZE(omnia_gpios)) {
++		if (omnia_gpios[i].ctl_cmd == CMD_GENERAL_CONTROL) {
++			ctl_mask |= omnia_gpios[i].ctl_bit;
++			if (test_bit(i, bits))
++				ctl |= omnia_gpios[i].ctl_bit;
++		} else if (omnia_gpios[i].ctl_cmd == CMD_EXT_CONTROL) {
++			ext_ctl_mask |= omnia_gpios[i].ctl_bit;
++			if (test_bit(i, bits))
++				ext_ctl |= omnia_gpios[i].ctl_bit;
++		}
++	}
++
++	mutex_lock(&mcu->lock);
++
++	if (ctl_mask)
++		err = omnia_ctl_cmd_locked(mcu, CMD_GENERAL_CONTROL, ctl,
++					   ctl_mask);
++
++	if (!err && ext_ctl_mask)
++		err = omnia_ctl_cmd_locked(mcu, CMD_EXT_CONTROL, ext_ctl,
++					   ext_ctl_mask);
++
++	mutex_unlock(&mcu->lock);
++
++	if (err)
++		dev_err(dev, "Cannot set GPIOs: %d\n", err);
++}
++
++static bool omnia_gpio_available(struct omnia_mcu *mcu,
++				 const struct omnia_gpio *gpio)
++{
++	if (gpio->feat_mask)
++		return (mcu->features & gpio->feat_mask) == gpio->feat;
++	else if (gpio->feat)
++		return mcu->features & gpio->feat;
++
++	return true;
++}
++
++static int omnia_gpio_init_valid_mask(struct gpio_chip *gc,
++				      unsigned long *valid_mask,
++				      unsigned int ngpios)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	unsigned int i;
++
++	for (i = 0; i < ngpios; i++) {
++		const struct omnia_gpio *gpio = &omnia_gpios[i];
++
++		if (!gpio->cmd && !gpio->int_bit) {
++			__clear_bit(i, valid_mask);
++			continue;
++		}
++
++		__assign_bit(i, valid_mask, omnia_gpio_available(mcu, gpio));
++	}
++
++	return 0;
++}
++
++static void omnia_irq_shutdown(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	mcu->rising &= ~bit;
++	mcu->falling &= ~bit;
++}
++
++static void omnia_irq_mask(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	if (!omnia_gpios[hwirq].cmd)
++		mcu->rising &= ~bit;
++	mcu->mask &= ~bit;
++}
++
++static void omnia_irq_unmask(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	mcu->mask |= bit;
++	if (!omnia_gpios[hwirq].cmd)
++		mcu->rising |= bit;
++}
++
++static int omnia_irq_set_type(struct irq_data *d, unsigned int type)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	struct device *dev = &mcu->client->dev;
++	u32 bit = omnia_gpios[hwirq].int_bit;
++
++	if (!(type & IRQ_TYPE_EDGE_BOTH)) {
++		dev_err(dev, "irq %u: unsupported type %u\n", d->irq, type);
++		return -EINVAL;
++	}
++
++	if (type & IRQ_TYPE_EDGE_RISING)
++		mcu->rising |= bit;
++	else
++		mcu->rising &= ~bit;
++
++	if (type & IRQ_TYPE_EDGE_FALLING)
++		mcu->falling |= bit;
++	else
++		mcu->falling &= ~bit;
++
++	return 0;
++}
++
++static void omnia_irq_bus_lock(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++
++	/* nothing to do if MCU firmware does not support new interrupt API */
++	if (!(mcu->features & FEAT_NEW_INT_API))
++		return;
++
++	mutex_lock(&mcu->lock);
++}
++
++static void omnia_irq_bus_sync_unlock(struct irq_data *d)
++{
++	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	struct device *dev = &mcu->client->dev;
++	u8 cmd[1 + CMD_INT_ARG_LEN];
++	u32 rising, falling;
++	int err;
++
++	/* nothing to do if MCU firmware does not support new interrupt API */
++	if (!(mcu->features & FEAT_NEW_INT_API))
++		return;
++
++	cmd[0] = CMD_SET_INT_MASK;
++
++	rising = mcu->rising & mcu->mask;
++	falling = mcu->falling & mcu->mask;
++
++	cmd[1] = rising;
++	cmd[2] = falling;
++	cmd[3] = rising >> 8;
++	cmd[4] = falling >> 8;
++	cmd[5] = rising >> 16;
++	cmd[6] = falling >> 16;
++	cmd[7] = rising >> 24;
++	cmd[8] = falling >> 24;
++
++	dev_dbg(dev, "set int mask %8ph\n", &cmd[1]);
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err) {
++		dev_err(dev, "Cannot set mask: %d\n", err);
++		goto unlock;
++	}
++
++	/*
++	 * Remember which GPIOs have both rising and falling interrupts enabled.
++	 * For those we will cache their value so that .get() method is faster.
++	 * We also need to forget cached values of GPIOs that aren't cached
++	 * anymore.
++	 */
++	mcu->both = rising & falling;
++	mcu->is_cached &= mcu->both;
++
++unlock:
++	mutex_unlock(&mcu->lock);
++}
++
++static void omnia_irq_init_valid_mask(struct gpio_chip *gc,
++				      unsigned long *valid_mask,
++				      unsigned int ngpios)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	unsigned int i;
++
++	for (i = 0; i < ngpios; i++) {
++		const struct omnia_gpio *gpio = &omnia_gpios[i];
++
++		if (!gpio->int_bit) {
++			__clear_bit(i, valid_mask);
++			continue;
++		}
++
++		__assign_bit(i, valid_mask, omnia_gpio_available(mcu, gpio));
++	}
++}
++
++static int omnia_irq_init_hw(struct gpio_chip *gc)
++{
++	struct omnia_mcu *mcu = gpiochip_get_data(gc);
++	u8 cmd[1 + CMD_INT_ARG_LEN] = {};
++
++	cmd[0] = CMD_SET_INT_MASK;
++
++	return omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++}
++
++/*
++ * Determine how many bytes we need to read from the reply to the
++ * CMD_GET_INT_AND_CLEAR command in order to retrieve all unmasked interrupts.
++ */
++static size_t omnia_irq_compute_pending_length(u32 rising, u32 falling)
++{
++	size_t rlen = 0, flen = 0;
++
++	if (rising)
++		rlen = ((__fls(rising) >> 3) << 1) + 1;
++
++	if (falling)
++		flen = ((__fls(falling) >> 3) << 1) + 2;
++
++	return max(rlen, flen);
++}
++
++static bool omnia_irq_read_pending_new(struct omnia_mcu *mcu,
++				       unsigned long *pending)
++{
++	struct device *dev = &mcu->client->dev;
++	u8 reply[CMD_INT_ARG_LEN] = {};
++	u32 rising, falling;
++	size_t len;
++	int err;
++
++	len = omnia_irq_compute_pending_length(mcu->rising & mcu->mask,
++					       mcu->falling & mcu->mask);
++	if (!len)
++		return false;
++
++	mutex_lock(&mcu->lock);
++
++	err = omnia_cmd_read(mcu->client, CMD_GET_INT_AND_CLEAR, reply,
++			     len);
++	if (err) {
++		mutex_unlock(&mcu->lock);
++		dev_err(dev, "Cannot read pending IRQs: %d\n", err);
++		return false;
++	}
++
++	rising = reply[0] | (reply[2] << 8) | (reply[4] << 16) |
++		 (reply[6] << 24);
++	falling = reply[1] | (reply[3] << 8) | (reply[5] << 16) |
++		  (reply[7] << 24);
++
++	rising &= mcu->mask;
++	falling &= mcu->mask;
++	*pending = rising | falling;
++
++	/* cache values for GPIOs that have both edges enabled */
++	mcu->is_cached &= ~(rising & falling);
++	mcu->is_cached |= mcu->both & (rising ^ falling);
++	mcu->cached = (mcu->cached | rising) & ~falling;
++
++	mutex_unlock(&mcu->lock);
++
++	return true;
++}
++
++static int omnia_read_status_word_old_fw(struct omnia_mcu *mcu, u16 *status)
++{
++	int ret;
++
++	ret = omnia_cmd_read_u16(mcu->client, CMD_GET_STATUS_WORD);
++	if (ret < 0)
++		return ret;
++
++	/*
++	 * Old firmware has a bug wherein it never resets the USB port
++	 * overcurrent bits back to zero. Ignore them.
++	 */
++	*status = ret & ~(STS_USB30_OVC | STS_USB31_OVC);
++
++	return 0;
++}
++
++static void button_release_emul_fn(struct work_struct *work)
++{
++	struct omnia_mcu *mcu = container_of(to_delayed_work(work),
++					     struct omnia_mcu,
++					     button_release_emul_work);
++
++	mcu->button_pressed_emul = false;
++	generic_handle_irq(mcu->client->irq);
++}
++
++static void fill_int_from_sts(u32 *rising, u32 *falling, u16 rising_sts,
++			      u16 falling_sts, u16 sts_bit, u32 int_bit)
++{
++	if (rising_sts & sts_bit)
++		*rising |= int_bit;
++	if (falling_sts & sts_bit)
++		*falling |= int_bit;
++}
++
++static bool omnia_irq_read_pending_old(struct omnia_mcu *mcu,
++				       unsigned long *pending)
++{
++	struct device *dev = &mcu->client->dev;
++	u16 status, rising_sts, falling_sts;
++	u32 rising, falling;
++	int ret;
++
++	mutex_lock(&mcu->lock);
++
++	ret = omnia_read_status_word_old_fw(mcu, &status);
++	if (ret < 0) {
++		mutex_unlock(&mcu->lock);
++		dev_err(dev, "Cannot read pending IRQs: %d\n", ret);
++		return false;
++	}
++
++	/*
++	 * The old firmware triggers an interrupt whenever status word changes,
++	 * but does not inform about which bits rose or fell. We need to compute
++	 * this here by comparing with the last status word value.
++	 *
++	 * The STS_BUTTON_PRESSED bit needs special handling, because the old
++	 * firmware clears the STS_BUTTON_PRESSED bit on successful completion
++	 * of the CMD_GET_STATUS_WORD command, resulting in another interrupt:
++	 * - first we get an interrupt, we read the status word where
++	 *   STS_BUTTON_PRESSED is present,
++	 * - MCU clears the STS_BUTTON_PRESSED bit because we read the status
++	 *   word,
++	 * - we get another interrupt because the status word changed again
++	 *   (STS_BUTTON_PRESSED was cleared).
++	 *
++	 * The gpiolib-cdev, gpiolib-sysfs and gpio-keys input driver all call
++	 * the gpiochip's .get() method after an edge event on a requested GPIO
++	 * occurs.
++	 *
++	 * We ensure that the .get() method reads 1 for the button GPIO for some
++	 * time.
++	 */
++
++	if (status & STS_BUTTON_PRESSED) {
++		mcu->button_pressed_emul = true;
++		mod_delayed_work(system_wq, &mcu->button_release_emul_work,
++				 msecs_to_jiffies(FRONT_BUTTON_RELEASE_DELAY));
++	} else if (mcu->button_pressed_emul) {
++		status |= STS_BUTTON_PRESSED;
++	}
++
++	rising_sts = ~mcu->last_status & status;
++	falling_sts = mcu->last_status & ~status;
++
++	mcu->last_status = status;
++
++	/*
++	 * Fill in the relevant interrupt bits from status bits for CARD_DET,
++	 * MSATA_IND and BUTTON_PRESSED.
++	 */
++	rising = 0;
++	falling = 0;
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_CARD_DET, INT_CARD_DET);
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_MSATA_IND, INT_MSATA_IND);
++	fill_int_from_sts(&rising, &falling, rising_sts, falling_sts,
++			  STS_BUTTON_PRESSED, INT_BUTTON_PRESSED);
++
++	/* Use only bits that are enabled */
++	rising &= mcu->rising & mcu->mask;
++	falling &= mcu->falling & mcu->mask;
++	*pending = rising | falling;
++
++	mutex_unlock(&mcu->lock);
++
++	return true;
++}
++
++static bool omnia_irq_read_pending(struct omnia_mcu *mcu,
++				   unsigned long *pending)
++{
++	if (mcu->features & FEAT_NEW_INT_API)
++		return omnia_irq_read_pending_new(mcu, pending);
++	else
++		return omnia_irq_read_pending_old(mcu, pending);
++}
++
++static irqreturn_t omnia_irq_thread_handler(int irq, void *dev_id)
++{
++	struct omnia_mcu *mcu = dev_id;
++	struct irq_domain *domain;
++	unsigned long pending;
++	int i;
++
++	if (!omnia_irq_read_pending(mcu, &pending))
++		return IRQ_NONE;
++
++	domain = mcu->gc.irq.domain;
++
++	for_each_set_bit(i, &pending, 32) {
++		unsigned int nested_irq;
++
++		nested_irq = irq_find_mapping(domain, omnia_int_to_gpio_idx[i]);
++
++		handle_nested_irq(nested_irq);
++	}
++
++	return IRQ_RETVAL(pending);
++}
++
++static const char * const front_button_modes[2] = { "mcu", "cpu" };
++
++static ssize_t front_button_mode_show(struct device *dev,
++				      struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	int val;
++
++	if (mcu->features & FEAT_NEW_INT_API) {
++		val = omnia_cmd_read_bit(mcu->client, CMD_GET_STATUS_WORD,
++					 STS_BUTTON_MODE);
++		if (val < 0)
++			return val;
++	} else {
++		val = !!(mcu->last_status & STS_BUTTON_MODE);
++	}
++
++	return sysfs_emit(buf, "%s\n", front_button_modes[val]);
++}
++
++static ssize_t front_button_mode_store(struct device *dev,
++				       struct device_attribute *a,
++				       const char *buf, size_t count)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	u8 mask, val;
++	int err, i;
++
++	mask = CTL_BUTTON_MODE;
++
++	i = sysfs_match_string(front_button_modes, buf);
++	if (i < 0)
++		return i;
++
++	val = i ? mask : 0;
++	err = omnia_ctl_cmd_locked(mcu, CMD_GENERAL_CONTROL, val, mask);
++	if (err)
++		return err;
++
++	return count;
++}
++static DEVICE_ATTR_RW(front_button_mode);
++
++static struct attribute *omnia_mcu_gpio_attrs[] = {
++	&dev_attr_front_button_mode.attr,
++	NULL
++};
++
++const struct attribute_group omnia_mcu_gpio_group = {
++	.attrs = omnia_mcu_gpio_attrs,
++};
++
++int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu)
++{
++	bool new_api = mcu->features & FEAT_NEW_INT_API;
++	struct device *dev = &mcu->client->dev;
++	unsigned long irqflags;
++	int err;
++
++	mutex_init(&mcu->lock);
++
++	mcu->gc.request = omnia_gpio_request;
++	mcu->gc.get_direction = omnia_gpio_get_direction;
++	mcu->gc.direction_input = omnia_gpio_direction_input;
++	mcu->gc.direction_output = omnia_gpio_direction_output;
++	mcu->gc.get = omnia_gpio_get;
++	mcu->gc.get_multiple = omnia_gpio_get_multiple;
++	mcu->gc.set = omnia_gpio_set;
++	mcu->gc.set_multiple = omnia_gpio_set_multiple;
++	mcu->gc.init_valid_mask = omnia_gpio_init_valid_mask;
++	mcu->gc.can_sleep = true;
++	mcu->gc.names = omnia_mcu_gpio_templates;
++	mcu->gc.base = -1;
++	mcu->gc.ngpio = ARRAY_SIZE(omnia_gpios);
++	mcu->gc.label = "Turris Omnia MCU GPIOs";
++	mcu->gc.parent = dev;
++	mcu->gc.owner = THIS_MODULE;
++
++	mcu->ic.name = "Turris Omnia MCU interrupts";
++	mcu->ic.irq_shutdown = omnia_irq_shutdown;
++	mcu->ic.irq_mask = omnia_irq_mask;
++	mcu->ic.irq_unmask = omnia_irq_unmask;
++	mcu->ic.irq_set_type = omnia_irq_set_type;
++	mcu->ic.irq_bus_lock = omnia_irq_bus_lock;
++	mcu->ic.irq_bus_sync_unlock = omnia_irq_bus_sync_unlock;
++
++	mcu->gc.irq.chip = &mcu->ic;
++	/* This will let us handle the parent IRQ in the driver */
++	mcu->gc.irq.parent_handler = NULL;
++	mcu->gc.irq.num_parents = 0;
++	mcu->gc.irq.parents = NULL;
++	mcu->gc.irq.default_type = IRQ_TYPE_NONE;
++	mcu->gc.irq.handler = handle_bad_irq;
++	mcu->gc.irq.threaded = true;
++	if (new_api)
++		mcu->gc.irq.init_hw = omnia_irq_init_hw;
++	mcu->gc.irq.init_valid_mask = omnia_irq_init_valid_mask;
++
++	err = devm_gpiochip_add_data(dev, &mcu->gc, mcu);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot add GPIO chip\n");
++
++	/*
++	 * Before requesting the interrupt, if firmware does not support the new
++	 * interrupt API, we need to cache the value of the status word, so that
++	 * when it changes, we may compare the new value with the cached one in
++	 * the interrupt handler.
++	 */
++	if (!new_api) {
++		err = omnia_read_status_word_old_fw(mcu, &mcu->last_status);
++		if (err < 0)
++			return dev_err_probe(dev, err,
++					     "Cannot read status word\n");
++
++		INIT_DELAYED_WORK(&mcu->button_release_emul_work,
++				  button_release_emul_fn);
++	}
++
++	irqflags = IRQF_ONESHOT;
++	if (new_api)
++		irqflags |= IRQF_TRIGGER_LOW;
++	else
++		irqflags |= IRQF_TRIGGER_FALLING;
++
++	err = request_threaded_irq(mcu->client->irq, NULL,
++				   omnia_irq_thread_handler, irqflags,
++				   "turris-omnia-mcu", mcu);
++	if (err)
++		return dev_err_probe(dev, err, "Cannot request IRQ\n");
++
++	return 0;
++}
++
++void omnia_mcu_unregister_gpiochip(struct omnia_mcu *mcu)
++{
++	if (!(mcu->features & FEAT_NEW_INT_API))
++		cancel_delayed_work_sync(&mcu->button_release_emul_work);
++
++	free_irq(mcu->client->irq, mcu);
++
++	mutex_destroy(&mcu->lock);
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index ee7c7cf34243..5383d4ca9b67 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -8,16 +8,40 @@
+ #ifndef __TURRIS_OMNIA_MCU_H
+ #define __TURRIS_OMNIA_MCU_H
+ 
++#include <linux/bitops.h>
++#include <linux/gpio/driver.h>
+ #include <linux/i2c.h>
++#include <linux/mutex.h>
+ #include <linux/types.h>
++#include <linux/workqueue.h>
+ #include <asm/byteorder.h>
+ 
+ struct omnia_mcu {
+ 	struct i2c_client *client;
+ 	const char *type;
+ 	u16 features;
++
++	/* GPIO chip */
++	struct gpio_chip gc;
++	struct irq_chip ic;
++	struct mutex lock;
++	u32 mask, rising, falling, both, cached, is_cached;
++	/* Old MCU firmware handling needs the following */
++	struct delayed_work button_release_emul_work;
++	u16 last_status;
++	bool button_pressed_emul;
+ };
+ 
++static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
++				  size_t len)
++{
++	int ret;
++
++	ret = i2c_master_send(client, cmd, len);
++
++	return ret < 0 ? ret : 0;
++}
++
+ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd, void *reply,
+ 				 unsigned int len)
+ {
+@@ -42,9 +66,41 @@ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd, void *
+ 	return 0;
+ }
+ 
++/* Returns 0 on success */
++static inline int omnia_cmd_read_bits(const struct i2c_client *client, u8 cmd,
++				      u32 bits, u32 *dst)
++{
++	__le32 reply;
++	int err;
++
++	if (!bits) {
++		*dst = 0;
++		return 0;
++	}
++
++	err = omnia_cmd_read(client, cmd, &reply, (__fls(bits) >> 3) + 1);
++	if (!err)
++		*dst = le32_to_cpu(reply) & bits;
++
++	return err;
++}
++
++static inline int omnia_cmd_read_bit(const struct i2c_client *client, u8 cmd,
++				     u32 bit)
++{
++	u32 reply;
++	int err;
++
++	err = omnia_cmd_read_bits(client, cmd, bit, &reply);
++	if (err)
++		return err;
++
++	return !!reply;
++}
++
+ static inline int omnia_cmd_read_u16(const struct i2c_client *client, u8 cmd)
+ {
+-	u16 reply;
++	__le16 reply;
+ 	int err;
+ 
+ 	err = omnia_cmd_read(client, cmd, &reply, sizeof(reply));
+@@ -62,4 +118,9 @@ static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
+ 	return err ?: reply;
+ }
+ 
++extern const struct attribute_group omnia_mcu_gpio_group;
++
++int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
++void omnia_mcu_unregister_gpiochip(struct omnia_mcu *mcu);
++
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-4-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch b/target/linux/mvebu/patches-5.15/103-v6.7-4-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
new file mode 100644
index 0000000000..1f03b2676c
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-4-platform-cznic-turris-omnia-mcu-Add-support-for-powe.patch
@@ -0,0 +1,447 @@
+From 3b0fbfaad455271a905a20ddcff48c449c826339 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 12:16:25 +0200
+Subject: [PATCH 12/17] platform: cznic: turris-omnia-mcu: Add support for
+ poweroff and wakeup
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for true board poweroff (MCU can disable all unnecessary
+voltage regulators) and wakeup at a specified time, implemented via a
+RTC driver so that the rtcwake utility can be used to configure it.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ .../sysfs-bus-i2c-devices-turris-omnia-mcu    |  16 ++
+ drivers/platform/cznic/Kconfig                |   4 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |  12 +-
+ .../cznic/turris-omnia-mcu-sys-off-wakeup.c   | 261 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  24 ++
+ 6 files changed, 317 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+index e635ba45ef9a..a69172d5b998 100644
+--- a/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
++++ b/Documentation/ABI/testing/sysfs-bus-i2c-devices-turris-omnia-mcu
+@@ -14,6 +14,22 @@ Description:	(RW) The front button on the Turris Omnia router can be
+ 
+ 		Format: %s.
+ 
++What:		/sys/bus/i2c/devices/<mcu_device>/front_button_poweron
++Date:		August 2023
++KernelVersion:	6.6
++Contact:	Marek Behún <kabel@kernel.org>
++Description:	(RW) Newer versions of the microcontroller firmware of the
++		Turris Omnia router support powering off the router into true
++		low power mode. The router can be powered on by pressing the
++		front button.
++
++		This file configures whether front button power on is enabled.
++
++		This file is present only if the power off feature is supported
++		by the firmware.
++
++		Format: %i.
++
+ What:		/sys/bus/i2c/devices/<mcu_device>/fw_features
+ Date:		November 2023
+ KernelVersion:	6.7
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index 3a8c3edcd7e6..0a752aa654fa 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -19,10 +19,14 @@ config TURRIS_OMNIA_MCU
+ 	depends on I2C
+ 	select GPIOLIB
+ 	select GPIOLIB_IRQCHIP
++	select RTC_CLASS
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
+ 	  The features include:
++	  - board poweroff into true low power mode (with voltage regulators
++	    disabled) and the ability to configure wake up from this mode (via
++	    rtcwake)
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+ 	      configured either to generate press events to the CPU or to change
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index a6177f5b4fff..6f1470d1f673 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -3,3 +3,4 @@
+ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index 272e0b0496d6..2e82419734d2 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -112,6 +112,7 @@ static const struct attribute_group omnia_mcu_base_group = {
+ static const struct attribute_group *omnia_mcu_groups[] = {
+ 	&omnia_mcu_base_group,
+ 	&omnia_mcu_gpio_group,
++	&omnia_mcu_poweroff_group,
+ 	NULL
+ };
+ 
+@@ -239,7 +240,15 @@ static int omnia_mcu_probe(struct i2c_client *client,
+ 		return dev_err_probe(dev, err,
+ 				     "Cannot determine MCU supported features\n");
+ 
+-	return omnia_mcu_register_gpiochip(mcu);
++	err = omnia_mcu_register_sys_off_and_wakeup(mcu);
++	if (err)
++		return err;
++
++	err = omnia_mcu_register_gpiochip(mcu);
++	if (err)
++		omnia_mcu_unregister_sys_off_and_wakeup(mcu);
++
++	return err;
+ }
+ 
+ static int omnia_mcu_remove(struct i2c_client *client)
+@@ -247,6 +256,7 @@ static int omnia_mcu_remove(struct i2c_client *client)
+ 	struct omnia_mcu *mcu = i2c_get_clientdata(client);
+ 
+ 	omnia_mcu_unregister_gpiochip(mcu);
++	omnia_mcu_unregister_sys_off_and_wakeup(mcu);
+ 
+ 	return 0;
+ }
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c b/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+new file mode 100644
+index 000000000000..35dddadf6262
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-sys-off-wakeup.c
+@@ -0,0 +1,261 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU system off and RTC wakeup driver
++ *
++ * This is not a true RTC driver (in the sense that it does not provide a
++ * real-time clock), rather the MCU implements a wakeup from powered off state
++ * at a specified time relative to MCU boot, and we expose this feature via RTC
++ * alarm, so that it can be used via the rtcwake command, which is the standard
++ * Linux command for this.
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/crc32.h>
++#include <linux/delay.h>
++#include <linux/i2c.h>
++#include <linux/reboot.h>
++#include <linux/rtc.h>
++#include <linux/sysfs.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++
++#include "turris-omnia-mcu.h"
++
++static int omnia_get_uptime_wakeup(const struct i2c_client *client, u32 *uptime,
++				   u32 *wakeup)
++{
++	__le32 reply[2];
++	int err;
++
++	err = omnia_cmd_read(client, CMD_GET_UPTIME_AND_WAKEUP, reply,
++			     sizeof(reply));
++	if (err)
++		return err;
++
++	if (uptime)
++		*uptime = le32_to_cpu(reply[0]);
++
++	if (wakeup)
++		*wakeup = le32_to_cpu(reply[1]);
++
++	return 0;
++}
++
++static int omnia_read_time(struct device *dev, struct rtc_time *tm)
++{
++	u32 uptime;
++	int err;
++
++	err = omnia_get_uptime_wakeup(to_i2c_client(dev), &uptime, NULL);
++	if (err)
++		return err;
++
++	rtc_time64_to_tm(uptime, tm);
++
++	return 0;
++}
++
++static int omnia_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++	u32 wakeup;
++	int err;
++
++	err = omnia_get_uptime_wakeup(client, NULL, &wakeup);
++	if (err)
++		return err;
++
++	alrm->enabled = !!wakeup;
++	rtc_time64_to_tm(wakeup ?: mcu->rtc_alarm, &alrm->time);
++
++	return 0;
++}
++
++static int omnia_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++
++	mcu->rtc_alarm = rtc_tm_to_time64(&alrm->time);
++
++	if (alrm->enabled)
++		return omnia_cmd_write_u32(client, CMD_SET_WAKEUP,
++					   mcu->rtc_alarm);
++	else
++		return 0;
++}
++
++static int omnia_alarm_irq_enable(struct device *dev, unsigned int enabled)
++{
++	struct i2c_client *client = to_i2c_client(dev);
++	struct omnia_mcu *mcu = i2c_get_clientdata(client);
++
++	return omnia_cmd_write_u32(client, CMD_SET_WAKEUP,
++				   enabled ? mcu->rtc_alarm : 0);
++}
++
++static const struct rtc_class_ops omnia_rtc_ops = {
++	.read_time		= omnia_read_time,
++	.read_alarm		= omnia_read_alarm,
++	.set_alarm		= omnia_set_alarm,
++	.alarm_irq_enable	= omnia_alarm_irq_enable,
++};
++
++static struct omnia_mcu *omnia_power_off_mcu_ptr;
++
++static void omnia_power_off(void)
++{
++	struct omnia_mcu *mcu = omnia_power_off_mcu_ptr;
++	__be32 tmp;
++	u8 cmd[9];
++	u16 arg;
++	int err;
++
++	if (mcu->front_button_poweron)
++		arg = CMD_POWER_OFF_POWERON_BUTTON;
++	else
++		arg = 0;
++
++	cmd[0] = CMD_POWER_OFF;
++	put_unaligned_le16(CMD_POWER_OFF_MAGIC, &cmd[1]);
++	put_unaligned_le16(arg, &cmd[3]);
++
++	tmp = cpu_to_be32(get_unaligned_le32(&cmd[1]));
++	put_unaligned_le32(crc32_be(0xffffffff, (void *)&tmp, sizeof(tmp)),
++			   &cmd[5]);
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err)
++		dev_err(&mcu->client->dev,
++			"Unable to send the poweroff command: %d\n", err);
++}
++
++static int omnia_restart(struct notifier_block *nb, unsigned long reboot_mode,
++			 void *restart_cmd)
++{
++	struct omnia_mcu *mcu = container_of(nb, struct omnia_mcu, restart_nb);
++	u8 cmd[3];
++	int err;
++
++	cmd[0] = CMD_GENERAL_CONTROL;
++
++	if (reboot_mode == REBOOT_HARD)
++		cmd[1] = cmd[2] = CTL_HARD_RST;
++	else
++		cmd[1] = cmd[2] = CTL_LIGHT_RST;
++
++	err = omnia_cmd_write(mcu->client, cmd, sizeof(cmd));
++	if (err)
++		dev_err(&mcu->client->dev,
++			"Unable to send the restart command: %d\n", err);
++
++	/*
++	 * MCU needs a little bit to process the I2C command, otherwise it will
++	 * do a light reset based on SOC SYSRES_OUT pin.
++	 */
++	mdelay(1);
++
++	return NOTIFY_DONE;
++}
++
++static ssize_t front_button_poweron_show(struct device *dev,
++					 struct device_attribute *a, char *buf)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	return sysfs_emit(buf, "%d\n", mcu->front_button_poweron);
++}
++
++static ssize_t front_button_poweron_store(struct device *dev,
++					  struct device_attribute *a,
++					  const char *buf, size_t count)
++{
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++	bool val;
++
++	if (kstrtobool(buf, &val) < 0)
++		return -EINVAL;
++
++	mcu->front_button_poweron = val;
++
++	return count;
++}
++static DEVICE_ATTR_RW(front_button_poweron);
++
++static struct attribute *omnia_mcu_poweroff_attrs[] = {
++	&dev_attr_front_button_poweron.attr,
++	NULL
++};
++
++static umode_t poweroff_attrs_visible(struct kobject *kobj, struct attribute *a,
++				      int n)
++{
++	struct device *dev = container_of(kobj, typeof(*dev), kobj);
++	struct omnia_mcu *mcu = i2c_get_clientdata(to_i2c_client(dev));
++
++	if (mcu->features & FEAT_POWEROFF_WAKEUP)
++		return a->mode;
++
++	return 0;
++}
++
++const struct attribute_group omnia_mcu_poweroff_group = {
++	.attrs = omnia_mcu_poweroff_attrs,
++	.is_visible = poweroff_attrs_visible,
++};
++
++int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	int err;
++
++	/* MCU restart is always available */
++	mcu->restart_nb.notifier_call = omnia_restart;
++	mcu->restart_nb.priority = 0;
++
++	err = register_restart_handler(&mcu->restart_nb);
++	if (err)
++		return dev_err_probe(dev, err,
++				     "Cannot register system restart handler\n");
++
++	/*
++	 * poweroff and wakeup are available only if POWEROFF_WAKEUP feature is
++	 * present
++	 */
++	if (!(mcu->features & FEAT_POWEROFF_WAKEUP))
++		return 0;
++
++	mcu->rtcdev = devm_rtc_allocate_device(dev);
++	if (IS_ERR(mcu->rtcdev)) {
++		unregister_restart_handler(&mcu->restart_nb);
++		return dev_err_probe(dev, PTR_ERR(mcu->rtcdev),
++				     "Cannot allocate RTC device\n");
++	}
++
++	mcu->rtcdev->ops = &omnia_rtc_ops;
++	mcu->rtcdev->range_max = U32_MAX;
++
++	err = devm_rtc_register_device(mcu->rtcdev);
++	if (err) {
++		unregister_restart_handler(&mcu->restart_nb);
++		return dev_err_probe(dev, err, "Cannot register RTC device\n");
++	}
++
++	mcu->front_button_poweron = true;
++
++	omnia_power_off_mcu_ptr = mcu;
++	mcu->prev_pm_power_off = pm_power_off;
++	pm_power_off = omnia_power_off;
++
++	return err;
++}
++
++void omnia_mcu_unregister_sys_off_and_wakeup(struct omnia_mcu *mcu)
++{
++	if (mcu->features & FEAT_POWEROFF_WAKEUP)
++		pm_power_off = mcu->prev_pm_power_off;
++
++	unregister_restart_handler(&mcu->restart_nb);
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index 5383d4ca9b67..d7f0c9e84e36 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -12,9 +12,12 @@
+ #include <linux/gpio/driver.h>
+ #include <linux/i2c.h>
+ #include <linux/mutex.h>
++#include <linux/notifier.h>
++#include <linux/rtc.h>
+ #include <linux/types.h>
+ #include <linux/workqueue.h>
+ #include <asm/byteorder.h>
++#include <asm/unaligned.h>
+ 
+ struct omnia_mcu {
+ 	struct i2c_client *client;
+@@ -30,6 +33,13 @@ struct omnia_mcu {
+ 	struct delayed_work button_release_emul_work;
+ 	u16 last_status;
+ 	bool button_pressed_emul;
++
++	/* RTC device for configuring wake-up */
++	struct rtc_device *rtcdev;
++	u32 rtc_alarm;
++	bool front_button_poweron;
++	struct notifier_block restart_nb;
++	void (*prev_pm_power_off)(void);
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -42,6 +52,17 @@ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++static inline int omnia_cmd_write_u32(const struct i2c_client *client, u8 cmd,
++				      u32 val)
++{
++	u8 buf[5];
++
++	buf[0] = cmd;
++	put_unaligned_le32(val, &buf[1]);
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
+ static inline int omnia_cmd_read(const struct i2c_client *client, u8 cmd, void *reply,
+ 				 unsigned int len)
+ {
+@@ -119,8 +140,11 @@ static inline int omnia_cmd_read_u8(const struct i2c_client *client, u8 cmd)
+ }
+ 
+ extern const struct attribute_group omnia_mcu_gpio_group;
++extern const struct attribute_group omnia_mcu_poweroff_group;
+ 
+ int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
+ void omnia_mcu_unregister_gpiochip(struct omnia_mcu *mcu);
++int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
++void omnia_mcu_unregister_sys_off_and_wakeup(struct omnia_mcu *mcu);
+ 
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch b/target/linux/mvebu/patches-5.15/103-v6.7-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
new file mode 100644
index 0000000000..db9d7eea39
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-5-platform-cznic-turris-omnia-mcu-Add-support-for-MCU-.patch
@@ -0,0 +1,261 @@
+From e9146f96269b2cb9e98bdd711dc7eed099606209 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 19 Sep 2023 12:21:40 +0200
+Subject: [PATCH 13/17] platform: cznic: turris-omnia-mcu: Add support for MCU
+ watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for the watchdog mechanism provided by the MCU.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/platform/cznic/Kconfig                |   2 +
+ drivers/platform/cznic/Makefile               |   1 +
+ .../platform/cznic/turris-omnia-mcu-base.c    |  10 +-
+ .../cznic/turris-omnia-mcu-watchdog.c         | 122 ++++++++++++++++++
+ drivers/platform/cznic/turris-omnia-mcu.h     |  24 ++++
+ 5 files changed, 158 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+
+diff --git a/drivers/platform/cznic/Kconfig b/drivers/platform/cznic/Kconfig
+index 0a752aa654fa..e2649cdecc38 100644
+--- a/drivers/platform/cznic/Kconfig
++++ b/drivers/platform/cznic/Kconfig
+@@ -20,6 +20,7 @@ config TURRIS_OMNIA_MCU
+ 	select GPIOLIB
+ 	select GPIOLIB_IRQCHIP
+ 	select RTC_CLASS
++	select WATCHDOG_CORE
+ 	help
+ 	  Say Y here to add support for the features implemented by the
+ 	  microcontroller on the CZ.NIC's Turris Omnia SOHO router.
+@@ -27,6 +28,7 @@ config TURRIS_OMNIA_MCU
+ 	  - board poweroff into true low power mode (with voltage regulators
+ 	    disabled) and the ability to configure wake up from this mode (via
+ 	    rtcwake)
++	  - MCU watchdog
+ 	  - GPIO pins
+ 	    - to get front button press events (the front button can be
+ 	      configured either to generate press events to the CPU or to change
+diff --git a/drivers/platform/cznic/Makefile b/drivers/platform/cznic/Makefile
+index 6f1470d1f673..a43997a12d74 100644
+--- a/drivers/platform/cznic/Makefile
++++ b/drivers/platform/cznic/Makefile
+@@ -4,3 +4,4 @@ obj-$(CONFIG_TURRIS_OMNIA_MCU)	+= turris-omnia-mcu.o
+ turris-omnia-mcu-objs		:= turris-omnia-mcu-base.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-gpio.o
+ turris-omnia-mcu-objs		+= turris-omnia-mcu-sys-off-wakeup.o
++turris-omnia-mcu-objs		+= turris-omnia-mcu-watchdog.o
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-base.c b/drivers/platform/cznic/turris-omnia-mcu-base.c
+index 2e82419734d2..6d401ce5d5dd 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu-base.c
++++ b/drivers/platform/cznic/turris-omnia-mcu-base.c
+@@ -244,11 +244,19 @@ static int omnia_mcu_probe(struct i2c_client *client,
+ 	if (err)
+ 		return err;
+ 
++	err = omnia_mcu_register_watchdog(mcu);
++	if (err)
++		goto err_unregister_sys_off;
++
+ 	err = omnia_mcu_register_gpiochip(mcu);
+ 	if (err)
+-		omnia_mcu_unregister_sys_off_and_wakeup(mcu);
++		goto err_unregister_sys_off;
+ 
+ 	return err;
++
++err_unregister_sys_off:
++	omnia_mcu_unregister_sys_off_and_wakeup(mcu);
++	return err;
+ }
+ 
+ static int omnia_mcu_remove(struct i2c_client *client)
+diff --git a/drivers/platform/cznic/turris-omnia-mcu-watchdog.c b/drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+new file mode 100644
+index 000000000000..6685166bc4c7
+--- /dev/null
++++ b/drivers/platform/cznic/turris-omnia-mcu-watchdog.c
+@@ -0,0 +1,122 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * CZ.NIC's Turris Omnia MCU watchdog driver
++ *
++ * 2023 by Marek Behún <kabel@kernel.org>
++ */
++
++#include <linux/moduleparam.h>
++#include <linux/turris-omnia-mcu-interface.h>
++#include <linux/types.h>
++#include <linux/watchdog.h>
++
++#include "turris-omnia-mcu.h"
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++static int omnia_wdt_start(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 1);
++}
++
++static int omnia_wdt_stop(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 0);
++}
++
++static int omnia_wdt_ping(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u8(mcu->client, CMD_SET_WATCHDOG_STATE, 1);
++}
++
++static int omnia_wdt_set_timeout(struct watchdog_device *wdt,
++				 unsigned int timeout)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++
++	return omnia_cmd_write_u16(mcu->client, CMD_SET_WDT_TIMEOUT,
++				   timeout * 10);
++}
++
++static unsigned int omnia_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct omnia_mcu *mcu = watchdog_get_drvdata(wdt);
++	int ret;
++
++	ret = omnia_cmd_read_u16(mcu->client, CMD_GET_WDT_TIMELEFT);
++	if (ret < 0) {
++		dev_err(&mcu->client->dev, "Cannot get watchdog timeleft: %d\n",
++			ret);
++		return 0;
++	}
++
++	return ret / 10;
++}
++
++static const struct watchdog_info omnia_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Turris Omnia MCU Watchdog",
++};
++
++static const struct watchdog_ops omnia_wdt_ops = {
++	.owner		= THIS_MODULE,
++	.start		= omnia_wdt_start,
++	.stop		= omnia_wdt_stop,
++	.ping		= omnia_wdt_ping,
++	.set_timeout	= omnia_wdt_set_timeout,
++	.get_timeleft	= omnia_wdt_get_timeleft,
++};
++
++int omnia_mcu_register_watchdog(struct omnia_mcu *mcu)
++{
++	struct device *dev = &mcu->client->dev;
++	int ret;
++
++	if (!(mcu->features & FEAT_WDT_PING))
++		return 0;
++
++	mcu->wdt.info = &omnia_wdt_info;
++	mcu->wdt.ops = &omnia_wdt_ops;
++	mcu->wdt.parent = dev;
++	mcu->wdt.min_timeout = 1;
++	mcu->wdt.max_timeout = 6553; /* 65535 deciseconds */
++
++	mcu->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&mcu->wdt, timeout, dev);
++
++	watchdog_set_drvdata(&mcu->wdt, mcu);
++
++	omnia_wdt_set_timeout(&mcu->wdt, mcu->wdt.timeout);
++
++	ret = omnia_cmd_read_u8(mcu->client, CMD_GET_WATCHDOG_STATE);
++	if (ret < 0)
++		return dev_err_probe(dev, ret,
++				     "Cannot get MCU watchdog state\n");
++
++	if (ret)
++		set_bit(WDOG_HW_RUNNING, &mcu->wdt.status);
++
++	watchdog_set_nowayout(&mcu->wdt, nowayout);
++	watchdog_stop_on_reboot(&mcu->wdt);
++	ret = devm_watchdog_register_device(dev, &mcu->wdt);
++	if (ret)
++		return dev_err_probe(dev, ret,
++				     "Cannot register MCU watchdog\n");
++
++	return 0;
++}
+diff --git a/drivers/platform/cznic/turris-omnia-mcu.h b/drivers/platform/cznic/turris-omnia-mcu.h
+index d7f0c9e84e36..ad4635a36f99 100644
+--- a/drivers/platform/cznic/turris-omnia-mcu.h
++++ b/drivers/platform/cznic/turris-omnia-mcu.h
+@@ -15,6 +15,7 @@
+ #include <linux/notifier.h>
+ #include <linux/rtc.h>
+ #include <linux/types.h>
++#include <linux/watchdog.h>
+ #include <linux/workqueue.h>
+ #include <asm/byteorder.h>
+ #include <asm/unaligned.h>
+@@ -40,6 +41,9 @@ struct omnia_mcu {
+ 	bool front_button_poweron;
+ 	struct notifier_block restart_nb;
+ 	void (*prev_pm_power_off)(void);
++
++	/* MCU watchdog */
++	struct watchdog_device wdt;
+ };
+ 
+ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+@@ -52,6 +56,25 @@ static inline int omnia_cmd_write(const struct i2c_client *client, void *cmd,
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++static inline int omnia_cmd_write_u8(const struct i2c_client *client, u8 cmd,
++				     u8 val)
++{
++	u8 buf[2] = { cmd, val };
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
++static inline int omnia_cmd_write_u16(const struct i2c_client *client, u8 cmd,
++				      u16 val)
++{
++	u8 buf[3];
++
++	buf[0] = cmd;
++	put_unaligned_le16(val, &buf[1]);
++
++	return omnia_cmd_write(client, buf, sizeof(buf));
++}
++
+ static inline int omnia_cmd_write_u32(const struct i2c_client *client, u8 cmd,
+ 				      u32 val)
+ {
+@@ -146,5 +169,6 @@ int omnia_mcu_register_gpiochip(struct omnia_mcu *mcu);
+ void omnia_mcu_unregister_gpiochip(struct omnia_mcu *mcu);
+ int omnia_mcu_register_sys_off_and_wakeup(struct omnia_mcu *mcu);
+ void omnia_mcu_unregister_sys_off_and_wakeup(struct omnia_mcu *mcu);
++int omnia_mcu_register_watchdog(struct omnia_mcu *mcu);
+ 
+ #endif /* __TURRIS_OMNIA_MCU_H */
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-6-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch b/target/linux/mvebu/patches-5.15/103-v6.7-6-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
new file mode 100644
index 0000000000..a5dc650f7b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-6-ARM-dts-turris-omnia-Add-MCU-system-controller-node.patch
@@ -0,0 +1,60 @@
+From 6021be3e190392bf25de436b553fbb2c956266c2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Tue, 8 Aug 2023 14:27:21 +0200
+Subject: [PATCH 14/17] ARM: dts: turris-omnia: Add MCU system-controller node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Turris Omnia's MCU provides various features that can be configured over
+I2C at address 0x2a. Add device-tree node.
+
+Fixes: 26ca8b52d6e1 ("ARM: dts: add support for Turris Omnia")
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dts | 22 ++++++++++++++++++-
+ 1 file changed, 21 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+index 764cda6c324f..657c86a6069e 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+@@ -187,7 +187,22 @@ i2c@0 {
+ 			#size-cells = <0>;
+ 			reg = <0>;
+ 
+-			/* STM32F0 command interface at address 0x2a */
++			mcu: system-controller@2a {
++				compatible = "cznic,turris-omnia-ctrl";
++				reg = <0x2a>;
++
++				pinctrl-names = "default";
++				pinctrl-0 = <&mcu_pins>;
++
++				interrupt-parent = <&gpio1>;
++				interrupts = <11 IRQ_TYPE_NONE>;
++
++				gpio-controller;
++				#gpio-cells = <2>;
++
++				interrupt-controller;
++				#interrupt-cells = <2>;
++			};
+ 
+ 			led-controller@2b {
+ 				compatible = "cznic,turris-omnia-leds";
+@@ -469,6 +484,11 @@ fixed-link {
+ };
+ 
+ &pinctrl {
++	mcu_pins: mcu-pins {
++		marvell,pins = "mpp43";
++		marvell,function = "gpio";
++	};
++
+ 	pcawan_pins: pcawan-pins {
+ 		marvell,pins = "mpp46";
+ 		marvell,function = "gpio";
+-- 
+2.41.0
+
diff --git a/target/linux/mvebu/patches-5.15/103-v6.7-7-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch b/target/linux/mvebu/patches-5.15/103-v6.7-7-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch
new file mode 100644
index 0000000000..e3ee7e0598
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/103-v6.7-7-ARM-dts-turris-omnia-Add-GPIO-key-node-for-front-but.patch
@@ -0,0 +1,45 @@
+From fb05d6e709894abf1f9c1ad0ce38635d56847e59 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 23 Aug 2023 16:33:42 +0200
+Subject: [PATCH 15/17] ARM: dts: turris-omnia: Add GPIO key node for front
+ button
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now that we have the MCU device-tree node, which acts as a GPIO
+controller, add GPIO key node for the front button.
+
+Fixes: 26ca8b52d6e1 ("ARM: dts: add support for Turris Omnia")
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dts | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+index 657c86a6069e..60b6923d79ec 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+@@ -108,6 +108,19 @@ sfp: sfp {
+ 		 */
+ 		status = "disabled";
+ 	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		front-button {
++			label = "Front Button";
++			linux,code = <KEY_VENDOR>;
++			linux,can-disable;
++			gpios = <&mcu 12 GPIO_ACTIVE_HIGH>;
++			/* debouncing is done by the microcontroller */
++			debounce-interval = <0>;
++		};
++	};
+ };
+ 
+ &bm {
+-- 
+2.41.0
+
-- 
2.41.0

