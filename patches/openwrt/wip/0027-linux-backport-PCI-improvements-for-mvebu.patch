From 9bb3c47911541dbc4ccd58e28260274eb0f4ab01 Mon Sep 17 00:00:00 2001
From: Josef Schlehofer <pepe.schlehofer@gmail.com>
Date: Wed, 24 Aug 2022 14:14:44 +0200
Subject: [PATCH] linux: backport PCI improvements for mvebu

---
 ...e-pci_ioremap_io-usage-by-devm_pci_r.patch |  62 +++
 ...-custom-mvebu_pci_host_probe-functio.patch |  82 ++++
 ...ace-pci_ioremap_io-usage-by-pci_rema.patch | 170 +++++++
 ...ve-unused-ARM-specific-function-pci_.patch |  55 +++
 ...xport-symbols-for-public-API-window-.patch |  63 +++
 ...pport-for-compiling-driver-as-module.patch | 175 +++++++
 ...0007-PCI-mvebu-Check-for-valid-ports.patch |  54 +++
 ...that-PCI-bridge-specified-in-DT-has-.patch |  38 ++
 ...-invalid-size-of-read-config-request.patch |  35 ++
 ...ow-mapping-interrupts-on-emulated-br.patch |  51 ++
 ...ate-errors-when-updating-PCI_IO_BASE.patch | 195 ++++++++
 ...-PCI-Bridge-Class-Code-to-PCI-Bridge.patch |  73 +++
 ...Pali-Roh-r-as-pci-mvebu.c-maintainer.patch |  30 ++
 ...mul-Make-struct-pci_bridge_emul_ops-.patch |  61 +++
 ...mul-Rename-PCI_BRIDGE_EMUL_NO_PREFET.patch |  69 +++
 ...mul-Add-support-for-new-flag-PCI_BRI.patch |  62 +++
 ...lp-string-for-CONFIG_PCI_MVEBU-optio.patch |  34 ++
 ...u-Remove-duplicate-nports-assignment.patch |  33 ++
 ...I_BRIDGE_EMUL_NO_IO_FORWARD-when-IO-.patch | 114 +++++
 ...ly-initialize-vendor-device-and-revi.patch |  42 ++
 ...-comment-for-PCI_EXP_LNKCAP-register.patch |  34 ++
 ...-comment-for-PCI_EXP_LNKCTL-register.patch |  39 ++
 ...porting-Data-Link-Layer-Link-Active-.patch |  50 ++
 ...ridge-emul-Re-arrange-register-tests.patch | 117 +++++
 ...mul-Add-support-for-PCIe-extended-ca.patch | 179 +++++++
 ...mul-Add-support-for-PCI-Bridge-Subsy.patch | 169 +++++++
 ...ngs-PCI-mvebu-Add-num-lanes-property.patch | 114 +++++
 ...mvebu-Correctly-configure-x1-x4-mode.patch |  78 ++++
 ...pport-for-PCI-Bridge-Subsystem-Vendo.patch |  53 +++
 ...pport-for-Advanced-Error-Reporting-r.patch | 125 +++++
 .../0031-PCI-mvebu-Use-child_ops-API.patch    | 165 +++++++
 ...mvebu-Update-information-about-intx-.patch |  34 ++
 ...cro-names-and-comments-about-legacy-.patch |  79 ++++
 ...ent-support-for-legacy-INTx-interrup.patch | 251 ++++++++++
 ...-Add-definitions-for-PCIe-legacy-INT.patch | 161 +++++++
 ...-definitions-for-PCIe-legacy-INTx-in.patch |  63 +++
 ...70.dtsi-Add-definitions-for-PCIe-leg.patch |  79 ++++
 ...p-98dx3236.dtsi-Add-definitions-for-.patch |  50 ++
 ...p-mv78230.dtsi-Add-definitions-for-P.patch | 166 +++++++
 ...p-mv78260.dtsi-Add-definitions-for-P.patch | 282 +++++++++++
 ...p-mv78460.dtsi-Add-definitions-for-P.patch | 311 +++++++++++++
 ...75.dtsi-Add-definitions-for-PCIe-leg.patch |  79 ++++
 ...80.dtsi-Add-definitions-for-PCIe-leg.patch | 108 +++++
 ...85.dtsi-Add-definitions-for-PCIe-leg.patch | 138 ++++++
 ...9x.dtsi-Add-definitions-for-PCIe-leg.patch | 137 ++++++
 ...dd-PCI_EXP_SLTCTL_ASPL_DISABLE-macro.patch |  33 ++
 ...slot-power-limit-milliwatt-PCIe-port.patch |  46 ++
 ...-for-parsing-slot-power-limit-milliw.patch | 135 ++++++
 ...pport-for-sending-Set_Slot_Power_Lim.patch | 210 +++++++++
 ...mnia-Set-PCIe-slot-power-limit-milli.patch |  43 ++
 ...mul-Set-position-of-PCI-capabilities.patch | 164 +++++++
 ...70-xp-Do-not-allow-mapping-IRQ-0-and.patch |  37 ++
 ...vm_request_irq-for-registering-inter.patch |  99 ++++
 ...e-INTx-irqs-prior-to-removing-INTx-d.patch |  47 ++
 ...5-PCI-Assign-PCI-domain-by-ida_alloc.patch | 215 +++++++++
 ...dianity-when-accessing-pci-emul-brid.patch |  68 +++
 ...-assigned-addresses-for-every-PCIe-R.patch |  35 ++
 ...70-Fix-assigned-addresses-for-every-.patch |  35 ++
 ...p-Fix-assigned-addresses-for-every-P.patch | 141 ++++++
 ...75-Fix-assigned-addresses-for-every-.patch |  35 ++
 ...8x-Fix-assigned-addresses-for-every-.patch |  76 +++
 ...9x-Fix-assigned-addresses-for-every-.patch |  53 +++
 ...70-xp-Do-not-call-ipi_resume-when-IP.patch |  49 ++
 ...70-xp-Fix-comment-about-unmasking-mp.patch |  35 ++
 ...70-xp-Do-not-touch-IPI-registers-on-.patch |  67 +++
 ...70-xp-Add-support-for-32-MSI-interru.patch | 181 ++++++++
 ...mvebu-Update-information-about-error.patch |  32 ++
 ...ent-support-for-interrupts-on-emulat.patch | 437 ++++++++++++++++++
 ...-Add-definitions-for-PCIe-error-inte.patch |  94 ++++
 ...-definitions-for-PCIe-error-interrup.patch |  46 ++
 ...hip-armada-370-xp-Update-information.patch |  42 ++
 ...70-xp-Implement-SoC-Error-interrupts.patch | 348 ++++++++++++++
 ...70-xp.dtsi-Add-node-for-MPIC-SoC-Err.patch |  33 ++
 ...75.dtsi-Add-node-for-MPIC-SoC-Error-.patch |  33 ++
 ...8x.dtsi-Add-node-for-MPIC-SoC-Error-.patch |  35 ++
 ...9x.dtsi-Add-node-for-MPIC-SoC-Error-.patch |  33 ++
 ...70.dtsi-Add-definitions-for-PCIe-err.patch |  43 ++
 ...p-mv78230.dtsi-Add-definitions-for-P.patch |  79 ++++
 ...p-mv78260.dtsi-Add-definitions-for-P.patch | 124 +++++
 ...p-mv78460.dtsi-Add-definitions-for-P.patch | 136 ++++++
 ...p-98dx3236.dtsi-Add-definitions-for-.patch |  32 ++
 ...75.dtsi-Add-definitions-for-PCIe-err.patch |  43 ++
 ...80.dtsi-Add-definitions-for-PCIe-err.patch |  57 +++
 ...85.dtsi-Add-definitions-for-PCIe-err.patch |  71 +++
 ...9x.dtsi-Add-definitions-for-PCIe-err.patch |  69 +++
 ...le-DLLSC-interrupt-only-if-supported.patch | 139 ++++++
 ...e-Command-Completed-Interrupt-only-i.patch |  38 ++
 ...pport-for-PCI_EXP_SLTSTA_DLLSC-via-h.patch | 297 ++++++++++++
 ...T-and-GENMASK-macros-instead-of-hard.patch |  47 ++
 ...nsistency-add-_OFF-suffix-to-all-reg.patch | 167 +++++++
 90 files changed, 8838 insertions(+)
 create mode 100644 target/linux/generic/pending-5.15/0001-PCI-mvebu-Replace-pci_ioremap_io-usage-by-devm_pci_r.patch
 create mode 100644 target/linux/generic/pending-5.15/0002-PCI-mvebu-Remove-custom-mvebu_pci_host_probe-functio.patch
 create mode 100644 target/linux/generic/pending-5.15/0003-arm-ioremap-Replace-pci_ioremap_io-usage-by-pci_rema.patch
 create mode 100644 target/linux/generic/pending-5.15/0004-arm-ioremap-Remove-unused-ARM-specific-function-pci_.patch
 create mode 100644 target/linux/generic/pending-5.15/0005-bus-mvebu-mbus-Export-symbols-for-public-API-window-.patch
 create mode 100644 target/linux/generic/pending-5.15/0006-PCI-mvebu-Add-support-for-compiling-driver-as-module.patch
 create mode 100644 target/linux/generic/pending-5.15/0007-PCI-mvebu-Check-for-valid-ports.patch
 create mode 100644 target/linux/generic/pending-5.15/0008-PCI-mvebu-Check-that-PCI-bridge-specified-in-DT-has-.patch
 create mode 100644 target/linux/generic/pending-5.15/0009-PCI-mvebu-Handle-invalid-size-of-read-config-request.patch
 create mode 100644 target/linux/generic/pending-5.15/0010-PCI-mvebu-Disallow-mapping-interrupts-on-emulated-br.patch
 create mode 100644 target/linux/generic/pending-5.15/0011-PCI-mvebu-Propagate-errors-when-updating-PCI_IO_BASE.patch
 create mode 100644 target/linux/generic/pending-5.15/0012-PCI-mvebu-Set-PCI-Bridge-Class-Code-to-PCI-Bridge.patch
 create mode 100644 target/linux/generic/pending-5.15/0013-MAINTAINERS-Add-Pali-Roh-r-as-pci-mvebu.c-maintainer.patch
 create mode 100644 target/linux/generic/pending-5.15/0014-PCI-pci-bridge-emul-Make-struct-pci_bridge_emul_ops-.patch
 create mode 100644 target/linux/generic/pending-5.15/0015-PCI-pci-bridge-emul-Rename-PCI_BRIDGE_EMUL_NO_PREFET.patch
 create mode 100644 target/linux/generic/pending-5.15/0016-PCI-pci-bridge-emul-Add-support-for-new-flag-PCI_BRI.patch
 create mode 100644 target/linux/generic/pending-5.15/0017-PCI-mvebu-Add-help-string-for-CONFIG_PCI_MVEBU-optio.patch
 create mode 100644 target/linux/generic/pending-5.15/0018-PCI-mvebu-Remove-duplicate-nports-assignment.patch
 create mode 100644 target/linux/generic/pending-5.15/0019-PCI-mvebu-Set-PCI_BRIDGE_EMUL_NO_IO_FORWARD-when-IO-.patch
 create mode 100644 target/linux/generic/pending-5.15/0020-PCI-mvebu-Properly-initialize-vendor-device-and-revi.patch
 create mode 100644 target/linux/generic/pending-5.15/0021-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCAP-register.patch
 create mode 100644 target/linux/generic/pending-5.15/0022-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCTL-register.patch
 create mode 100644 target/linux/generic/pending-5.15/0023-PCI-mvebu-Fix-reporting-Data-Link-Layer-Link-Active-.patch
 create mode 100644 target/linux/generic/pending-5.15/0024-PCI-pci-bridge-emul-Re-arrange-register-tests.patch
 create mode 100644 target/linux/generic/pending-5.15/0025-PCI-pci-bridge-emul-Add-support-for-PCIe-extended-ca.patch
 create mode 100644 target/linux/generic/pending-5.15/0026-PCI-pci-bridge-emul-Add-support-for-PCI-Bridge-Subsy.patch
 create mode 100644 target/linux/generic/pending-5.15/0027-dt-bindings-PCI-mvebu-Add-num-lanes-property.patch
 create mode 100644 target/linux/generic/pending-5.15/0028-PCI-mvebu-Correctly-configure-x1-x4-mode.patch
 create mode 100644 target/linux/generic/pending-5.15/0029-PCI-mvebu-Add-support-for-PCI-Bridge-Subsystem-Vendo.patch
 create mode 100644 target/linux/generic/pending-5.15/0030-PCI-mvebu-Add-support-for-Advanced-Error-Reporting-r.patch
 create mode 100644 target/linux/generic/pending-5.15/0031-PCI-mvebu-Use-child_ops-API.patch
 create mode 100644 target/linux/generic/pending-5.15/0032-dt-bindings-PCI-mvebu-Update-information-about-intx-.patch
 create mode 100644 target/linux/generic/pending-5.15/0033-PCI-mvebu-Fix-macro-names-and-comments-about-legacy-.patch
 create mode 100644 target/linux/generic/pending-5.15/0034-PCI-mvebu-Implement-support-for-legacy-INTx-interrup.patch
 create mode 100644 target/linux/generic/pending-5.15/0035-ARM-dts-kirkwood-Add-definitions-for-PCIe-legacy-INT.patch
 create mode 100644 target/linux/generic/pending-5.15/0036-ARM-dts-dove-Add-definitions-for-PCIe-legacy-INTx-in.patch
 create mode 100644 target/linux/generic/pending-5.15/0037-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-leg.patch
 create mode 100644 target/linux/generic/pending-5.15/0038-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
 create mode 100644 target/linux/generic/pending-5.15/0039-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0040-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0041-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0042-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-leg.patch
 create mode 100644 target/linux/generic/pending-5.15/0043-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-leg.patch
 create mode 100644 target/linux/generic/pending-5.15/0044-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-leg.patch
 create mode 100644 target/linux/generic/pending-5.15/0045-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-leg.patch
 create mode 100644 target/linux/generic/pending-5.15/0046-PCI-Add-PCI_EXP_SLTCTL_ASPL_DISABLE-macro.patch
 create mode 100644 target/linux/generic/pending-5.15/0047-dt-bindings-Add-slot-power-limit-milliwatt-PCIe-port.patch
 create mode 100644 target/linux/generic/pending-5.15/0048-PCI-Add-function-for-parsing-slot-power-limit-milliw.patch
 create mode 100644 target/linux/generic/pending-5.15/0049-PCI-mvebu-Add-support-for-sending-Set_Slot_Power_Lim.patch
 create mode 100644 target/linux/generic/pending-5.15/0050-ARM-dts-turris-omnia-Set-PCIe-slot-power-limit-milli.patch
 create mode 100644 target/linux/generic/pending-5.15/0051-PCI-pci-bridge-emul-Set-position-of-PCI-capabilities.patch
 create mode 100644 target/linux/generic/pending-5.15/0053-PCI-mvebu-Use-devm_request_irq-for-registering-inter.patch
 create mode 100644 target/linux/generic/pending-5.15/0054-PCI-mvebu-Dispose-INTx-irqs-prior-to-removing-INTx-d.patch
 create mode 100644 target/linux/generic/pending-5.15/0055-PCI-Assign-PCI-domain-by-ida_alloc.patch
 create mode 100644 target/linux/generic/pending-5.15/0056-PCI-mvebu-Fix-endianity-when-accessing-pci-emul-brid.patch
 create mode 100644 target/linux/generic/pending-5.15/0057-ARM-dts-dove-Fix-assigned-addresses-for-every-PCIe-R.patch
 create mode 100644 target/linux/generic/pending-5.15/0058-ARM-dts-armada-370-Fix-assigned-addresses-for-every-.patch
 create mode 100644 target/linux/generic/pending-5.15/0059-ARM-dts-armada-xp-Fix-assigned-addresses-for-every-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0060-ARM-dts-armada-375-Fix-assigned-addresses-for-every-.patch
 create mode 100644 target/linux/generic/pending-5.15/0061-ARM-dts-armada-38x-Fix-assigned-addresses-for-every-.patch
 create mode 100644 target/linux/generic/pending-5.15/0062-ARM-dts-armada-39x-Fix-assigned-addresses-for-every-.patch
 create mode 100644 target/linux/generic/pending-5.15/0063-irqchip-armada-370-xp-Do-not-call-ipi_resume-when-IP.patch
 create mode 100644 target/linux/generic/pending-5.15/0064-irqchip-armada-370-xp-Fix-comment-about-unmasking-mp.patch
 create mode 100644 target/linux/generic/pending-5.15/0065-irqchip-armada-370-xp-Do-not-touch-IPI-registers-on-.patch
 create mode 100644 target/linux/generic/pending-5.15/0066-irqchip-armada-370-xp-Add-support-for-32-MSI-interru.patch
 create mode 100644 target/linux/generic/pending-5.15/0067-dt-bindings-PCI-mvebu-Update-information-about-error.patch
 create mode 100644 target/linux/generic/pending-5.15/0068-PCI-mvebu-Implement-support-for-interrupts-on-emulat.patch
 create mode 100644 target/linux/generic/pending-5.15/0069-ARM-dts-kirkwood-Add-definitions-for-PCIe-error-inte.patch
 create mode 100644 target/linux/generic/pending-5.15/0070-ARM-dts-dove-Add-definitions-for-PCIe-error-interrup.patch
 create mode 100644 target/linux/generic/pending-5.15/0071-dt-bindings-irqchip-armada-370-xp-Update-information.patch
 create mode 100644 target/linux/generic/pending-5.15/0072-irqchip-armada-370-xp-Implement-SoC-Error-interrupts.patch
 create mode 100644 target/linux/generic/pending-5.15/0073-ARM-dts-armada-370-xp.dtsi-Add-node-for-MPIC-SoC-Err.patch
 create mode 100644 target/linux/generic/pending-5.15/0074-ARM-dts-armada-375.dtsi-Add-node-for-MPIC-SoC-Error-.patch
 create mode 100644 target/linux/generic/pending-5.15/0075-ARM-dts-armada-38x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
 create mode 100644 target/linux/generic/pending-5.15/0076-ARM-dts-armada-39x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
 create mode 100644 target/linux/generic/pending-5.15/0077-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-err.patch
 create mode 100644 target/linux/generic/pending-5.15/0078-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0079-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0080-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
 create mode 100644 target/linux/generic/pending-5.15/0081-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
 create mode 100644 target/linux/generic/pending-5.15/0082-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-err.patch
 create mode 100644 target/linux/generic/pending-5.15/0083-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-err.patch
 create mode 100644 target/linux/generic/pending-5.15/0084-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-err.patch
 create mode 100644 target/linux/generic/pending-5.15/0085-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-err.patch
 create mode 100644 target/linux/generic/pending-5.15/0086-PCI-pciehp-Enable-DLLSC-interrupt-only-if-supported.patch
 create mode 100644 target/linux/generic/pending-5.15/0087-PCI-pciehp-Enable-Command-Completed-Interrupt-only-i.patch
 create mode 100644 target/linux/generic/pending-5.15/0088-PCI-mvebu-Add-support-for-PCI_EXP_SLTSTA_DLLSC-via-h.patch
 create mode 100644 target/linux/generic/pending-5.15/0089-PCI-mvebu-use-BIT-and-GENMASK-macros-instead-of-hard.patch
 create mode 100644 target/linux/generic/pending-5.15/0090-PCI-mvebu-For-consistency-add-_OFF-suffix-to-all-reg.patch

diff --git a/target/linux/generic/pending-5.15/0001-PCI-mvebu-Replace-pci_ioremap_io-usage-by-devm_pci_r.patch b/target/linux/generic/pending-5.15/0001-PCI-mvebu-Replace-pci_ioremap_io-usage-by-devm_pci_r.patch
new file mode 100644
index 0000000000..abe0360ab6
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0001-PCI-mvebu-Replace-pci_ioremap_io-usage-by-devm_pci_r.patch
@@ -0,0 +1,62 @@
+From 42b54ca7612af1051a744abf00fdd5a04bccb627 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 23 Nov 2021 12:22:59 +0100
+Subject: [PATCH 01/90] PCI: mvebu: Replace pci_ioremap_io() usage by
+ devm_pci_remap_iospace()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now when ARM architecture code also provides standard PCI core function
+pci_remap_iospace(), use its devm_pci_remap_iospace() variant in
+pci-mvebu.c driver instead of old ARM-specific pci_ioremap_io() function.
+
+Call devm_pci_remap_iospace() before adding IO resource to host bridge
+structure, at the place where it should be.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 13 ++++---------
+ 1 file changed, 4 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 2a3bf82aa4e2..12661311853b 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -1082,6 +1082,10 @@ static int mvebu_pcie_parse_request_resources(struct mvebu_pcie *pcie)
+ 					 resource_size(&pcie->io) - 1);
+ 		pcie->realio.name = "PCI I/O";
+ 
++		ret = devm_pci_remap_iospace(dev, &pcie->realio, pcie->io.start);
++		if (ret)
++			return ret;
++
+ 		pci_add_resource(&bridge->windows, &pcie->realio);
+ 		ret = devm_request_resource(dev, &ioport_resource, &pcie->realio);
+ 		if (ret)
+@@ -1100,7 +1104,6 @@ static int mvebu_pcie_parse_request_resources(struct mvebu_pcie *pcie)
+  */
+ static int mvebu_pci_host_probe(struct pci_host_bridge *bridge)
+ {
+-	struct mvebu_pcie *pcie;
+ 	struct pci_bus *bus, *child;
+ 	int ret;
+ 
+@@ -1110,14 +1113,6 @@ static int mvebu_pci_host_probe(struct pci_host_bridge *bridge)
+ 		return ret;
+ 	}
+ 
+-	pcie = pci_host_bridge_priv(bridge);
+-	if (resource_size(&pcie->io) != 0) {
+-		unsigned int i;
+-
+-		for (i = 0; i < resource_size(&pcie->realio); i += SZ_64K)
+-			pci_ioremap_io(i, pcie->io.start + i);
+-	}
+-
+ 	bus = bridge->bus;
+ 
+ 	/*
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0002-PCI-mvebu-Remove-custom-mvebu_pci_host_probe-functio.patch b/target/linux/generic/pending-5.15/0002-PCI-mvebu-Remove-custom-mvebu_pci_host_probe-functio.patch
new file mode 100644
index 0000000000..ea40f97d77
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0002-PCI-mvebu-Remove-custom-mvebu_pci_host_probe-functio.patch
@@ -0,0 +1,82 @@
+From 74c5cf43b5e5de7832075264762c9ea85ef06b0a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 20:19:52 +0100
+Subject: [PATCH 02/90] PCI: mvebu: Remove custom mvebu_pci_host_probe()
+ function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now after pci_ioremap_io() usage was replaced by devm_pci_remap_iospace()
+function, there is no need to use custom mvebu_pci_host_probe() function.
+Current implementation of mvebu_pci_host_probe() is same as standard PCI
+core functionn pci_host_probe(). So replace mvebu_pci_host_probe() call by
+pci_host_probe() and remove custom mvebu_pci_host_probe() function.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 41 +-----------------------------
+ 1 file changed, 1 insertion(+), 40 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 12661311853b..9cbf10d6fc30 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -1095,45 +1095,6 @@ static int mvebu_pcie_parse_request_resources(struct mvebu_pcie *pcie)
+ 	return 0;
+ }
+ 
+-/*
+- * This is a copy of pci_host_probe(), except that it does the I/O
+- * remap as the last step, once we are sure we won't fail.
+- *
+- * It should be removed once the I/O remap error handling issue has
+- * been sorted out.
+- */
+-static int mvebu_pci_host_probe(struct pci_host_bridge *bridge)
+-{
+-	struct pci_bus *bus, *child;
+-	int ret;
+-
+-	ret = pci_scan_root_bus_bridge(bridge);
+-	if (ret < 0) {
+-		dev_err(bridge->dev.parent, "Scanning root bridge failed");
+-		return ret;
+-	}
+-
+-	bus = bridge->bus;
+-
+-	/*
+-	 * We insert PCI resources into the iomem_resource and
+-	 * ioport_resource trees in either pci_bus_claim_resources()
+-	 * or pci_bus_assign_resources().
+-	 */
+-	if (pci_has_flag(PCI_PROBE_ONLY)) {
+-		pci_bus_claim_resources(bus);
+-	} else {
+-		pci_bus_size_bridges(bus);
+-		pci_bus_assign_resources(bus);
+-
+-		list_for_each_entry(child, &bus->children, node)
+-			pcie_bus_configure_settings(child);
+-	}
+-
+-	pci_bus_add_devices(bus);
+-	return 0;
+-}
+-
+ static int mvebu_pcie_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+@@ -1293,7 +1254,7 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 	bridge->ops = &mvebu_pcie_ops;
+ 	bridge->align_resource = mvebu_pcie_align_resource;
+ 
+-	return mvebu_pci_host_probe(bridge);
++	return pci_host_probe(bridge);
+ }
+ 
+ static const struct of_device_id mvebu_pcie_of_match_table[] = {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0003-arm-ioremap-Replace-pci_ioremap_io-usage-by-pci_rema.patch b/target/linux/generic/pending-5.15/0003-arm-ioremap-Replace-pci_ioremap_io-usage-by-pci_rema.patch
new file mode 100644
index 0000000000..eb1d636b2a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0003-arm-ioremap-Replace-pci_ioremap_io-usage-by-pci_rema.patch
@@ -0,0 +1,170 @@
+From f7b0b5aa413f2a38083e4155baf211117121674c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 23 Nov 2021 12:05:54 +0100
+Subject: [PATCH 03/90] arm: ioremap: Replace pci_ioremap_io() usage by
+ pci_remap_iospace()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Replace all usage of ARM specific pci_ioremap_io() function by standard PCI
+core API function pci_remap_iospace() in all drivers and arm march code.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/mach-dove/pcie.c    |  9 +++++----
+ arch/arm/mach-iop32x/pci.c   |  5 ++++-
+ arch/arm/mach-mv78xx0/pcie.c |  5 ++++-
+ arch/arm/mach-orion5x/pci.c  | 10 ++++++++--
+ drivers/pcmcia/at91_cf.c     |  6 +++++-
+ 5 files changed, 26 insertions(+), 9 deletions(-)
+
+diff --git a/arch/arm/mach-dove/pcie.c b/arch/arm/mach-dove/pcie.c
+index ee91ac6b5ebf..2a493bdfffc6 100644
+--- a/arch/arm/mach-dove/pcie.c
++++ b/arch/arm/mach-dove/pcie.c
+@@ -38,6 +38,7 @@ static int num_pcie_ports;
+ static int __init dove_pcie_setup(int nr, struct pci_sys_data *sys)
+ {
+ 	struct pcie_port *pp;
++	struct resource realio;
+ 
+ 	if (nr >= num_pcie_ports)
+ 		return 0;
+@@ -53,10 +54,10 @@ static int __init dove_pcie_setup(int nr, struct pci_sys_data *sys)
+ 
+ 	orion_pcie_setup(pp->base);
+ 
+-	if (pp->index == 0)
+-		pci_ioremap_io(sys->busnr * SZ_64K, DOVE_PCIE0_IO_PHYS_BASE);
+-	else
+-		pci_ioremap_io(sys->busnr * SZ_64K, DOVE_PCIE1_IO_PHYS_BASE);
++	realio.start = sys->busnr * SZ_64K;
++	realio.end = realio.start + SZ_64K - 1;
++	pci_remap_iospace(&realio, pp->index == 0 ? DOVE_PCIE0_IO_PHYS_BASE :
++						    DOVE_PCIE1_IO_PHYS_BASE);
+ 
+ 	/*
+ 	 * IORESOURCE_MEM
+diff --git a/arch/arm/mach-iop32x/pci.c b/arch/arm/mach-iop32x/pci.c
+index ab0010dc3145..7a215d2ee7e2 100644
+--- a/arch/arm/mach-iop32x/pci.c
++++ b/arch/arm/mach-iop32x/pci.c
+@@ -185,6 +185,7 @@ iop3xx_pci_abort(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+ int iop3xx_pci_setup(int nr, struct pci_sys_data *sys)
+ {
+ 	struct resource *res;
++	struct resource realio;
+ 
+ 	if (nr != 0)
+ 		return 0;
+@@ -206,7 +207,9 @@ int iop3xx_pci_setup(int nr, struct pci_sys_data *sys)
+ 
+ 	pci_add_resource_offset(&sys->resources, res, sys->mem_offset);
+ 
+-	pci_ioremap_io(0, IOP3XX_PCI_LOWER_IO_PA);
++	realio.start = 0;
++	realio.end = realio.start + SZ_64K - 1;
++	pci_remap_iospace(&realio, IOP3XX_PCI_LOWER_IO_PA);
+ 
+ 	return 1;
+ }
+diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
+index 636d84b40466..e15646af7f26 100644
+--- a/arch/arm/mach-mv78xx0/pcie.c
++++ b/arch/arm/mach-mv78xx0/pcie.c
+@@ -101,6 +101,7 @@ static void __init mv78xx0_pcie_preinit(void)
+ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
+ {
+ 	struct pcie_port *pp;
++	struct resource realio;
+ 
+ 	if (nr >= num_pcie_ports)
+ 		return 0;
+@@ -115,7 +116,9 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
+ 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
+ 	orion_pcie_setup(pp->base);
+ 
+-	pci_ioremap_io(nr * SZ_64K, MV78XX0_PCIE_IO_PHYS_BASE(nr));
++	realio.start = nr * SZ_64K;
++	realio.end = realio.start + SZ_64K - 1;
++	pci_remap_iospace(&realio, MV78XX0_PCIE_IO_PHYS_BASE(nr));
+ 
+ 	pci_add_resource_offset(&sys->resources, &pp->res, sys->mem_offset);
+ 
+diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
+index 76951bfbacf5..92e938bba20d 100644
+--- a/arch/arm/mach-orion5x/pci.c
++++ b/arch/arm/mach-orion5x/pci.c
+@@ -142,6 +142,7 @@ static struct pci_ops pcie_ops = {
+ static int __init pcie_setup(struct pci_sys_data *sys)
+ {
+ 	struct resource *res;
++	struct resource realio;
+ 	int dev;
+ 
+ 	/*
+@@ -164,7 +165,9 @@ static int __init pcie_setup(struct pci_sys_data *sys)
+ 		pcie_ops.read = pcie_rd_conf_wa;
+ 	}
+ 
+-	pci_ioremap_io(sys->busnr * SZ_64K, ORION5X_PCIE_IO_PHYS_BASE);
++	realio.start = sys->busnr * SZ_64K;
++	realio.end = realio.start + SZ_64K - 1;
++	pci_remap_iospace(&realio, ORION5X_PCIE_IO_PHYS_BASE);
+ 
+ 	/*
+ 	 * Request resources.
+@@ -466,6 +469,7 @@ static void __init orion5x_setup_pci_wins(void)
+ static int __init pci_setup(struct pci_sys_data *sys)
+ {
+ 	struct resource *res;
++	struct resource realio;
+ 
+ 	/*
+ 	 * Point PCI unit MBUS decode windows to DRAM space.
+@@ -482,7 +486,9 @@ static int __init pci_setup(struct pci_sys_data *sys)
+ 	 */
+ 	orion5x_setbits(PCI_CMD, PCI_CMD_HOST_REORDER);
+ 
+-	pci_ioremap_io(sys->busnr * SZ_64K, ORION5X_PCI_IO_PHYS_BASE);
++	realio.start = sys->busnr * SZ_64K;
++	realio.end = realio.start + SZ_64K - 1;
++	pci_remap_iospace(&realio, ORION5X_PCI_IO_PHYS_BASE);
+ 
+ 	/*
+ 	 * Request resources
+diff --git a/drivers/pcmcia/at91_cf.c b/drivers/pcmcia/at91_cf.c
+index 6b1edfc890a3..92df2c2c5d07 100644
+--- a/drivers/pcmcia/at91_cf.c
++++ b/drivers/pcmcia/at91_cf.c
+@@ -20,6 +20,7 @@
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/of_gpio.h>
++#include <linux/pci.h>
+ #include <linux/regmap.h>
+ 
+ #include <pcmcia/ss.h>
+@@ -230,6 +231,7 @@ static int at91_cf_probe(struct platform_device *pdev)
+ 	struct at91_cf_socket	*cf;
+ 	struct at91_cf_data	*board;
+ 	struct resource		*io;
++	struct resource		realio;
+ 	int			status;
+ 
+ 	board = devm_kzalloc(&pdev->dev, sizeof(*board), GFP_KERNEL);
+@@ -307,7 +309,9 @@ static int at91_cf_probe(struct platform_device *pdev)
+ 	 * io_offset is set to 0x10000 to avoid the check in static_find_io().
+ 	 * */
+ 	cf->socket.io_offset = 0x10000;
+-	status = pci_ioremap_io(0x10000, cf->phys_baseaddr + CF_IO_PHYS);
++	realio.start = cf->socket.io_offset;
++	realio.end = realio.start + SZ_64K - 1;
++	status = pci_remap_iospace(&realio, cf->phys_baseaddr + CF_IO_PHYS);
+ 	if (status)
+ 		goto fail0a;
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0004-arm-ioremap-Remove-unused-ARM-specific-function-pci_.patch b/target/linux/generic/pending-5.15/0004-arm-ioremap-Remove-unused-ARM-specific-function-pci_.patch
new file mode 100644
index 0000000000..78a5b02a76
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0004-arm-ioremap-Remove-unused-ARM-specific-function-pci_.patch
@@ -0,0 +1,55 @@
+From 084358229bf6939d2f5e54e4d3e9aa84bc9240fa Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 23 Nov 2021 12:24:04 +0100
+Subject: [PATCH 04/90] arm: ioremap: Remove unused ARM-specific function
+ pci_ioremap_io()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This function is not used by any driver anymore. So completely remove it.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/include/asm/io.h |  2 --
+ arch/arm/mm/ioremap.c     | 11 -----------
+ 2 files changed, 13 deletions(-)
+
+diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
+index 79d246ac93ab..2d551fa12a34 100644
+--- a/arch/arm/include/asm/io.h
++++ b/arch/arm/include/asm/io.h
+@@ -179,8 +179,6 @@ void pci_ioremap_set_mem_type(int mem_type);
+ static inline void pci_ioremap_set_mem_type(int mem_type) {}
+ #endif
+ 
+-extern int pci_ioremap_io(unsigned int offset, phys_addr_t phys_addr);
+-
+ /*
+  * PCI configuration space mapping function.
+  *
+diff --git a/arch/arm/mm/ioremap.c b/arch/arm/mm/ioremap.c
+index 2660bdfcad4d..0e67162c978d 100644
+--- a/arch/arm/mm/ioremap.c
++++ b/arch/arm/mm/ioremap.c
+@@ -453,17 +453,6 @@ void pci_ioremap_set_mem_type(int mem_type)
+ 	pci_ioremap_mem_type = mem_type;
+ }
+ 
+-int pci_ioremap_io(unsigned int offset, phys_addr_t phys_addr)
+-{
+-	BUG_ON(offset + SZ_64K - 1 > IO_SPACE_LIMIT);
+-
+-	return ioremap_page_range(PCI_IO_VIRT_BASE + offset,
+-				  PCI_IO_VIRT_BASE + offset + SZ_64K,
+-				  phys_addr,
+-				  __pgprot(get_mem_type(pci_ioremap_mem_type)->prot_pte));
+-}
+-EXPORT_SYMBOL_GPL(pci_ioremap_io);
+-
+ void __iomem *pci_remap_cfgspace(resource_size_t res_cookie, size_t size)
+ {
+ 	return arch_ioremap_caller(res_cookie, size, MT_UNCACHED,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0005-bus-mvebu-mbus-Export-symbols-for-public-API-window-.patch b/target/linux/generic/pending-5.15/0005-bus-mvebu-mbus-Export-symbols-for-public-API-window-.patch
new file mode 100644
index 0000000000..87a7e9b43a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0005-bus-mvebu-mbus-Export-symbols-for-public-API-window-.patch
@@ -0,0 +1,63 @@
+From c472757ed4c9b9f3383301842b06f83b1444d743 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 31 Oct 2021 22:50:14 +0100
+Subject: [PATCH 05/90] bus: mvebu-mbus: Export symbols for public API window
+ functions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This would allow to compile pci-mvebu.c driver as module.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/bus/mvebu-mbus.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c
+index ea0424922de7..db612045616f 100644
+--- a/drivers/bus/mvebu-mbus.c
++++ b/drivers/bus/mvebu-mbus.c
+@@ -914,6 +914,7 @@ int mvebu_mbus_add_window_remap_by_id(unsigned int target,
+ 
+ 	return mvebu_mbus_alloc_window(s, base, size, remap, target, attribute);
+ }
++EXPORT_SYMBOL_GPL(mvebu_mbus_add_window_remap_by_id);
+ 
+ int mvebu_mbus_add_window_by_id(unsigned int target, unsigned int attribute,
+ 				phys_addr_t base, size_t size)
+@@ -921,6 +922,7 @@ int mvebu_mbus_add_window_by_id(unsigned int target, unsigned int attribute,
+ 	return mvebu_mbus_add_window_remap_by_id(target, attribute, base,
+ 						 size, MVEBU_MBUS_NO_REMAP);
+ }
++EXPORT_SYMBOL_GPL(mvebu_mbus_add_window_by_id);
+ 
+ int mvebu_mbus_del_window(phys_addr_t base, size_t size)
+ {
+@@ -933,6 +935,7 @@ int mvebu_mbus_del_window(phys_addr_t base, size_t size)
+ 	mvebu_mbus_disable_window(&mbus_state, win);
+ 	return 0;
+ }
++EXPORT_SYMBOL_GPL(mvebu_mbus_del_window);
+ 
+ void mvebu_mbus_get_pcie_mem_aperture(struct resource *res)
+ {
+@@ -940,6 +943,7 @@ void mvebu_mbus_get_pcie_mem_aperture(struct resource *res)
+ 		return;
+ 	*res = mbus_state.pcie_mem_aperture;
+ }
++EXPORT_SYMBOL_GPL(mvebu_mbus_get_pcie_mem_aperture);
+ 
+ void mvebu_mbus_get_pcie_io_aperture(struct resource *res)
+ {
+@@ -947,6 +951,7 @@ void mvebu_mbus_get_pcie_io_aperture(struct resource *res)
+ 		return;
+ 	*res = mbus_state.pcie_io_aperture;
+ }
++EXPORT_SYMBOL_GPL(mvebu_mbus_get_pcie_io_aperture);
+ 
+ int mvebu_mbus_get_dram_win_info(phys_addr_t phyaddr, u8 *target, u8 *attr)
+ {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0006-PCI-mvebu-Add-support-for-compiling-driver-as-module.patch b/target/linux/generic/pending-5.15/0006-PCI-mvebu-Add-support-for-compiling-driver-as-module.patch
new file mode 100644
index 0000000000..2ff5eef811
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0006-PCI-mvebu-Add-support-for-compiling-driver-as-module.patch
@@ -0,0 +1,175 @@
+From 2d12fdead984145ea791cac44c0b0ce25504f4c5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 31 Oct 2021 22:55:20 +0100
+Subject: [PATCH 06/90] PCI: mvebu: Add support for compiling driver as module
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now when driver uses devm_pci_remap_iospace() function, it is possible
+implement ->remove() callback for unbinding device from driver.
+
+Implement mvebu_pcie_remove() callback with proper cleanup phase, drop
+driver's suppress_bind_attrs flag and switch type of CONFIG_PCI_MVEBU
+option from bool to tristate.
+
+This allows to compile pci-mvebu.c driver as loadable module pci-mvebu.ko
+with ability to unload it.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/Kconfig     |  2 +-
+ drivers/pci/controller/pci-mvebu.c | 91 +++++++++++++++++++++++++-----
+ 2 files changed, 77 insertions(+), 16 deletions(-)
+
+diff --git a/drivers/pci/controller/Kconfig b/drivers/pci/controller/Kconfig
+index 326f7d13024f..a4c99ebff85e 100644
+--- a/drivers/pci/controller/Kconfig
++++ b/drivers/pci/controller/Kconfig
+@@ -4,7 +4,7 @@ menu "PCI controller drivers"
+ 	depends on PCI
+ 
+ config PCI_MVEBU
+-	bool "Marvell EBU PCIe controller"
++	tristate "Marvell EBU PCIe controller"
+ 	depends on ARCH_MVEBU || ARCH_DOVE || COMPILE_TEST
+ 	depends on MVEBU_MBUS
+ 	depends on ARM
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 9cbf10d6fc30..504eb9b94c0f 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -6,6 +6,7 @@
+  */
+ 
+ #include <linux/kernel.h>
++#include <linux/module.h>
+ #include <linux/pci.h>
+ #include <linux/clk.h>
+ #include <linux/delay.h>
+@@ -154,22 +155,13 @@ static void mvebu_pcie_set_local_dev_nr(struct mvebu_pcie_port *port, int nr)
+ 	mvebu_writel(port, stat, PCIE_STAT_OFF);
+ }
+ 
+-/*
+- * Setup PCIE BARs and Address Decode Wins:
+- * BAR[0] -> internal registers (needed for MSI)
+- * BAR[1] -> covers all DRAM banks
+- * BAR[2] -> Disabled
+- * WIN[0-3] -> DRAM bank[0-3]
+- */
+-static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
++static void mvebu_pcie_disable_wins(struct mvebu_pcie_port *port)
+ {
+-	const struct mbus_dram_target_info *dram;
+-	u32 size;
+ 	int i;
+ 
+-	dram = mv_mbus_dram_info();
++	mvebu_writel(port, 0, PCIE_BAR_LO_OFF(0));
++	mvebu_writel(port, 0, PCIE_BAR_HI_OFF(0));
+ 
+-	/* First, disable and clear BARs and windows. */
+ 	for (i = 1; i < 3; i++) {
+ 		mvebu_writel(port, 0, PCIE_BAR_CTRL_OFF(i));
+ 		mvebu_writel(port, 0, PCIE_BAR_LO_OFF(i));
+@@ -185,6 +177,25 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
+ 	mvebu_writel(port, 0, PCIE_WIN5_CTRL_OFF);
+ 	mvebu_writel(port, 0, PCIE_WIN5_BASE_OFF);
+ 	mvebu_writel(port, 0, PCIE_WIN5_REMAP_OFF);
++}
++
++/*
++ * Setup PCIE BARs and Address Decode Wins:
++ * BAR[0] -> internal registers (needed for MSI)
++ * BAR[1] -> covers all DRAM banks
++ * BAR[2] -> Disabled
++ * WIN[0-3] -> DRAM bank[0-3]
++ */
++static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
++{
++	const struct mbus_dram_target_info *dram;
++	u32 size;
++	int i;
++
++	dram = mv_mbus_dram_info();
++
++	/* First, disable and clear BARs and windows. */
++	mvebu_pcie_disable_wins(port);
+ 
+ 	/* Setup windows for DDR banks.  Count total DDR size on the fly. */
+ 	size = 0;
+@@ -1257,6 +1268,52 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 	return pci_host_probe(bridge);
+ }
+ 
++static int mvebu_pcie_remove(struct platform_device *pdev)
++{
++	struct mvebu_pcie *pcie = platform_get_drvdata(pdev);
++	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
++	u32 cmd;
++	int i;
++
++	/* Remove PCI bus with all devices. */
++	pci_lock_rescan_remove();
++	pci_stop_root_bus(bridge->bus);
++	pci_remove_root_bus(bridge->bus);
++	pci_unlock_rescan_remove();
++
++	for (i = 0; i < pcie->nports; i++) {
++		struct mvebu_pcie_port *port = &pcie->ports[i];
++
++		if (!port->base)
++			continue;
++
++		/* Disable Root Bridge I/O space, memory space and bus mastering. */
++		cmd = mvebu_readl(port, PCIE_CMD_OFF);
++		cmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
++		mvebu_writel(port, cmd, PCIE_CMD_OFF);
++
++		/* Mask all interrupt sources. */
++		mvebu_writel(port, 0, PCIE_MASK_OFF);
++
++		/* Free config space for emulated root bridge. */
++		pci_bridge_emul_cleanup(&port->bridge);
++
++		/* Disable and clear BARs and windows. */
++		mvebu_pcie_disable_wins(port);
++
++		/* Delete PCIe IO and MEM windows. */
++		if (port->iowin.size)
++			mvebu_pcie_del_windows(port, port->iowin.base, port->iowin.size);
++		if (port->memwin.size)
++			mvebu_pcie_del_windows(port, port->memwin.base, port->memwin.size);
++
++		/* Power down card and disable clocks. Must be the last step. */
++		mvebu_pcie_powerdown(port);
++	}
++
++	return 0;
++}
++
+ static const struct of_device_id mvebu_pcie_of_match_table[] = {
+ 	{ .compatible = "marvell,armada-xp-pcie", },
+ 	{ .compatible = "marvell,armada-370-pcie", },
+@@ -1273,10 +1330,14 @@ static struct platform_driver mvebu_pcie_driver = {
+ 	.driver = {
+ 		.name = "mvebu-pcie",
+ 		.of_match_table = mvebu_pcie_of_match_table,
+-		/* driver unloading/unbinding currently not supported */
+-		.suppress_bind_attrs = true,
+ 		.pm = &mvebu_pcie_pm_ops,
+ 	},
+ 	.probe = mvebu_pcie_probe,
++	.remove = mvebu_pcie_remove,
+ };
+-builtin_platform_driver(mvebu_pcie_driver);
++module_platform_driver(mvebu_pcie_driver);
++
++MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@bootlin.com>");
++MODULE_AUTHOR("Pali Rohár <pali@kernel.org>");
++MODULE_DESCRIPTION("Marvell EBU PCIe controller");
++MODULE_LICENSE("GPL v2");
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0007-PCI-mvebu-Check-for-valid-ports.patch b/target/linux/generic/pending-5.15/0007-PCI-mvebu-Check-for-valid-ports.patch
new file mode 100644
index 0000000000..9ffd1bbfd9
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0007-PCI-mvebu-Check-for-valid-ports.patch
@@ -0,0 +1,54 @@
+From 848b0bb310d53bfdf4492605ea23f85f5534d7d3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 10:51:43 +0100
+Subject: [PATCH 07/90] PCI: mvebu: Check for valid ports
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some mvebu ports do not have to be initialized. So skip these uninitialized
+mvebu ports in every port iteration function to prevent access to unmapped
+memory or dereferencing NULL pointers. Uninitialized mvebu port has base
+address set to NULL.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 504eb9b94c0f..e4c6dc73159f 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -707,6 +707,9 @@ static struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = &pcie->ports[i];
+ 
++		if (!port->base)
++			continue;
++
+ 		if (bus->number == 0 && port->devfn == devfn)
+ 			return port;
+ 		if (bus->number != 0 &&
+@@ -882,6 +885,8 @@ static int mvebu_pcie_suspend(struct device *dev)
+ 	pcie = dev_get_drvdata(dev);
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = pcie->ports + i;
++		if (!port->base)
++			continue;
+ 		port->saved_pcie_stat = mvebu_readl(port, PCIE_STAT_OFF);
+ 	}
+ 
+@@ -896,6 +901,8 @@ static int mvebu_pcie_resume(struct device *dev)
+ 	pcie = dev_get_drvdata(dev);
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = pcie->ports + i;
++		if (!port->base)
++			continue;
+ 		mvebu_writel(port, port->saved_pcie_stat, PCIE_STAT_OFF);
+ 		mvebu_pcie_setup_hw(port);
+ 	}
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0008-PCI-mvebu-Check-that-PCI-bridge-specified-in-DT-has-.patch b/target/linux/generic/pending-5.15/0008-PCI-mvebu-Check-that-PCI-bridge-specified-in-DT-has-.patch
new file mode 100644
index 0000000000..3b943f7c65
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0008-PCI-mvebu-Check-that-PCI-bridge-specified-in-DT-has-.patch
@@ -0,0 +1,38 @@
+From 978d8acb29959079c59f700fbd9df105147a3c44 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 11:39:48 +0200
+Subject: [PATCH 08/90] PCI: mvebu: Check that PCI bridge specified in DT has
+ function number zero
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Driver cannot handle PCI bridges at non-zero function address. So add
+appropriate check. Currently all in-tree kernel DTS files set PCI bridge
+function to zero.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index e4c6dc73159f..b0965067e4ce 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -946,6 +946,11 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 	port->devfn = of_pci_get_devfn(child);
+ 	if (port->devfn < 0)
+ 		goto skip;
++	if (PCI_FUNC(port->devfn) != 0) {
++		dev_err(dev, "%s: invalid function number, must be zero\n",
++			port->name);
++		goto skip;
++	}
+ 
+ 	ret = mvebu_get_tgt_attr(dev->of_node, port->devfn, IORESOURCE_MEM,
+ 				 &port->mem_target, &port->mem_attr);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0009-PCI-mvebu-Handle-invalid-size-of-read-config-request.patch b/target/linux/generic/pending-5.15/0009-PCI-mvebu-Handle-invalid-size-of-read-config-request.patch
new file mode 100644
index 0000000000..93aa72754c
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0009-PCI-mvebu-Handle-invalid-size-of-read-config-request.patch
@@ -0,0 +1,35 @@
+From f117e4e1d4d4ba03cdf376392dc996e84c04ddb5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 13:13:52 +0200
+Subject: [PATCH 09/90] PCI: mvebu: Handle invalid size of read config request
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Function mvebu_pcie_hw_rd_conf() does not handle invalid size. So correctly
+set read value to all-ones and return appropriate error return value
+PCIBIOS_BAD_REGISTER_NUMBER like in mvebu_pcie_hw_wr_conf() function.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index b0965067e4ce..5bf1889cfb38 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -273,6 +273,9 @@ static int mvebu_pcie_hw_rd_conf(struct mvebu_pcie_port *port,
+ 	case 4:
+ 		*val = readl_relaxed(conf_data);
+ 		break;
++	default:
++		*val = 0xffffffff;
++		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 	}
+ 
+ 	return PCIBIOS_SUCCESSFUL;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0010-PCI-mvebu-Disallow-mapping-interrupts-on-emulated-br.patch b/target/linux/generic/pending-5.15/0010-PCI-mvebu-Disallow-mapping-interrupts-on-emulated-br.patch
new file mode 100644
index 0000000000..cfcb1e58ad
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0010-PCI-mvebu-Disallow-mapping-interrupts-on-emulated-br.patch
@@ -0,0 +1,51 @@
+From 7931a2a131998d990e5f9732fc3dc448ec672046 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 13:42:10 +0200
+Subject: [PATCH 10/90] PCI: mvebu: Disallow mapping interrupts on emulated
+ bridges
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Interrupt support on mvebu emulated bridges is not implemented yet.
+
+So properly indicate return value to callers that they cannot request
+interrupts from emulated bridge.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 5bf1889cfb38..0a8b552364aa 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -787,6 +787,15 @@ static struct pci_ops mvebu_pcie_ops = {
+ 	.write = mvebu_pcie_wr_conf,
+ };
+ 
++static int mvebu_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
++{
++	/* Interrupt support on mvebu emulated bridges is not implemented yet */
++	if (dev->bus->number == 0)
++		return 0; /* Proper return code 0 == NO_IRQ */
++
++	return of_irq_parse_and_map_pci(dev, slot, pin);
++}
++
+ static resource_size_t mvebu_pcie_align_resource(struct pci_dev *dev,
+ 						 const struct resource *res,
+ 						 resource_size_t start,
+@@ -1279,6 +1288,7 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 	bridge->sysdata = pcie;
+ 	bridge->ops = &mvebu_pcie_ops;
+ 	bridge->align_resource = mvebu_pcie_align_resource;
++	bridge->map_irq = mvebu_pcie_map_irq;
+ 
+ 	return pci_host_probe(bridge);
+ }
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0011-PCI-mvebu-Propagate-errors-when-updating-PCI_IO_BASE.patch b/target/linux/generic/pending-5.15/0011-PCI-mvebu-Propagate-errors-when-updating-PCI_IO_BASE.patch
new file mode 100644
index 0000000000..225965c6c6
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0011-PCI-mvebu-Propagate-errors-when-updating-PCI_IO_BASE.patch
@@ -0,0 +1,195 @@
+From 14d8c749e493bd09b00e5766ba96631794e1a109 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 11:34:50 +0200
+Subject: [PATCH 11/90] PCI: mvebu: Propagate errors when updating PCI_IO_BASE
+ and PCI_MEM_BASE registers
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Properly propagate failure from mvebu_pcie_add_windows() function back to
+the caller mvebu_pci_bridge_emul_base_conf_write() and correctly updates
+PCI_IO_BASE, PCI_MEM_BASE and PCI_IO_BASE_UPPER16 registers on error.
+On error set base value higher than limit value which indicates that
+address range is disabled. When IO is unsupported then let IO registers
+zeroed as required by PCIe base specification.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 82 ++++++++++++++++++++----------
+ 1 file changed, 55 insertions(+), 27 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 0a8b552364aa..32aa78059e96 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -329,7 +329,7 @@ static void mvebu_pcie_del_windows(struct mvebu_pcie_port *port,
+  * areas each having a power of two size. We start from the largest
+  * one (i.e highest order bit set in the size).
+  */
+-static void mvebu_pcie_add_windows(struct mvebu_pcie_port *port,
++static int mvebu_pcie_add_windows(struct mvebu_pcie_port *port,
+ 				   unsigned int target, unsigned int attribute,
+ 				   phys_addr_t base, size_t size,
+ 				   phys_addr_t remap)
+@@ -350,7 +350,7 @@ static void mvebu_pcie_add_windows(struct mvebu_pcie_port *port,
+ 				&base, &end, ret);
+ 			mvebu_pcie_del_windows(port, base - size_mapped,
+ 					       size_mapped);
+-			return;
++			return ret;
+ 		}
+ 
+ 		size -= sz;
+@@ -359,16 +359,20 @@ static void mvebu_pcie_add_windows(struct mvebu_pcie_port *port,
+ 		if (remap != MVEBU_MBUS_NO_REMAP)
+ 			remap += sz;
+ 	}
++
++	return 0;
+ }
+ 
+-static void mvebu_pcie_set_window(struct mvebu_pcie_port *port,
++static int mvebu_pcie_set_window(struct mvebu_pcie_port *port,
+ 				  unsigned int target, unsigned int attribute,
+ 				  const struct mvebu_pcie_window *desired,
+ 				  struct mvebu_pcie_window *cur)
+ {
++	int ret;
++
+ 	if (desired->base == cur->base && desired->remap == cur->remap &&
+ 	    desired->size == cur->size)
+-		return;
++		return 0;
+ 
+ 	if (cur->size != 0) {
+ 		mvebu_pcie_del_windows(port, cur->base, cur->size);
+@@ -383,30 +387,35 @@ static void mvebu_pcie_set_window(struct mvebu_pcie_port *port,
+ 	}
+ 
+ 	if (desired->size == 0)
+-		return;
++		return 0;
++
++	ret = mvebu_pcie_add_windows(port, target, attribute, desired->base,
++				     desired->size, desired->remap);
++	if (ret) {
++		cur->size = 0;
++		cur->base = 0;
++		return ret;
++	}
+ 
+-	mvebu_pcie_add_windows(port, target, attribute, desired->base,
+-			       desired->size, desired->remap);
+ 	*cur = *desired;
++	return 0;
+ }
+ 
+-static void mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
++static int mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
+ {
+ 	struct mvebu_pcie_window desired = {};
+ 	struct pci_bridge_emul_conf *conf = &port->bridge.conf;
+ 
+ 	/* Are the new iobase/iolimit values invalid? */
+ 	if (conf->iolimit < conf->iobase ||
+-	    conf->iolimitupper < conf->iobaseupper) {
+-		mvebu_pcie_set_window(port, port->io_target, port->io_attr,
+-				      &desired, &port->iowin);
+-		return;
+-	}
++	    conf->iolimitupper < conf->iobaseupper)
++		return mvebu_pcie_set_window(port, port->io_target, port->io_attr,
++					     &desired, &port->iowin);
+ 
+ 	if (!mvebu_has_ioport(port)) {
+ 		dev_WARN(&port->pcie->pdev->dev,
+ 			 "Attempt to set IO when IO is disabled\n");
+-		return;
++		return -EOPNOTSUPP;
+ 	}
+ 
+ 	/*
+@@ -424,21 +433,19 @@ static void mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
+ 			desired.remap) +
+ 		       1;
+ 
+-	mvebu_pcie_set_window(port, port->io_target, port->io_attr, &desired,
+-			      &port->iowin);
++	return mvebu_pcie_set_window(port, port->io_target, port->io_attr, &desired,
++				     &port->iowin);
+ }
+ 
+-static void mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)
++static int mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)
+ {
+ 	struct mvebu_pcie_window desired = {.remap = MVEBU_MBUS_NO_REMAP};
+ 	struct pci_bridge_emul_conf *conf = &port->bridge.conf;
+ 
+ 	/* Are the new membase/memlimit values invalid? */
+-	if (conf->memlimit < conf->membase) {
+-		mvebu_pcie_set_window(port, port->mem_target, port->mem_attr,
+-				      &desired, &port->memwin);
+-		return;
+-	}
++	if (conf->memlimit < conf->membase)
++		return mvebu_pcie_set_window(port, port->mem_target, port->mem_attr,
++					     &desired, &port->memwin);
+ 
+ 	/*
+ 	 * We read the PCI-to-PCI bridge emulated registers, and
+@@ -450,8 +457,8 @@ static void mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)
+ 	desired.size = (((conf->memlimit & 0xFFF0) << 16) | 0xFFFFF) -
+ 		       desired.base + 1;
+ 
+-	mvebu_pcie_set_window(port, port->mem_target, port->mem_attr, &desired,
+-			      &port->memwin);
++	return mvebu_pcie_set_window(port, port->mem_target, port->mem_attr, &desired,
++				     &port->memwin);
+ }
+ 
+ static pci_bridge_emul_read_status_t
+@@ -576,15 +583,36 @@ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 		break;
+ 
+ 	case PCI_IO_BASE:
+-		mvebu_pcie_handle_iobase_change(port);
++		if ((mask & 0xffff) && mvebu_pcie_handle_iobase_change(port)) {
++			/* On error disable IO range */
++			conf->iobase &= ~0xf0;
++			conf->iolimit &= ~0xf0;
++			conf->iobaseupper = cpu_to_le16(0x0000);
++			conf->iolimitupper = cpu_to_le16(0x0000);
++			if (mvebu_has_ioport(port))
++				conf->iobase |= 0xf0;
++		}
+ 		break;
+ 
+ 	case PCI_MEMORY_BASE:
+-		mvebu_pcie_handle_membase_change(port);
++		if (mvebu_pcie_handle_membase_change(port)) {
++			/* On error disable mem range */
++			conf->membase = cpu_to_le16(le16_to_cpu(conf->membase) & ~0xfff0);
++			conf->memlimit = cpu_to_le16(le16_to_cpu(conf->memlimit) & ~0xfff0);
++			conf->membase = cpu_to_le16(le16_to_cpu(conf->membase) | 0xfff0);
++		}
+ 		break;
+ 
+ 	case PCI_IO_BASE_UPPER16:
+-		mvebu_pcie_handle_iobase_change(port);
++		if (mvebu_pcie_handle_iobase_change(port)) {
++			/* On error disable IO range */
++			conf->iobase &= ~0xf0;
++			conf->iolimit &= ~0xf0;
++			conf->iobaseupper = cpu_to_le16(0x0000);
++			conf->iolimitupper = cpu_to_le16(0x0000);
++			if (mvebu_has_ioport(port))
++				conf->iobase |= 0xf0;
++		}
+ 		break;
+ 
+ 	case PCI_PRIMARY_BUS:
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0012-PCI-mvebu-Set-PCI-Bridge-Class-Code-to-PCI-Bridge.patch b/target/linux/generic/pending-5.15/0012-PCI-mvebu-Set-PCI-Bridge-Class-Code-to-PCI-Bridge.patch
new file mode 100644
index 0000000000..10d6b4959a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0012-PCI-mvebu-Set-PCI-Bridge-Class-Code-to-PCI-Bridge.patch
@@ -0,0 +1,73 @@
+From 0d7c624cae34b5a31715fc3bd2614315d2982bd9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 11:51:43 +0200
+Subject: [PATCH 12/90] PCI: mvebu: Set PCI Bridge Class Code to PCI Bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The default value of Class Code of this bridge corresponds to a Memory
+controller, though. This is probably relict from the past when old
+Marvell/Galileo PCI-based controllers were used as standalone PCI device
+for connecting SDRAM or workaround for PCs with broken BIOS. Details are
+in commit 36de23a4c5f0 ("MIPS: Cobalt: Explain GT64111 early PCI fixup").
+
+Change the Class Code to correspond to a PCI Bridge.
+
+Add comment explaining this change.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Cc: stable@vger.kernel.org
+---
+ drivers/pci/controller/pci-mvebu.c | 28 +++++++++++++++++++++++++++-
+ 1 file changed, 27 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 32aa78059e96..68aa94a258ff 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -233,7 +233,7 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
+ 
+ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ {
+-	u32 ctrl, cmd, mask;
++	u32 ctrl, cmd, dev_rev, mask;
+ 
+ 	/* Setup PCIe controller to Root Complex mode. */
+ 	ctrl = mvebu_readl(port, PCIE_CTRL_OFF);
+@@ -245,6 +245,32 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	cmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+ 	mvebu_writel(port, cmd, PCIE_CMD_OFF);
+ 
++	/*
++	 * Change Class Code of PCI Bridge device to PCI Bridge (0x6004)
++	 * because default value is Memory controller (0x5080).
++	 *
++	 * Note that this mvebu PCI Bridge does not have compliant Type 1
++	 * Configuration Space. Header Type is reported as Type 0 and it
++	 * has format of Type 0 config space.
++	 *
++	 * Moreover Type 0 BAR registers (ranges 0x10 - 0x28 and 0x30 - 0x34)
++	 * have the same format in Marvell's specification as in PCIe
++	 * specification, but their meaning is totally different and they do
++	 * different things: they are aliased into internal mvebu registers
++	 * (e.g. PCIE_BAR_LO_OFF) and these should not be changed or
++	 * reconfigured by pci device drivers.
++	 *
++	 * Therefore driver uses emulation of PCI Bridge which emulates
++	 * access to configuration space via internal mvebu registers or
++	 * emulated configuration buffer. Driver access these PCI Bridge
++	 * directly for simplification, but these registers can be accessed
++	 * also via standard mvebu way for accessing PCI config space.
++	 */
++	dev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);
++	dev_rev &= ~0xffffff00;
++	dev_rev |= (PCI_CLASS_BRIDGE_PCI << 8) << 8;
++	mvebu_writel(port, dev_rev, PCIE_DEV_REV_OFF);
++
+ 	/* Point PCIe unit MBUS decode windows to DRAM space. */
+ 	mvebu_pcie_setup_wins(port);
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0013-MAINTAINERS-Add-Pali-Roh-r-as-pci-mvebu.c-maintainer.patch b/target/linux/generic/pending-5.15/0013-MAINTAINERS-Add-Pali-Roh-r-as-pci-mvebu.c-maintainer.patch
new file mode 100644
index 0000000000..96c4dd3b84
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0013-MAINTAINERS-Add-Pali-Roh-r-as-pci-mvebu.c-maintainer.patch
@@ -0,0 +1,30 @@
+From b8db9ac56b79c68e4501491b259b19487eccd7db Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 25 Nov 2021 13:51:15 +0100
+Subject: [PATCH 13/90] =?UTF-8?q?MAINTAINERS:=20Add=20Pali=20Roh=C3=A1r=20?=
+ =?UTF-8?q?as=20pci-mvebu.c=20maintainer?=
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ MAINTAINERS | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index edc32575828b..5bb588d01805 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -14396,6 +14396,7 @@ F:	drivers/pci/controller/mobiveil/pcie-mobiveil*
+ 
+ PCI DRIVER FOR MVEBU (Marvell Armada 370 and Armada XP SOC support)
+ M:	Thomas Petazzoni <thomas.petazzoni@bootlin.com>
++M:	Pali Rohár <pali@kernel.org>
+ L:	linux-pci@vger.kernel.org
+ L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
+ S:	Maintained
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0014-PCI-pci-bridge-emul-Make-struct-pci_bridge_emul_ops-.patch b/target/linux/generic/pending-5.15/0014-PCI-pci-bridge-emul-Make-struct-pci_bridge_emul_ops-.patch
new file mode 100644
index 0000000000..014b632ed3
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0014-PCI-pci-bridge-emul-Make-struct-pci_bridge_emul_ops-.patch
@@ -0,0 +1,61 @@
+From 002ef7f63fb628d49f079a02ab0d8f3e08efb94a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 10:54:50 +0100
+Subject: [PATCH 14/90] PCI: pci-bridge-emul: Make struct pci_bridge_emul_ops
+ as const
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It is read-only constant structure, so properly mark it with const keyword.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 2 +-
+ drivers/pci/controller/pci-mvebu.c    | 2 +-
+ drivers/pci/pci-bridge-emul.h         | 2 +-
+ 3 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-aardvark.c b/drivers/pci/controller/pci-aardvark.c
+index 7cc2c54daad0..3fe4d3329267 100644
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -944,7 +944,7 @@ advk_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 	}
+ }
+ 
+-static struct pci_bridge_emul_ops advk_pci_bridge_emul_ops = {
++static const struct pci_bridge_emul_ops advk_pci_bridge_emul_ops = {
+ 	.read_base = advk_pci_bridge_emul_base_conf_read,
+ 	.write_base = advk_pci_bridge_emul_base_conf_write,
+ 	.read_pcie = advk_pci_bridge_emul_pcie_conf_read,
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 68aa94a258ff..2ecc1ab12249 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -709,7 +709,7 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 	}
+ }
+ 
+-static struct pci_bridge_emul_ops mvebu_pci_bridge_emul_ops = {
++static const struct pci_bridge_emul_ops mvebu_pci_bridge_emul_ops = {
+ 	.read_base = mvebu_pci_bridge_emul_base_conf_read,
+ 	.write_base = mvebu_pci_bridge_emul_base_conf_write,
+ 	.read_pcie = mvebu_pci_bridge_emul_pcie_conf_read,
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 49bbd37ee318..0690b6369755 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -112,7 +112,7 @@ struct pci_bridge_reg_behavior;
+ struct pci_bridge_emul {
+ 	struct pci_bridge_emul_conf conf;
+ 	struct pci_bridge_emul_pcie_conf pcie_conf;
+-	struct pci_bridge_emul_ops *ops;
++	const struct pci_bridge_emul_ops *ops;
+ 	struct pci_bridge_reg_behavior *pci_regs_behavior;
+ 	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
+ 	void *data;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0015-PCI-pci-bridge-emul-Rename-PCI_BRIDGE_EMUL_NO_PREFET.patch b/target/linux/generic/pending-5.15/0015-PCI-pci-bridge-emul-Rename-PCI_BRIDGE_EMUL_NO_PREFET.patch
new file mode 100644
index 0000000000..2226c30630
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0015-PCI-pci-bridge-emul-Rename-PCI_BRIDGE_EMUL_NO_PREFET.patch
@@ -0,0 +1,69 @@
+From bb5a2178ce576f3100ae3679599777d823f459a4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 10:59:52 +0100
+Subject: [PATCH 15/90] PCI: pci-bridge-emul: Rename
+ PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR to PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This flag describe whether PCI bridge supports forwarding of prefetchable
+memory requests in given range between primary and secondary buses. It does
+not specify if bridge has support for prefetchable memory BAR (moreover
+this pci-bridge-emul.c driver does not provide support for BARs).
+
+So change name of this flag to be less misleading and add comment.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 2 +-
+ drivers/pci/pci-bridge-emul.c      | 2 +-
+ drivers/pci/pci-bridge-emul.h      | 6 +++++-
+ 3 files changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 2ecc1ab12249..2e10ade660a1 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -747,7 +747,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	bridge->data = port;
+ 	bridge->ops = &mvebu_pci_bridge_emul_ops;
+ 
+-	return pci_bridge_emul_init(bridge, PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR);
++	return pci_bridge_emul_init(bridge, PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD);
+ }
+ 
+ static inline struct mvebu_pcie *sys_to_pcie(struct pci_sys_data *sys)
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index c994ebec2360..ceacba03e714 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -377,7 +377,7 @@ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+ 			~(BIT(10) << 16);
+ 	}
+ 
+-	if (flags & PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR) {
++	if (flags & PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD) {
+ 		bridge->pci_regs_behavior[PCI_PREF_MEMORY_BASE / 4].ro = ~0;
+ 		bridge->pci_regs_behavior[PCI_PREF_MEMORY_BASE / 4].rw = 0;
+ 	}
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 0690b6369755..087b5fa01bcf 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -120,7 +120,11 @@ struct pci_bridge_emul {
+ };
+ 
+ enum {
+-	PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR = BIT(0),
++	/*
++	 * PCI bridge does not support forwarding of prefetchable memory
++	 * requests between primary and secondary buses.
++	 */
++	PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD = BIT(0),
+ };
+ 
+ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0016-PCI-pci-bridge-emul-Add-support-for-new-flag-PCI_BRI.patch b/target/linux/generic/pending-5.15/0016-PCI-pci-bridge-emul-Add-support-for-new-flag-PCI_BRI.patch
new file mode 100644
index 0000000000..5d0dad669f
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0016-PCI-pci-bridge-emul-Add-support-for-new-flag-PCI_BRI.patch
@@ -0,0 +1,62 @@
+From 369e0346a0e54c96ef8776bd32d810c4e1cbbb1d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 16:53:33 +0100
+Subject: [PATCH 16/90] PCI: pci-bridge-emul: Add support for new flag
+ PCI_BRIDGE_EMUL_NO_IO_FORWARD
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Like PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD, this new flag specifies that
+emulated PCI bridge does not support forwarding of IO requests in given
+range between primary and secondary buses. This flag should be used as
+argument for pci_bridge_emul_init() for hardware setup without IO support.
+
+Setting this flag cause that IO base and limit registers are read-only.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/pci-bridge-emul.c | 9 +++++++++
+ drivers/pci/pci-bridge-emul.h | 6 ++++++
+ 2 files changed, 15 insertions(+)
+
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index ceacba03e714..a16f9e30099e 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -382,6 +382,15 @@ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+ 		bridge->pci_regs_behavior[PCI_PREF_MEMORY_BASE / 4].rw = 0;
+ 	}
+ 
++	if (flags & PCI_BRIDGE_EMUL_NO_IO_FORWARD) {
++		bridge->pci_regs_behavior[PCI_COMMAND / 4].ro |= PCI_COMMAND_IO;
++		bridge->pci_regs_behavior[PCI_COMMAND / 4].rw &= ~PCI_COMMAND_IO;
++		bridge->pci_regs_behavior[PCI_IO_BASE / 4].ro |= GENMASK(15, 0);
++		bridge->pci_regs_behavior[PCI_IO_BASE / 4].rw &= ~GENMASK(15, 0);
++		bridge->pci_regs_behavior[PCI_IO_BASE_UPPER16 / 4].ro = ~0;
++		bridge->pci_regs_behavior[PCI_IO_BASE_UPPER16 / 4].rw = 0;
++	}
++
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(pci_bridge_emul_init);
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 087b5fa01bcf..4953274cac18 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -125,6 +125,12 @@ enum {
+ 	 * requests between primary and secondary buses.
+ 	 */
+ 	PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD = BIT(0),
++
++	/*
++	 * PCI bridge does not support forwarding of IO requests between
++	 * primary and secondary buses.
++	 */
++	PCI_BRIDGE_EMUL_NO_IO_FORWARD = BIT(1),
+ };
+ 
+ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0017-PCI-mvebu-Add-help-string-for-CONFIG_PCI_MVEBU-optio.patch b/target/linux/generic/pending-5.15/0017-PCI-mvebu-Add-help-string-for-CONFIG_PCI_MVEBU-optio.patch
new file mode 100644
index 0000000000..36e71476f7
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0017-PCI-mvebu-Add-help-string-for-CONFIG_PCI_MVEBU-optio.patch
@@ -0,0 +1,34 @@
+From 3eaa66f27317eff5741cc91279e19e00c22f5643 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 31 Oct 2021 22:57:40 +0100
+Subject: [PATCH 17/90] PCI: mvebu: Add help string for CONFIG_PCI_MVEBU option
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+There is no description for CONFIG_PCI_MVEBU option. Add it.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/Kconfig | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/drivers/pci/controller/Kconfig b/drivers/pci/controller/Kconfig
+index a4c99ebff85e..46fa9bbff177 100644
+--- a/drivers/pci/controller/Kconfig
++++ b/drivers/pci/controller/Kconfig
+@@ -10,6 +10,10 @@ config PCI_MVEBU
+ 	depends on ARM
+ 	depends on OF
+ 	select PCI_BRIDGE_EMUL
++	help
++	 Add support for Marvell EBU PCIe controller. This PCIe controller
++	 is used on 32-bit Marvell ARM SoCs: Dove, Kirkwood, Armada 370,
++	 Armada XP, Armada 375, Armada 38x and Armada 39x.
+ 
+ config PCI_AARDVARK
+ 	tristate "Aardvark PCIe controller"
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0018-PCI-mvebu-Remove-duplicate-nports-assignment.patch b/target/linux/generic/pending-5.15/0018-PCI-mvebu-Remove-duplicate-nports-assignment.patch
new file mode 100644
index 0000000000..616ca2bcd0
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0018-PCI-mvebu-Remove-duplicate-nports-assignment.patch
@@ -0,0 +1,33 @@
+From 4a4519b81a342e4fe0616d839f07c215325aed86 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 20:18:18 +0100
+Subject: [PATCH 18/90] PCI: mvebu: Remove duplicate nports assignment
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Member pcie->nports is initialized to correct value before the previous
+for-loop. There is not need to initialize it more times.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-mvebu.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 2e10ade660a1..016f709b3067 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -1337,8 +1337,6 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 		mvebu_pcie_set_local_bus_nr(port, 0);
+ 	}
+ 
+-	pcie->nports = i;
+-
+ 	bridge->sysdata = pcie;
+ 	bridge->ops = &mvebu_pcie_ops;
+ 	bridge->align_resource = mvebu_pcie_align_resource;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0019-PCI-mvebu-Set-PCI_BRIDGE_EMUL_NO_IO_FORWARD-when-IO-.patch b/target/linux/generic/pending-5.15/0019-PCI-mvebu-Set-PCI_BRIDGE_EMUL_NO_IO_FORWARD-when-IO-.patch
new file mode 100644
index 0000000000..02e364a82f
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0019-PCI-mvebu-Set-PCI_BRIDGE_EMUL_NO_IO_FORWARD-when-IO-.patch
@@ -0,0 +1,114 @@
+From 1269339f0ff159e788117fb1329159b527da490f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 17:22:03 +0100
+Subject: [PATCH 19/90] PCI: mvebu: Set PCI_BRIDGE_EMUL_NO_IO_FORWARD when IO
+ is unsupported
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This will make PCI bridge to return zeros when accessing IO base and limit
+registers, as required by PCIe base specification.
+
+This allows to remove adhoc checks around mvebu_pcie_handle_iobase_change()
+function for unsupported IO ranges. PCI_BRIDGE_EMUL_NO_IO_FORWARD ensures
+that there will be no non-zeros write to IO registers when IO is not
+supported.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 29 ++++++++++-------------------
+ 1 file changed, 10 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 016f709b3067..551f55af5226 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -438,12 +438,6 @@ static int mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
+ 		return mvebu_pcie_set_window(port, port->io_target, port->io_attr,
+ 					     &desired, &port->iowin);
+ 
+-	if (!mvebu_has_ioport(port)) {
+-		dev_WARN(&port->pcie->pdev->dev,
+-			 "Attempt to set IO when IO is disabled\n");
+-		return -EOPNOTSUPP;
+-	}
+-
+ 	/*
+ 	 * We read the PCI-to-PCI bridge emulated registers, and
+ 	 * calculate the base address and size of the address decoding
+@@ -599,24 +593,18 @@ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 
+ 	switch (reg) {
+ 	case PCI_COMMAND:
+-		if (!mvebu_has_ioport(port)) {
+-			conf->command = cpu_to_le16(
+-				le16_to_cpu(conf->command) & ~PCI_COMMAND_IO);
+-			new &= ~PCI_COMMAND_IO;
+-		}
+-
+ 		mvebu_writel(port, new, PCIE_CMD_OFF);
+ 		break;
+ 
+ 	case PCI_IO_BASE:
+-		if ((mask & 0xffff) && mvebu_pcie_handle_iobase_change(port)) {
++		if ((mask & 0xffff) && mvebu_has_ioport(port) &&
++		    mvebu_pcie_handle_iobase_change(port)) {
+ 			/* On error disable IO range */
+ 			conf->iobase &= ~0xf0;
+ 			conf->iolimit &= ~0xf0;
++			conf->iobase |= 0xf0;
+ 			conf->iobaseupper = cpu_to_le16(0x0000);
+ 			conf->iolimitupper = cpu_to_le16(0x0000);
+-			if (mvebu_has_ioport(port))
+-				conf->iobase |= 0xf0;
+ 		}
+ 		break;
+ 
+@@ -630,14 +618,14 @@ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 		break;
+ 
+ 	case PCI_IO_BASE_UPPER16:
+-		if (mvebu_pcie_handle_iobase_change(port)) {
++		if (mvebu_has_ioport(port) &&
++		    mvebu_pcie_handle_iobase_change(port)) {
+ 			/* On error disable IO range */
+ 			conf->iobase &= ~0xf0;
+ 			conf->iolimit &= ~0xf0;
++			conf->iobase |= 0xf0;
+ 			conf->iobaseupper = cpu_to_le16(0x0000);
+ 			conf->iolimitupper = cpu_to_le16(0x0000);
+-			if (mvebu_has_ioport(port))
+-				conf->iobase |= 0xf0;
+ 		}
+ 		break;
+ 
+@@ -722,6 +710,7 @@ static const struct pci_bridge_emul_ops mvebu_pci_bridge_emul_ops = {
+  */
+ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ {
++	unsigned int bridge_flags = PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD;
+ 	struct pci_bridge_emul *bridge = &port->bridge;
+ 	u32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP);
+ 	u8 pcie_cap_ver = ((pcie_cap >> 16) & PCI_EXP_FLAGS_VERS);
+@@ -735,6 +724,8 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 		/* We support 32 bits I/O addressing */
+ 		bridge->conf.iobase = PCI_IO_RANGE_TYPE_32;
+ 		bridge->conf.iolimit = PCI_IO_RANGE_TYPE_32;
++	} else {
++		bridge_flags |= PCI_BRIDGE_EMUL_NO_IO_FORWARD;
+ 	}
+ 
+ 	/*
+@@ -747,7 +738,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	bridge->data = port;
+ 	bridge->ops = &mvebu_pci_bridge_emul_ops;
+ 
+-	return pci_bridge_emul_init(bridge, PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD);
++	return pci_bridge_emul_init(bridge, bridge_flags);
+ }
+ 
+ static inline struct mvebu_pcie *sys_to_pcie(struct pci_sys_data *sys)
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0020-PCI-mvebu-Properly-initialize-vendor-device-and-revi.patch b/target/linux/generic/pending-5.15/0020-PCI-mvebu-Properly-initialize-vendor-device-and-revi.patch
new file mode 100644
index 0000000000..3025003f75
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0020-PCI-mvebu-Properly-initialize-vendor-device-and-revi.patch
@@ -0,0 +1,42 @@
+From 4ae6a8f60faf1d918e7421410d04386ee8b06894 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:48:21 +0200
+Subject: [PATCH 20/90] PCI: mvebu: Properly initialize vendor, device and
+ revision of emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+With this change also PCI vendor id is read from mvebu registers.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 9 +++++----
+ 1 file changed, 5 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 551f55af5226..94ef00b6d697 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -712,13 +712,14 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ {
+ 	unsigned int bridge_flags = PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD;
+ 	struct pci_bridge_emul *bridge = &port->bridge;
++	u32 dev_id = mvebu_readl(port, PCIE_DEV_ID_OFF);
++	u32 dev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);
+ 	u32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP);
+ 	u8 pcie_cap_ver = ((pcie_cap >> 16) & PCI_EXP_FLAGS_VERS);
+ 
+-	bridge->conf.vendor = PCI_VENDOR_ID_MARVELL;
+-	bridge->conf.device = mvebu_readl(port, PCIE_DEV_ID_OFF) >> 16;
+-	bridge->conf.class_revision =
+-		mvebu_readl(port, PCIE_DEV_REV_OFF) & 0xff;
++	bridge->conf.vendor = cpu_to_le16(dev_id & 0xffff);
++	bridge->conf.device = cpu_to_le16(dev_id >> 16);
++	bridge->conf.class_revision = cpu_to_le32(dev_rev & 0xff);
+ 
+ 	if (mvebu_has_ioport(port)) {
+ 		/* We support 32 bits I/O addressing */
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0021-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCAP-register.patch b/target/linux/generic/pending-5.15/0021-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCAP-register.patch
new file mode 100644
index 0000000000..1239337d24
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0021-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCAP-register.patch
@@ -0,0 +1,34 @@
+From 91948e605b7b0f3f65919d6e19ef4e39535faf6a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 11:54:37 +0200
+Subject: [PATCH 21/90] PCI: mvebu: Update comment for PCI_EXP_LNKCAP register
+ on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Reason for clearing this bit is because mvebu hw returns incorrectly this bit set to 1.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 94ef00b6d697..1aac65977b97 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -546,8 +546,8 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 
+ 	case PCI_EXP_LNKCAP:
+ 		/*
+-		 * PCIe requires the clock power management capability to be
+-		 * hard-wired to zero for downstream ports
++		 * PCIe requires that the Clock Power Management capability bit
++		 * is hard-wired to zero for downstream ports but HW returns 1.
+ 		 */
+ 		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &
+ 			 ~PCI_EXP_LNKCAP_CLKPM;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0022-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCTL-register.patch b/target/linux/generic/pending-5.15/0022-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCTL-register.patch
new file mode 100644
index 0000000000..49bd9e28b8
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0022-PCI-mvebu-Update-comment-for-PCI_EXP_LNKCTL-register.patch
@@ -0,0 +1,39 @@
+From b47763b59b70859fdcb98e228ac5d762cca39ab7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 11:57:20 +0200
+Subject: [PATCH 22/90] PCI: mvebu: Update comment for PCI_EXP_LNKCTL register
+ on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Logic and code for clearing PCI_EXP_LNKCTL_CLKREQ_EN bit is correct, but
+comment describing it is misleading. PCI_EXP_LNKCTL_CLKREQ_EN bit should be
+hardwired to zero but mvebu hw allows to change it.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 7 +++----
+ 1 file changed, 3 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 1aac65977b97..dffa330de174 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -663,10 +663,9 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 
+ 	case PCI_EXP_LNKCTL:
+ 		/*
+-		 * If we don't support CLKREQ, we must ensure that the
+-		 * CLKREQ enable bit always reads zero.  Since we haven't
+-		 * had this capability, and it's dependent on board wiring,
+-		 * disable it for the time being.
++		 * PCIe requires that the Enable Clock Power Management bit
++		 * is hard-wired to zero for downstream ports but HW allows
++		 * to change it.
+ 		 */
+ 		new &= ~PCI_EXP_LNKCTL_CLKREQ_EN;
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0023-PCI-mvebu-Fix-reporting-Data-Link-Layer-Link-Active-.patch b/target/linux/generic/pending-5.15/0023-PCI-mvebu-Fix-reporting-Data-Link-Layer-Link-Active-.patch
new file mode 100644
index 0000000000..9c4b93cfdf
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0023-PCI-mvebu-Fix-reporting-Data-Link-Layer-Link-Active-.patch
@@ -0,0 +1,50 @@
+From 65913d4ca9e1f51ddd086b530373da620c934502 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 13:16:37 +0200
+Subject: [PATCH 23/90] PCI: mvebu: Fix reporting Data Link Layer Link Active
+ on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for reporting PCI_EXP_LNKSTA_DLLLA bit in Link Control register
+on emulated bridge via PCIE_STAT_OFF reg. Function mvebu_pcie_link_up()
+already parses this register and returns if Data Link is Active or not.
+
+Also correctly indicate DLLLA capability via PCI_EXP_LNKCAP_DLLLARC bit in
+Link Control Capability register which is required for reporting DLLLA bit.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 11 ++++++++---
+ 1 file changed, 8 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index dffa330de174..a075ba26cff1 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -548,13 +548,18 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 		/*
+ 		 * PCIe requires that the Clock Power Management capability bit
+ 		 * is hard-wired to zero for downstream ports but HW returns 1.
++		 * Additionally enable Data Link Layer Link Active Reporting
++		 * Capable bit as DL_Active indication is provided too.
+ 		 */
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &
+-			 ~PCI_EXP_LNKCAP_CLKPM;
++		*value = (mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &
++			  ~PCI_EXP_LNKCAP_CLKPM) | PCI_EXP_LNKCAP_DLLLARC;
+ 		break;
+ 
+ 	case PCI_EXP_LNKCTL:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);
++		/* DL_Active indication is provided via PCIE_STAT_OFF */
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL) |
++			 (mvebu_pcie_link_up(port) ?
++			  (PCI_EXP_LNKSTA_DLLLA << 16) : 0);
+ 		break;
+ 
+ 	case PCI_EXP_SLTCTL:
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0024-PCI-pci-bridge-emul-Re-arrange-register-tests.patch b/target/linux/generic/pending-5.15/0024-PCI-pci-bridge-emul-Re-arrange-register-tests.patch
new file mode 100644
index 0000000000..6fee5533a5
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0024-PCI-pci-bridge-emul-Re-arrange-register-tests.patch
@@ -0,0 +1,117 @@
+From fd539c7270dca28ee9943f7b93d445481ab71721 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 2 Feb 2021 13:45:28 +0000
+Subject: [PATCH 24/90] PCI: pci-bridge-emul: Re-arrange register tests
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Re-arrange the tests for which sets of registers are being accessed so that
+it is easier to add further regions later. No functional change.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[pali: Fix reading old value in pci_bridge_emul_conf_write]
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/pci-bridge-emul.c | 61 ++++++++++++++++++-----------------
+ 1 file changed, 31 insertions(+), 30 deletions(-)
+
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index a16f9e30099e..a956408834d6 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -422,25 +422,25 @@ int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+ 	__le32 *cfgspace;
+ 	const struct pci_bridge_reg_behavior *behavior;
+ 
+-	if (bridge->has_pcie && reg >= PCI_CAP_PCIE_END) {
+-		*value = 0;
+-		return PCIBIOS_SUCCESSFUL;
+-	}
+-
+-	if (!bridge->has_pcie && reg >= PCI_BRIDGE_CONF_END) {
++	if (reg < PCI_BRIDGE_CONF_END) {
++		/* Emulated PCI space */
++		read_op = bridge->ops->read_base;
++		cfgspace = (__le32 *) &bridge->conf;
++		behavior = bridge->pci_regs_behavior;
++	} else if (!bridge->has_pcie) {
++		/* PCIe space is not implemented, and no PCI capabilities */
+ 		*value = 0;
+ 		return PCIBIOS_SUCCESSFUL;
+-	}
+-
+-	if (bridge->has_pcie && reg >= PCI_CAP_PCIE_START) {
++	} else if (reg < PCI_CAP_PCIE_END) {
++		/* Our emulated PCIe capability */
+ 		reg -= PCI_CAP_PCIE_START;
+ 		read_op = bridge->ops->read_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+ 	} else {
+-		read_op = bridge->ops->read_base;
+-		cfgspace = (__le32 *) &bridge->conf;
+-		behavior = bridge->pci_regs_behavior;
++		/* Beyond our PCIe space */
++		*value = 0;
++		return PCIBIOS_SUCCESSFUL;
+ 	}
+ 
+ 	if (read_op)
+@@ -484,11 +484,27 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 	__le32 *cfgspace;
+ 	const struct pci_bridge_reg_behavior *behavior;
+ 
+-	if (bridge->has_pcie && reg >= PCI_CAP_PCIE_END)
+-		return PCIBIOS_SUCCESSFUL;
++	ret = pci_bridge_emul_conf_read(bridge, reg, 4, &old);
++	if (ret != PCIBIOS_SUCCESSFUL)
++		return ret;
+ 
+-	if (!bridge->has_pcie && reg >= PCI_BRIDGE_CONF_END)
++	if (reg < PCI_BRIDGE_CONF_END) {
++		/* Emulated PCI space */
++		write_op = bridge->ops->write_base;
++		cfgspace = (__le32 *) &bridge->conf;
++		behavior = bridge->pci_regs_behavior;
++	} else if (!bridge->has_pcie) {
++		/* PCIe space is not implemented, and no PCI capabilities */
+ 		return PCIBIOS_SUCCESSFUL;
++	} else if (reg < PCI_CAP_PCIE_END) {
++		/* Our emulated PCIe capability */
++		reg -= PCI_CAP_PCIE_START;
++		write_op = bridge->ops->write_pcie;
++		cfgspace = (__le32 *) &bridge->pcie_conf;
++		behavior = bridge->pcie_cap_regs_behavior;
++	} else {
++		return PCIBIOS_SUCCESSFUL;
++	}
+ 
+ 	shift = (where & 0x3) * 8;
+ 
+@@ -501,21 +517,6 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 	else
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 
+-	ret = pci_bridge_emul_conf_read(bridge, reg, 4, &old);
+-	if (ret != PCIBIOS_SUCCESSFUL)
+-		return ret;
+-
+-	if (bridge->has_pcie && reg >= PCI_CAP_PCIE_START) {
+-		reg -= PCI_CAP_PCIE_START;
+-		write_op = bridge->ops->write_pcie;
+-		cfgspace = (__le32 *) &bridge->pcie_conf;
+-		behavior = bridge->pcie_cap_regs_behavior;
+-	} else {
+-		write_op = bridge->ops->write_base;
+-		cfgspace = (__le32 *) &bridge->conf;
+-		behavior = bridge->pci_regs_behavior;
+-	}
+-
+ 	/* Keep all bits, except the RW bits */
+ 	new = old & (~mask | ~behavior[reg / 4].rw);
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0025-PCI-pci-bridge-emul-Add-support-for-PCIe-extended-ca.patch b/target/linux/generic/pending-5.15/0025-PCI-pci-bridge-emul-Add-support-for-PCIe-extended-ca.patch
new file mode 100644
index 0000000000..27e7b570a6
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0025-PCI-pci-bridge-emul-Add-support-for-PCIe-extended-ca.patch
@@ -0,0 +1,179 @@
+From 09ccac06bf207e939bd00487bb8e2b7bdc1cddf2 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 2 Feb 2021 13:57:04 +0000
+Subject: [PATCH 25/90] PCI: pci-bridge-emul: Add support for PCIe extended
+ capabilities
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for PCIe extended capabilities, which we just redirect to the
+emulating driver.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[pali: Fix writing new value with W1C bits]
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/pci-bridge-emul.c | 77 +++++++++++++++++++++++------------
+ drivers/pci/pci-bridge-emul.h | 15 +++++++
+ 2 files changed, 67 insertions(+), 25 deletions(-)
+
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index a956408834d6..c4b9837006ff 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -437,10 +437,16 @@ int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+ 		read_op = bridge->ops->read_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+-	} else {
+-		/* Beyond our PCIe space */
++	} else if (reg < PCI_CFG_SPACE_SIZE) {
++		/* Rest of PCI space not implemented */
+ 		*value = 0;
+ 		return PCIBIOS_SUCCESSFUL;
++	} else {
++		/* PCIe extended capability space */
++		reg -= PCI_CFG_SPACE_SIZE;
++		read_op = bridge->ops->read_ext;
++		cfgspace = NULL;
++		behavior = NULL;
+ 	}
+ 
+ 	if (read_op)
+@@ -448,15 +454,20 @@ int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+ 	else
+ 		ret = PCI_BRIDGE_EMUL_NOT_HANDLED;
+ 
+-	if (ret == PCI_BRIDGE_EMUL_NOT_HANDLED)
+-		*value = le32_to_cpu(cfgspace[reg / 4]);
++	if (ret == PCI_BRIDGE_EMUL_NOT_HANDLED) {
++		if (cfgspace)
++			*value = le32_to_cpu(cfgspace[reg / 4]);
++		else
++			*value = 0;
++	}
+ 
+ 	/*
+ 	 * Make sure we never return any reserved bit with a value
+ 	 * different from 0.
+ 	 */
+-	*value &= behavior[reg / 4].ro | behavior[reg / 4].rw |
+-		  behavior[reg / 4].w1c;
++	if (behavior)
++		*value &= behavior[reg / 4].ro | behavior[reg / 4].rw |
++			  behavior[reg / 4].w1c;
+ 
+ 	if (size == 1)
+ 		*value = (*value >> (8 * (where & 3))) & 0xff;
+@@ -502,8 +513,15 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 		write_op = bridge->ops->write_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+-	} else {
++	} else if (reg < PCI_CFG_SPACE_SIZE) {
++		/* Rest of PCI space not implemented */
+ 		return PCIBIOS_SUCCESSFUL;
++	} else {
++		/* PCIe extended capability space */
++		reg -= PCI_CFG_SPACE_SIZE;
++		write_op = bridge->ops->write_ext;
++		cfgspace = NULL;
++		behavior = NULL;
+ 	}
+ 
+ 	shift = (where & 0x3) * 8;
+@@ -517,29 +535,38 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 	else
+ 		return PCIBIOS_BAD_REGISTER_NUMBER;
+ 
+-	/* Keep all bits, except the RW bits */
+-	new = old & (~mask | ~behavior[reg / 4].rw);
++	if (behavior) {
++		/* Keep all bits, except the RW bits */
++		new = old & (~mask | ~behavior[reg / 4].rw);
+ 
+-	/* Update the value of the RW bits */
+-	new |= (value << shift) & (behavior[reg / 4].rw & mask);
++		/* Update the value of the RW bits */
++		new |= (value << shift) & (behavior[reg / 4].rw & mask);
+ 
+-	/* Clear the W1C bits */
+-	new &= ~((value << shift) & (behavior[reg / 4].w1c & mask));
++		/* Clear the W1C bits */
++		new &= ~((value << shift) & (behavior[reg / 4].w1c & mask));
++	} else {
++		new = old & ~mask;
++		new |= (value << shift) & mask;
++	}
+ 
+-	/* Save the new value with the cleared W1C bits into the cfgspace */
+-	cfgspace[reg / 4] = cpu_to_le32(new);
++	if (cfgspace) {
++		/* Save the new value with the cleared W1C bits into the cfgspace */
++		cfgspace[reg / 4] = cpu_to_le32(new);
++	}
+ 
+-	/*
+-	 * Clear the W1C bits not specified by the write mask, so that the
+-	 * write_op() does not clear them.
+-	 */
+-	new &= ~(behavior[reg / 4].w1c & ~mask);
++	if (behavior) {
++		/*
++		 * Clear the W1C bits not specified by the write mask, so that the
++		 * write_op() does not clear them.
++		 */
++		new &= ~(behavior[reg / 4].w1c & ~mask);
+ 
+-	/*
+-	 * Set the W1C bits specified by the write mask, so that write_op()
+-	 * knows about that they are to be cleared.
+-	 */
+-	new |= (value << shift) & (behavior[reg / 4].w1c & mask);
++		/*
++		 * Set the W1C bits specified by the write mask, so that write_op()
++		 * knows about that they are to be cleared.
++		 */
++		new |= (value << shift) & (behavior[reg / 4].w1c & mask);
++	}
+ 
+ 	if (write_op)
+ 		write_op(bridge, reg, old, new, mask);
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 4953274cac18..6b5f75b2ad02 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -90,6 +90,14 @@ struct pci_bridge_emul_ops {
+ 	 */
+ 	pci_bridge_emul_read_status_t (*read_pcie)(struct pci_bridge_emul *bridge,
+ 						   int reg, u32 *value);
++
++	/*
++	 * Same as ->read_base(), except it is for reading from the
++	 * PCIe extended capability configuration space.
++	 */
++	pci_bridge_emul_read_status_t (*read_ext)(struct pci_bridge_emul *bridge,
++						  int reg, u32 *value);
++
+ 	/*
+ 	 * Called when writing to the regular PCI bridge configuration
+ 	 * space. old is the current value, new is the new value being
+@@ -105,6 +113,13 @@ struct pci_bridge_emul_ops {
+ 	 */
+ 	void (*write_pcie)(struct pci_bridge_emul *bridge, int reg,
+ 			   u32 old, u32 new, u32 mask);
++
++	/*
++	 * Same as ->write_base(), except it is for writing from the
++	 * PCIe extended capability configuration space.
++	 */
++	void (*write_ext)(struct pci_bridge_emul *bridge, int reg,
++			  u32 old, u32 new, u32 mask);
+ };
+ 
+ struct pci_bridge_reg_behavior;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0026-PCI-pci-bridge-emul-Add-support-for-PCI-Bridge-Subsy.patch b/target/linux/generic/pending-5.15/0026-PCI-pci-bridge-emul-Add-support-for-PCI-Bridge-Subsy.patch
new file mode 100644
index 0000000000..bcaa3d1cac
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0026-PCI-pci-bridge-emul-Add-support-for-PCI-Bridge-Subsy.patch
@@ -0,0 +1,169 @@
+From 097c7cbac9190481535ff83ac2271ede383e8f0a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 8 Oct 2021 11:39:06 +0200
+Subject: [PATCH 26/90] PCI: pci-bridge-emul: Add support for PCI Bridge
+ Subsystem Vendor ID capability
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This is read-only capability in PCI config space. Put it between base PCI
+capability and base PCI Express capability.
+
+Driver just have to specify subsystem_vendor_id and subsystem_id fields in
+emulated bridge structure and pci-bridge-emul takes care of correctly
+compose PCI Bridge Subsystem Vendor ID capability.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/pci-bridge-emul.c | 69 +++++++++++++++++++++++++----------
+ drivers/pci/pci-bridge-emul.h |  2 +
+ 2 files changed, 51 insertions(+), 20 deletions(-)
+
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index c4b9837006ff..a5b662cc89d0 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -21,8 +21,11 @@
+ #include "pci-bridge-emul.h"
+ 
+ #define PCI_BRIDGE_CONF_END	PCI_STD_HEADER_SIZEOF
++#define PCI_CAP_SSID_SIZEOF	(PCI_SSVID_DEVICE_ID + 2)
++#define PCI_CAP_SSID_START	PCI_BRIDGE_CONF_END
++#define PCI_CAP_SSID_END	(PCI_CAP_SSID_START + PCI_CAP_SSID_SIZEOF)
+ #define PCI_CAP_PCIE_SIZEOF	(PCI_EXP_SLTSTA2 + 2)
+-#define PCI_CAP_PCIE_START	PCI_BRIDGE_CONF_END
++#define PCI_CAP_PCIE_START	PCI_CAP_SSID_END
+ #define PCI_CAP_PCIE_END	(PCI_CAP_PCIE_START + PCI_CAP_PCIE_SIZEOF)
+ 
+ /**
+@@ -315,6 +318,25 @@ struct pci_bridge_reg_behavior pcie_cap_regs_behavior[PCI_CAP_PCIE_SIZEOF / 4] =
+ 	},
+ };
+ 
++static pci_bridge_emul_read_status_t
++pci_bridge_emul_read_ssid(struct pci_bridge_emul *bridge, int reg, u32 *value)
++{
++	switch (reg) {
++	case PCI_CAP_LIST_ID:
++		*value = PCI_CAP_ID_SSVID |
++			(bridge->has_pcie ? (PCI_CAP_PCIE_START << 8) : 0);
++		return PCI_BRIDGE_EMUL_HANDLED;
++
++	case PCI_SSVID_VENDOR_ID:
++		*value = bridge->subsystem_vendor_id |
++			(bridge->subsystem_id << 16);
++		return PCI_BRIDGE_EMUL_HANDLED;
++
++	default:
++		return PCI_BRIDGE_EMUL_NOT_HANDLED;
++	}
++}
++
+ /*
+  * Initialize a pci_bridge_emul structure to represent a fake PCI
+  * bridge configuration space. The caller needs to have initialized
+@@ -341,9 +363,17 @@ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+ 	if (!bridge->pci_regs_behavior)
+ 		return -ENOMEM;
+ 
+-	if (bridge->has_pcie) {
++	if (bridge->subsystem_vendor_id)
++		bridge->conf.capabilities_pointer = PCI_CAP_SSID_START;
++	else if (bridge->has_pcie)
+ 		bridge->conf.capabilities_pointer = PCI_CAP_PCIE_START;
++	else
++		bridge->conf.capabilities_pointer = 0;
++
++	if (bridge->conf.capabilities_pointer)
+ 		bridge->conf.status |= cpu_to_le16(PCI_STATUS_CAP_LIST);
++
++	if (bridge->has_pcie) {
+ 		bridge->pcie_conf.cap_id = PCI_CAP_ID_EXP;
+ 		bridge->pcie_conf.cap |= cpu_to_le16(PCI_EXP_TYPE_ROOT_PORT << 4);
+ 		bridge->pcie_cap_regs_behavior =
+@@ -427,26 +457,28 @@ int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+ 		read_op = bridge->ops->read_base;
+ 		cfgspace = (__le32 *) &bridge->conf;
+ 		behavior = bridge->pci_regs_behavior;
+-	} else if (!bridge->has_pcie) {
+-		/* PCIe space is not implemented, and no PCI capabilities */
+-		*value = 0;
+-		return PCIBIOS_SUCCESSFUL;
+-	} else if (reg < PCI_CAP_PCIE_END) {
++	} else if (reg >= PCI_CAP_SSID_START && reg < PCI_CAP_SSID_END && bridge->subsystem_vendor_id) {
++		/* Emulated PCI Bridge Subsystem Vendor ID capability */
++		reg -= PCI_CAP_SSID_START;
++		read_op = pci_bridge_emul_read_ssid;
++		cfgspace = NULL;
++		behavior = NULL;
++	} else if (reg >= PCI_CAP_PCIE_START && reg < PCI_CAP_PCIE_END && bridge->has_pcie) {
+ 		/* Our emulated PCIe capability */
+ 		reg -= PCI_CAP_PCIE_START;
+ 		read_op = bridge->ops->read_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+-	} else if (reg < PCI_CFG_SPACE_SIZE) {
+-		/* Rest of PCI space not implemented */
+-		*value = 0;
+-		return PCIBIOS_SUCCESSFUL;
+-	} else {
++	} else if (reg >= PCI_CFG_SPACE_SIZE && bridge->has_pcie) {
+ 		/* PCIe extended capability space */
+ 		reg -= PCI_CFG_SPACE_SIZE;
+ 		read_op = bridge->ops->read_ext;
+ 		cfgspace = NULL;
+ 		behavior = NULL;
++	} else {
++		/* Not implemented */
++		*value = 0;
++		return PCIBIOS_SUCCESSFUL;
+ 	}
+ 
+ 	if (read_op)
+@@ -504,24 +536,21 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 		write_op = bridge->ops->write_base;
+ 		cfgspace = (__le32 *) &bridge->conf;
+ 		behavior = bridge->pci_regs_behavior;
+-	} else if (!bridge->has_pcie) {
+-		/* PCIe space is not implemented, and no PCI capabilities */
+-		return PCIBIOS_SUCCESSFUL;
+-	} else if (reg < PCI_CAP_PCIE_END) {
++	} else if (reg >= PCI_CAP_PCIE_START && reg < PCI_CAP_PCIE_END && bridge->has_pcie) {
+ 		/* Our emulated PCIe capability */
+ 		reg -= PCI_CAP_PCIE_START;
+ 		write_op = bridge->ops->write_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+-	} else if (reg < PCI_CFG_SPACE_SIZE) {
+-		/* Rest of PCI space not implemented */
+-		return PCIBIOS_SUCCESSFUL;
+-	} else {
++	} else if (reg >= PCI_CFG_SPACE_SIZE && bridge->has_pcie) {
+ 		/* PCIe extended capability space */
+ 		reg -= PCI_CFG_SPACE_SIZE;
+ 		write_op = bridge->ops->write_ext;
+ 		cfgspace = NULL;
+ 		behavior = NULL;
++	} else {
++		/* Not implemented */
++		return PCIBIOS_SUCCESSFUL;
+ 	}
+ 
+ 	shift = (where & 0x3) * 8;
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 6b5f75b2ad02..71392b67471d 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -132,6 +132,8 @@ struct pci_bridge_emul {
+ 	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
+ 	void *data;
+ 	bool has_pcie;
++	u16 subsystem_vendor_id;
++	u16 subsystem_id;
+ };
+ 
+ enum {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0027-dt-bindings-PCI-mvebu-Add-num-lanes-property.patch b/target/linux/generic/pending-5.15/0027-dt-bindings-PCI-mvebu-Add-num-lanes-property.patch
new file mode 100644
index 0000000000..339456b790
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0027-dt-bindings-PCI-mvebu-Add-num-lanes-property.patch
@@ -0,0 +1,114 @@
+From cca87cdc18be3c7ab387aad99cbc3d2e2a5e16dc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 3 Nov 2021 14:32:52 +0100
+Subject: [PATCH 27/90] dt-bindings: PCI: mvebu: Add num-lanes property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Controller driver needs to correctly configure PCIe link if it contains 1
+or 4 SerDes PCIe lanes. Therefore add a new 'num-lanes' DT property for
+mvebu PCIe controller. Property 'num-lanes' seems to be de-facto standard
+way how number of lanes is specified in other PCIe controllers.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Rob Herring <robh@kernel.org>
+---
+ Documentation/devicetree/bindings/pci/mvebu-pci.txt | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+diff --git a/Documentation/devicetree/bindings/pci/mvebu-pci.txt b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+index 6173af6885f8..24225852bce0 100644
+--- a/Documentation/devicetree/bindings/pci/mvebu-pci.txt
++++ b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+@@ -77,6 +77,7 @@ and the following optional properties:
+ - marvell,pcie-lane: the physical PCIe lane number, for ports having
+   multiple lanes. If this property is not found, we assume that the
+   value is 0.
++- num-lanes: number of SerDes PCIe lanes for this link (1 or 4)
+ - reset-gpios: optional GPIO to PERST#
+ - reset-delay-us: delay in us to wait after reset de-assertion, if not
+   specified will default to 100ms, as required by the PCIe specification.
+@@ -141,6 +142,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 58>;
+ 		marvell,pcie-port = <0>;
+ 		marvell,pcie-lane = <0>;
++		num-lanes = <1>;
+ 		/* low-active PERST# reset on GPIO 25 */
+ 		reset-gpios = <&gpio0 25 1>;
+ 		/* wait 20ms for device settle after reset deassertion */
+@@ -161,6 +163,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 59>;
+ 		marvell,pcie-port = <0>;
+ 		marvell,pcie-lane = <1>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 6>;
+ 	};
+ 
+@@ -177,6 +180,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 60>;
+ 		marvell,pcie-port = <0>;
+ 		marvell,pcie-lane = <2>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 7>;
+ 	};
+ 
+@@ -193,6 +197,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 61>;
+ 		marvell,pcie-port = <0>;
+ 		marvell,pcie-lane = <3>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 8>;
+ 	};
+ 
+@@ -209,6 +214,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 62>;
+ 		marvell,pcie-port = <1>;
+ 		marvell,pcie-lane = <0>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 9>;
+ 	};
+ 
+@@ -225,6 +231,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 63>;
+ 		marvell,pcie-port = <1>;
+ 		marvell,pcie-lane = <1>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 10>;
+ 	};
+ 
+@@ -241,6 +248,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 64>;
+ 		marvell,pcie-port = <1>;
+ 		marvell,pcie-lane = <2>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 11>;
+ 	};
+ 
+@@ -257,6 +265,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 65>;
+ 		marvell,pcie-port = <1>;
+ 		marvell,pcie-lane = <3>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 12>;
+ 	};
+ 
+@@ -273,6 +282,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 99>;
+ 		marvell,pcie-port = <2>;
+ 		marvell,pcie-lane = <0>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 26>;
+ 	};
+ 
+@@ -289,6 +299,7 @@ pcie-controller {
+ 		interrupt-map = <0 0 0 0 &mpic 103>;
+ 		marvell,pcie-port = <3>;
+ 		marvell,pcie-lane = <0>;
++		num-lanes = <1>;
+ 		clocks = <&gateclk 27>;
+ 	};
+ };
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0028-PCI-mvebu-Correctly-configure-x1-x4-mode.patch b/target/linux/generic/pending-5.15/0028-PCI-mvebu-Correctly-configure-x1-x4-mode.patch
new file mode 100644
index 0000000000..bb871633c1
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0028-PCI-mvebu-Correctly-configure-x1-x4-mode.patch
@@ -0,0 +1,78 @@
+From 2137824f2a4e824b5d54b17c12d1005a6455ca12 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 11 Oct 2021 11:30:05 +0200
+Subject: [PATCH 28/90] PCI: mvebu: Correctly configure x1/x4 mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+If x1/x4 mode is not set correctly then link with endpoint card is not
+established.
+
+Use DTS property 'num-lanes' to deteriminate x1/x4 mode.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 19 ++++++++++++++++++-
+ 1 file changed, 18 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index a075ba26cff1..0f2ec0a17874 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -93,6 +93,7 @@ struct mvebu_pcie_port {
+ 	void __iomem *base;
+ 	u32 port;
+ 	u32 lane;
++	bool is_x4;
+ 	int devfn;
+ 	unsigned int mem_target;
+ 	unsigned int mem_attr;
+@@ -233,13 +234,25 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
+ 
+ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ {
+-	u32 ctrl, cmd, dev_rev, mask;
++	u32 ctrl, lnkcap, cmd, dev_rev, mask;
+ 
+ 	/* Setup PCIe controller to Root Complex mode. */
+ 	ctrl = mvebu_readl(port, PCIE_CTRL_OFF);
+ 	ctrl |= PCIE_CTRL_RC_MODE;
+ 	mvebu_writel(port, ctrl, PCIE_CTRL_OFF);
+ 
++	/*
++	 * Set Maximum Link Width to X1 or X4 in Root Port's PCIe Link
++	 * Capability register. This register is defined by PCIe specification
++	 * as read-only but this mvebu controller has it as read-write and must
++	 * be set to number of SerDes PCIe lanes (1 or 4). If this register is
++	 * not set correctly then link with endpoint card is not established.
++	 */
++	lnkcap = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);
++	lnkcap &= ~PCI_EXP_LNKCAP_MLW;
++	lnkcap |= (port->is_x4 ? 4 : 1) << 4;
++	mvebu_writel(port, lnkcap, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);
++
+ 	/* Disable Root Bridge I/O space, memory space and bus mastering. */
+ 	cmd = mvebu_readl(port, PCIE_CMD_OFF);
+ 	cmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+@@ -986,6 +999,7 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 	struct device *dev = &pcie->pdev->dev;
+ 	enum of_gpio_flags flags;
+ 	int reset_gpio, ret;
++	u32 num_lanes;
+ 
+ 	port->pcie = pcie;
+ 
+@@ -998,6 +1012,9 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 	if (of_property_read_u32(child, "marvell,pcie-lane", &port->lane))
+ 		port->lane = 0;
+ 
++	if (!of_property_read_u32(child, "num-lanes", &num_lanes) && num_lanes == 4)
++		port->is_x4 = true;
++
+ 	port->name = devm_kasprintf(dev, GFP_KERNEL, "pcie%d.%d", port->port,
+ 				    port->lane);
+ 	if (!port->name) {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0029-PCI-mvebu-Add-support-for-PCI-Bridge-Subsystem-Vendo.patch b/target/linux/generic/pending-5.15/0029-PCI-mvebu-Add-support-for-PCI-Bridge-Subsystem-Vendo.patch
new file mode 100644
index 0000000000..7f264763fd
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0029-PCI-mvebu-Add-support-for-PCI-Bridge-Subsystem-Vendo.patch
@@ -0,0 +1,53 @@
+From 1192a8856544109e30555ca15aed7353297bae79 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 8 Oct 2021 11:47:35 +0200
+Subject: [PATCH 29/90] PCI: mvebu: Add support for PCI Bridge Subsystem Vendor
+ ID on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Register with Subsystem Device/Vendor ID is at offset 0x2c. Export is via
+emulated bridge.
+
+After this change Subsystem ID is visible in lspci output at line:
+
+  Capabilities: [40] Subsystem
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 0f2ec0a17874..811af9e6ede5 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -32,6 +32,7 @@
+ #define PCIE_DEV_REV_OFF	0x0008
+ #define PCIE_BAR_LO_OFF(n)	(0x0010 + ((n) << 3))
+ #define PCIE_BAR_HI_OFF(n)	(0x0014 + ((n) << 3))
++#define PCIE_SSDEV_ID_OFF	0x002c
+ #define PCIE_CAP_PCIEXP		0x0060
+ #define PCIE_HEADER_LOG_4_OFF	0x0128
+ #define PCIE_BAR_CTRL_OFF(n)	(0x1804 + (((n) - 1) * 4))
+@@ -731,6 +732,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	struct pci_bridge_emul *bridge = &port->bridge;
+ 	u32 dev_id = mvebu_readl(port, PCIE_DEV_ID_OFF);
+ 	u32 dev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);
++	u32 ssdev_id = mvebu_readl(port, PCIE_SSDEV_ID_OFF);
+ 	u32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP);
+ 	u8 pcie_cap_ver = ((pcie_cap >> 16) & PCI_EXP_FLAGS_VERS);
+ 
+@@ -752,6 +754,8 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	 */
+ 	bridge->pcie_conf.cap = cpu_to_le16(pcie_cap_ver);
+ 
++	bridge->subsystem_vendor_id = ssdev_id & 0xffff;
++	bridge->subsystem_id = ssdev_id >> 16;
+ 	bridge->has_pcie = true;
+ 	bridge->data = port;
+ 	bridge->ops = &mvebu_pci_bridge_emul_ops;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0030-PCI-mvebu-Add-support-for-Advanced-Error-Reporting-r.patch b/target/linux/generic/pending-5.15/0030-PCI-mvebu-Add-support-for-Advanced-Error-Reporting-r.patch
new file mode 100644
index 0000000000..fb806e5349
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0030-PCI-mvebu-Add-support-for-Advanced-Error-Reporting-r.patch
@@ -0,0 +1,125 @@
+From 6ccfcdf4eef16aaac2bddc3b625a2dabe357bcb1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 13:46:44 +0200
+Subject: [PATCH 30/90] PCI: mvebu: Add support for Advanced Error Reporting
+ registers on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+AER registers start at mvebu offset 0x0100. Registers PCI_ERR_ROOT_COMMAND,
+PCI_ERR_ROOT_STATUS and PCI_ERR_ROOT_ERR_SRC are not supported on pre-XP
+hardware and returns zeros.
+
+Note that AER interrupt is not supported yet as mvebu emulated bridge does
+not implement interrupts support at all yet.
+
+Also remove custom macro PCIE_HEADER_LOG_4_OFF as it is unused and
+correctly this register should be referenced via standard macros with
+offset, e.g. as: PCIE_CAP_PCIERR_OFF + PCI_ERR_HEADER_LOG + 4.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 67 +++++++++++++++++++++++++++++-
+ 1 file changed, 66 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 811af9e6ede5..9ea2f6a7c2b0 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -34,7 +34,7 @@
+ #define PCIE_BAR_HI_OFF(n)	(0x0014 + ((n) << 3))
+ #define PCIE_SSDEV_ID_OFF	0x002c
+ #define PCIE_CAP_PCIEXP		0x0060
+-#define PCIE_HEADER_LOG_4_OFF	0x0128
++#define PCIE_CAP_PCIERR_OFF	0x0100
+ #define PCIE_BAR_CTRL_OFF(n)	(0x1804 + (((n) - 1) * 4))
+ #define PCIE_WIN04_CTRL_OFF(n)	(0x1820 + ((n) << 4))
+ #define PCIE_WIN04_BASE_OFF(n)	(0x1824 + ((n) << 4))
+@@ -603,6 +603,37 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 	return PCI_BRIDGE_EMUL_HANDLED;
+ }
+ 
++static pci_bridge_emul_read_status_t
++mvebu_pci_bridge_emul_ext_conf_read(struct pci_bridge_emul *bridge,
++				    int reg, u32 *value)
++{
++	struct mvebu_pcie_port *port = bridge->data;
++
++	switch (reg) {
++	case 0:
++	case PCI_ERR_UNCOR_STATUS:
++	case PCI_ERR_UNCOR_MASK:
++	case PCI_ERR_UNCOR_SEVER:
++	case PCI_ERR_COR_STATUS:
++	case PCI_ERR_COR_MASK:
++	case PCI_ERR_CAP:
++	case PCI_ERR_HEADER_LOG+0:
++	case PCI_ERR_HEADER_LOG+4:
++	case PCI_ERR_HEADER_LOG+8:
++	case PCI_ERR_HEADER_LOG+12:
++	case PCI_ERR_ROOT_COMMAND:
++	case PCI_ERR_ROOT_STATUS:
++	case PCI_ERR_ROOT_ERR_SRC:
++		*value = mvebu_readl(port, PCIE_CAP_PCIERR_OFF + reg);
++		break;
++
++	default:
++		return PCI_BRIDGE_EMUL_NOT_HANDLED;
++	}
++
++	return PCI_BRIDGE_EMUL_HANDLED;
++}
++
+ static void
+ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 				      int reg, u32 old, u32 new, u32 mask)
+@@ -715,11 +746,45 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 	}
+ }
+ 
++static void
++mvebu_pci_bridge_emul_ext_conf_write(struct pci_bridge_emul *bridge,
++				     int reg, u32 old, u32 new, u32 mask)
++{
++	struct mvebu_pcie_port *port = bridge->data;
++
++	switch (reg) {
++	/* These are W1C registers, so clear other bits */
++	case PCI_ERR_UNCOR_STATUS:
++	case PCI_ERR_COR_STATUS:
++	case PCI_ERR_ROOT_STATUS:
++		new &= mask;
++		fallthrough;
++
++	case PCI_ERR_UNCOR_MASK:
++	case PCI_ERR_UNCOR_SEVER:
++	case PCI_ERR_COR_MASK:
++	case PCI_ERR_CAP:
++	case PCI_ERR_HEADER_LOG+0:
++	case PCI_ERR_HEADER_LOG+4:
++	case PCI_ERR_HEADER_LOG+8:
++	case PCI_ERR_HEADER_LOG+12:
++	case PCI_ERR_ROOT_COMMAND:
++	case PCI_ERR_ROOT_ERR_SRC:
++		mvebu_writel(port, new, PCIE_CAP_PCIERR_OFF + reg);
++		break;
++
++	default:
++		break;
++	}
++}
++
+ static const struct pci_bridge_emul_ops mvebu_pci_bridge_emul_ops = {
+ 	.read_base = mvebu_pci_bridge_emul_base_conf_read,
+ 	.write_base = mvebu_pci_bridge_emul_base_conf_write,
+ 	.read_pcie = mvebu_pci_bridge_emul_pcie_conf_read,
+ 	.write_pcie = mvebu_pci_bridge_emul_pcie_conf_write,
++	.read_ext = mvebu_pci_bridge_emul_ext_conf_read,
++	.write_ext = mvebu_pci_bridge_emul_ext_conf_write,
+ };
+ 
+ /*
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0031-PCI-mvebu-Use-child_ops-API.patch b/target/linux/generic/pending-5.15/0031-PCI-mvebu-Use-child_ops-API.patch
new file mode 100644
index 0000000000..41d74306e9
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0031-PCI-mvebu-Use-child_ops-API.patch
@@ -0,0 +1,165 @@
+From a32d68b41dac1a1aeab94a2c8b2239534ac59c15 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 16 Nov 2021 10:43:17 +0100
+Subject: [PATCH 31/90] PCI: mvebu: Use child_ops API
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Split struct pci_ops between ops and child_ops. Member ops is used for
+accessing PCIe Root Ports via pci-bridge-emul.c driver and child_ops for
+accessing real PCIe cards.
+
+There is no need to mix these two struct pci_ops into one as PCI core code
+already provides separate callbacks via bridge->ops and bridge->child_ops.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 82 ++++++++++++++++--------------
+ 1 file changed, 44 insertions(+), 38 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 9ea2f6a7c2b0..1e90ab888075 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -294,11 +294,29 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	mvebu_writel(port, mask, PCIE_MASK_OFF);
+ }
+ 
+-static int mvebu_pcie_hw_rd_conf(struct mvebu_pcie_port *port,
+-				 struct pci_bus *bus,
+-				 u32 devfn, int where, int size, u32 *val)
++static struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,
++						    struct pci_bus *bus,
++						    int devfn);
++
++static int mvebu_pcie_child_rd_conf(struct pci_bus *bus, u32 devfn, int where,
++				    int size, u32 *val)
+ {
+-	void __iomem *conf_data = port->base + PCIE_CONF_DATA_OFF;
++	struct mvebu_pcie *pcie = bus->sysdata;
++	struct mvebu_pcie_port *port;
++	void __iomem *conf_data;
++
++	port = mvebu_pcie_find_port(pcie, bus, devfn);
++	if (!port) {
++		*val = 0xffffffff;
++		return PCIBIOS_DEVICE_NOT_FOUND;
++	}
++
++	if (!mvebu_pcie_link_up(port)) {
++		*val = 0xffffffff;
++		return PCIBIOS_DEVICE_NOT_FOUND;
++	}
++
++	conf_data = port->base + PCIE_CONF_DATA_OFF;
+ 
+ 	mvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),
+ 		     PCIE_CONF_ADDR_OFF);
+@@ -321,11 +339,21 @@ static int mvebu_pcie_hw_rd_conf(struct mvebu_pcie_port *port,
+ 	return PCIBIOS_SUCCESSFUL;
+ }
+ 
+-static int mvebu_pcie_hw_wr_conf(struct mvebu_pcie_port *port,
+-				 struct pci_bus *bus,
+-				 u32 devfn, int where, int size, u32 val)
++static int mvebu_pcie_child_wr_conf(struct pci_bus *bus, u32 devfn,
++				    int where, int size, u32 val)
+ {
+-	void __iomem *conf_data = port->base + PCIE_CONF_DATA_OFF;
++	struct mvebu_pcie *pcie = bus->sysdata;
++	struct mvebu_pcie_port *port;
++	void __iomem *conf_data;
++
++	port = mvebu_pcie_find_port(pcie, bus, devfn);
++	if (!port)
++		return PCIBIOS_DEVICE_NOT_FOUND;
++
++	if (!mvebu_pcie_link_up(port))
++		return PCIBIOS_DEVICE_NOT_FOUND;
++
++	conf_data = port->base + PCIE_CONF_DATA_OFF;
+ 
+ 	mvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),
+ 		     PCIE_CONF_ADDR_OFF);
+@@ -347,6 +375,11 @@ static int mvebu_pcie_hw_wr_conf(struct mvebu_pcie_port *port,
+ 	return PCIBIOS_SUCCESSFUL;
+ }
+ 
++static struct pci_ops mvebu_pcie_child_ops = {
++	.read = mvebu_pcie_child_rd_conf,
++	.write = mvebu_pcie_child_wr_conf,
++};
++
+ /*
+  * Remove windows, starting from the largest ones to the smallest
+  * ones.
+@@ -862,25 +895,12 @@ static int mvebu_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+ {
+ 	struct mvebu_pcie *pcie = bus->sysdata;
+ 	struct mvebu_pcie_port *port;
+-	int ret;
+ 
+ 	port = mvebu_pcie_find_port(pcie, bus, devfn);
+ 	if (!port)
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 
+-	/* Access the emulated PCI-to-PCI bridge */
+-	if (bus->number == 0)
+-		return pci_bridge_emul_conf_write(&port->bridge, where,
+-						  size, val);
+-
+-	if (!mvebu_pcie_link_up(port))
+-		return PCIBIOS_DEVICE_NOT_FOUND;
+-
+-	/* Access the real PCIe interface */
+-	ret = mvebu_pcie_hw_wr_conf(port, bus, devfn,
+-				    where, size, val);
+-
+-	return ret;
++	return pci_bridge_emul_conf_write(&port->bridge, where, size, val);
+ }
+ 
+ /* PCI configuration space read function */
+@@ -889,7 +909,6 @@ static int mvebu_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+ {
+ 	struct mvebu_pcie *pcie = bus->sysdata;
+ 	struct mvebu_pcie_port *port;
+-	int ret;
+ 
+ 	port = mvebu_pcie_find_port(pcie, bus, devfn);
+ 	if (!port) {
+@@ -897,21 +916,7 @@ static int mvebu_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+ 		return PCIBIOS_DEVICE_NOT_FOUND;
+ 	}
+ 
+-	/* Access the emulated PCI-to-PCI bridge */
+-	if (bus->number == 0)
+-		return pci_bridge_emul_conf_read(&port->bridge, where,
+-						 size, val);
+-
+-	if (!mvebu_pcie_link_up(port)) {
+-		*val = 0xffffffff;
+-		return PCIBIOS_DEVICE_NOT_FOUND;
+-	}
+-
+-	/* Access the real PCIe interface */
+-	ret = mvebu_pcie_hw_rd_conf(port, bus, devfn,
+-				    where, size, val);
+-
+-	return ret;
++	return pci_bridge_emul_conf_read(&port->bridge, where, size, val);
+ }
+ 
+ static struct pci_ops mvebu_pcie_ops = {
+@@ -1421,6 +1426,7 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 
+ 	bridge->sysdata = pcie;
+ 	bridge->ops = &mvebu_pcie_ops;
++	bridge->child_ops = &mvebu_pcie_child_ops;
+ 	bridge->align_resource = mvebu_pcie_align_resource;
+ 	bridge->map_irq = mvebu_pcie_map_irq;
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0032-dt-bindings-PCI-mvebu-Update-information-about-intx-.patch b/target/linux/generic/pending-5.15/0032-dt-bindings-PCI-mvebu-Update-information-about-intx-.patch
new file mode 100644
index 0000000000..9e7102037a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0032-dt-bindings-PCI-mvebu-Update-information-about-intx-.patch
@@ -0,0 +1,34 @@
+From 3ef4b961298bb64ba871616f51a0d869cb7c4555 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:43:39 +0200
+Subject: [PATCH 32/90] dt-bindings: PCI: mvebu: Update information about intx
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Rob Herring <robh@kernel.org>
+---
+ Documentation/devicetree/bindings/pci/mvebu-pci.txt | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/Documentation/devicetree/bindings/pci/mvebu-pci.txt b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+index 24225852bce0..6d022a9d36ee 100644
+--- a/Documentation/devicetree/bindings/pci/mvebu-pci.txt
++++ b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+@@ -81,6 +81,11 @@ and the following optional properties:
+ - reset-gpios: optional GPIO to PERST#
+ - reset-delay-us: delay in us to wait after reset de-assertion, if not
+   specified will default to 100ms, as required by the PCIe specification.
++- interrupt-names: list of interrupt names, supported are:
++   - "intx" - interrupt line triggered by one of the legacy interrupt
++- interrupts or interrupts-extended: List of the interrupt sources which
++  corresponding to the "interrupt-names". If non-empty then also additional
++  'interrupt-controller' subnode must be defined.
+ 
+ Example:
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0033-PCI-mvebu-Fix-macro-names-and-comments-about-legacy-.patch b/target/linux/generic/pending-5.15/0033-PCI-mvebu-Fix-macro-names-and-comments-about-legacy-.patch
new file mode 100644
index 0000000000..185b1c22f7
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0033-PCI-mvebu-Fix-macro-names-and-comments-about-legacy-.patch
@@ -0,0 +1,79 @@
+From 8fa82d166233f0c6b4ec82b4b92dbb356cd69675 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 14 Feb 2022 13:12:48 +0100
+Subject: [PATCH 33/90] PCI: mvebu: Fix macro names and comments about legacy
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Register 0x1910 unmasks interrupts and legacy INTx interrupts are unmasked
+because driver does not support individual masking yet.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 26 ++++++++++++++++++--------
+ 1 file changed, 18 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 1e90ab888075..5f8b8b4ddbea 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -54,9 +54,10 @@
+ 	 PCIE_CONF_ADDR_EN)
+ #define PCIE_CONF_DATA_OFF	0x18fc
+ #define PCIE_INT_CAUSE_OFF	0x1900
++#define PCIE_INT_UNMASK_OFF	0x1910
++#define  PCIE_INT_INTX(i)		BIT(24+i)
+ #define  PCIE_INT_PM_PME		BIT(28)
+-#define PCIE_MASK_OFF		0x1910
+-#define  PCIE_MASK_ENABLE_INTS          0x0f000000
++#define  PCIE_INT_ALL_MASK		GENMASK(31, 0)
+ #define PCIE_CTRL_OFF		0x1a00
+ #define  PCIE_CTRL_X1_MODE		0x0001
+ #define  PCIE_CTRL_RC_MODE		BIT(1)
+@@ -235,7 +236,7 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
+ 
+ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ {
+-	u32 ctrl, lnkcap, cmd, dev_rev, mask;
++	u32 ctrl, lnkcap, cmd, dev_rev, unmask;
+ 
+ 	/* Setup PCIe controller to Root Complex mode. */
+ 	ctrl = mvebu_readl(port, PCIE_CTRL_OFF);
+@@ -288,10 +289,19 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	/* Point PCIe unit MBUS decode windows to DRAM space. */
+ 	mvebu_pcie_setup_wins(port);
+ 
+-	/* Enable interrupt lines A-D. */
+-	mask = mvebu_readl(port, PCIE_MASK_OFF);
+-	mask |= PCIE_MASK_ENABLE_INTS;
+-	mvebu_writel(port, mask, PCIE_MASK_OFF);
++	/*
++	 * Unmask all legacy INTx interrupts as driver does not provide a way
++	 * for masking and unmasking of individual legacy INTx interrupts.
++	 * Legacy INTx are reported via one shared GIC source and therefore
++	 * kernel cannot distinguish which individual legacy INTx was triggered.
++	 * These interrupts are shared, so it should not cause any issue. Just
++	 * performance penalty as every PCIe interrupt handler needs to be
++	 * called when some interrupt is triggered.
++	 */
++	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++	unmask |= PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |
++		  PCIE_INT_INTX(2) | PCIE_INT_INTX(3);
++	mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
+ }
+ 
+ static struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,
+@@ -1458,7 +1468,7 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 		mvebu_writel(port, cmd, PCIE_CMD_OFF);
+ 
+ 		/* Mask all interrupt sources. */
+-		mvebu_writel(port, 0, PCIE_MASK_OFF);
++		mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);
+ 
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0034-PCI-mvebu-Implement-support-for-legacy-INTx-interrup.patch b/target/linux/generic/pending-5.15/0034-PCI-mvebu-Implement-support-for-legacy-INTx-interrup.patch
new file mode 100644
index 0000000000..d02a2c4c9a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0034-PCI-mvebu-Implement-support-for-legacy-INTx-interrup.patch
@@ -0,0 +1,251 @@
+From 09e38b818e55358009d7c20aeddb7c59f0b3a3e1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 2 Nov 2021 10:30:20 +0100
+Subject: [PATCH 34/90] PCI: mvebu: Implement support for legacy INTx
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for legacy INTx interrupts received from other PCIe
+devices and which are reported by a new INTx irq chip.
+
+With this change, kernel can distinguish between INTA, INTB, INTC and INTD
+interrupts.
+
+Note that for this support, device tree files has to be properly adjusted
+to provide "interrupts" or "interrupts-extended" property with intx
+interrupt source, "interrupt-names" property with "intx" string and also
+'interrupt-controller' subnode must be defined.
+
+If device tree files do not provide these nodes then driver would work as
+before.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 159 +++++++++++++++++++++++++++++
+ 1 file changed, 159 insertions(+)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 5f8b8b4ddbea..c9311829dfe3 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -111,6 +111,9 @@ struct mvebu_pcie_port {
+ 	struct mvebu_pcie_window iowin;
+ 	u32 saved_pcie_stat;
+ 	struct resource regs;
++	struct irq_domain *intx_irq_domain;
++	raw_spinlock_t irq_lock;
++	int intx_irq;
+ };
+ 
+ static inline void mvebu_writel(struct mvebu_pcie_port *port, u32 val, u32 reg)
+@@ -289,7 +292,18 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	/* Point PCIe unit MBUS decode windows to DRAM space. */
+ 	mvebu_pcie_setup_wins(port);
+ 
++	/* Mask all interrupt sources. */
++	mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);
++
++	/* Clear all interrupt causes. */
++	mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);
++
++	/* Check if "intx" interrupt was specified in DT. */
++	if (port->intx_irq > 0)
++		return;
++
+ 	/*
++	 * Fallback code when "intx" interrupt was not specified in DT:
+ 	 * Unmask all legacy INTx interrupts as driver does not provide a way
+ 	 * for masking and unmasking of individual legacy INTx interrupts.
+ 	 * Legacy INTx are reported via one shared GIC source and therefore
+@@ -934,6 +948,108 @@ static struct pci_ops mvebu_pcie_ops = {
+ 	.write = mvebu_pcie_wr_conf,
+ };
+ 
++static void mvebu_pcie_intx_irq_mask(struct irq_data *d)
++{
++	struct mvebu_pcie_port *port = d->domain->host_data;
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	unsigned long flags;
++	u32 unmask;
++
++	raw_spin_lock_irqsave(&port->irq_lock, flags);
++	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++	unmask &= ~PCIE_INT_INTX(hwirq);
++	mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	raw_spin_unlock_irqrestore(&port->irq_lock, flags);
++}
++
++static void mvebu_pcie_intx_irq_unmask(struct irq_data *d)
++{
++	struct mvebu_pcie_port *port = d->domain->host_data;
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	unsigned long flags;
++	u32 unmask;
++
++	raw_spin_lock_irqsave(&port->irq_lock, flags);
++	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++	unmask |= PCIE_INT_INTX(hwirq);
++	mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	raw_spin_unlock_irqrestore(&port->irq_lock, flags);
++}
++
++static struct irq_chip intx_irq_chip = {
++	.name = "mvebu-INTx",
++	.irq_mask = mvebu_pcie_intx_irq_mask,
++	.irq_unmask = mvebu_pcie_intx_irq_unmask,
++};
++
++static int mvebu_pcie_intx_irq_map(struct irq_domain *h,
++				   unsigned int virq, irq_hw_number_t hwirq)
++{
++	struct mvebu_pcie_port *port = h->host_data;
++
++	irq_set_status_flags(virq, IRQ_LEVEL);
++	irq_set_chip_and_handler(virq, &intx_irq_chip, handle_level_irq);
++	irq_set_chip_data(virq, port);
++
++	return 0;
++}
++
++static const struct irq_domain_ops mvebu_pcie_intx_irq_domain_ops = {
++	.map = mvebu_pcie_intx_irq_map,
++	.xlate = irq_domain_xlate_onecell,
++};
++
++static int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)
++{
++	struct device *dev = &port->pcie->pdev->dev;
++	struct device_node *pcie_intc_node;
++
++	raw_spin_lock_init(&port->irq_lock);
++
++	pcie_intc_node = of_get_next_child(port->dn, NULL);
++	if (!pcie_intc_node) {
++		dev_err(dev, "No PCIe Intc node found for %s\n", port->name);
++		return -ENODEV;
++	}
++
++	port->intx_irq_domain = irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,
++						      &mvebu_pcie_intx_irq_domain_ops,
++						      port);
++	of_node_put(pcie_intc_node);
++	if (!port->intx_irq_domain) {
++		dev_err(dev, "Failed to get INTx IRQ domain for %s\n", port->name);
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
++static void mvebu_pcie_irq_handler(struct irq_desc *desc)
++{
++	struct mvebu_pcie_port *port = irq_desc_get_handler_data(desc);
++	struct irq_chip *chip = irq_desc_get_chip(desc);
++	struct device *dev = &port->pcie->pdev->dev;
++	u32 cause, unmask, status;
++	int i;
++
++	chained_irq_enter(chip, desc);
++
++	cause = mvebu_readl(port, PCIE_INT_CAUSE_OFF);
++	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++	status = cause & unmask;
++
++	/* Process legacy INTx interrupts */
++	for (i = 0; i < PCI_NUM_INTX; i++) {
++		if (!(status & PCIE_INT_INTX(i)))
++			continue;
++
++		if (generic_handle_domain_irq(port->intx_irq_domain, i) == -EINVAL)
++			dev_err_ratelimited(dev, "unexpected INT%c IRQ\n", (char)i+'A');
++	}
++
++	chained_irq_exit(chip, desc);
++}
++
+ static int mvebu_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+ {
+ 	/* Interrupt support on mvebu emulated bridges is not implemented yet */
+@@ -1131,6 +1247,21 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 		port->io_attr = -1;
+ 	}
+ 
++	/*
++	 * Old DT bindings do not contain "intx" interrupt
++	 * so do not fail probing driver when interrupt does not exist.
++	 */
++	port->intx_irq = of_irq_get_byname(child, "intx");
++	if (port->intx_irq == -EPROBE_DEFER) {
++		ret = port->intx_irq;
++		goto err;
++	}
++	if (port->intx_irq <= 0) {
++		dev_warn(dev, "%s: legacy INTx interrupts cannot be masked individually, "
++			      "%pOF does not contain intx interrupt\n",
++			 port->name, child);
++	}
++
+ 	reset_gpio = of_get_named_gpio_flags(child, "reset-gpios", 0, &flags);
+ 	if (reset_gpio == -EPROBE_DEFER) {
+ 		ret = reset_gpio;
+@@ -1327,6 +1458,7 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = &pcie->ports[i];
++		int irq = port->intx_irq;
+ 
+ 		child = port->dn;
+ 		if (!child)
+@@ -1354,6 +1486,22 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 			continue;
+ 		}
+ 
++		if (irq > 0) {
++			ret = mvebu_pcie_init_irq_domain(port);
++			if (ret) {
++				dev_err(dev, "%s: cannot init irq domain\n",
++					port->name);
++				pci_bridge_emul_cleanup(&port->bridge);
++				devm_iounmap(dev, port->base);
++				port->base = NULL;
++				mvebu_pcie_powerdown(port);
++				continue;
++			}
++			irq_set_chained_handler_and_data(irq,
++							 mvebu_pcie_irq_handler,
++							 port);
++		}
++
+ 		/*
+ 		 * PCIe topology exported by mvebu hw is quite complicated. In
+ 		 * reality has something like N fully independent host bridges
+@@ -1458,6 +1606,7 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = &pcie->ports[i];
++		int irq = port->intx_irq;
+ 
+ 		if (!port->base)
+ 			continue;
+@@ -1470,6 +1619,16 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 		/* Mask all interrupt sources. */
+ 		mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);
+ 
++		/* Clear all interrupt causes. */
++		mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);
++
++		if (irq > 0)
++			irq_set_chained_handler_and_data(irq, NULL, NULL);
++
++		/* Remove IRQ domains. */
++		if (port->intx_irq_domain)
++			irq_domain_remove(port->intx_irq_domain);
++
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0035-ARM-dts-kirkwood-Add-definitions-for-PCIe-legacy-INT.patch b/target/linux/generic/pending-5.15/0035-ARM-dts-kirkwood-Add-definitions-for-PCIe-legacy-INT.patch
new file mode 100644
index 0000000000..5f72bc4b85
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0035-ARM-dts-kirkwood-Add-definitions-for-PCIe-legacy-INT.patch
@@ -0,0 +1,161 @@
+From 17c0e92f81db8b06c2fccc47da25bc14af58e03c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:14:33 +0200
+Subject: [PATCH 35/90] ARM: dts: kirkwood: Add definitions for PCIe legacy
+ INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/kirkwood-6192.dtsi     | 14 ++++++++++--
+ arch/arm/boot/dts/kirkwood-6281.dtsi     | 14 ++++++++++--
+ arch/arm/boot/dts/kirkwood-6282.dtsi     | 28 ++++++++++++++++++++----
+ arch/arm/boot/dts/kirkwood-98dx4122.dtsi | 14 ++++++++++--
+ 4 files changed, 60 insertions(+), 10 deletions(-)
+
+diff --git a/arch/arm/boot/dts/kirkwood-6192.dtsi b/arch/arm/boot/dts/kirkwood-6192.dtsi
+index 396bcba08adb..07f4f7f98c0c 100644
+--- a/arch/arm/boot/dts/kirkwood-6192.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6192.dtsi
+@@ -26,12 +26,22 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 9>;
++				interrupt-names = "intx";
++				interrupts = <9>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie_intc 0>,
++						<0 0 0 2 &pcie_intc 1>,
++						<0 0 0 3 &pcie_intc 2>,
++						<0 0 0 4 &pcie_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gate_clk 2>;
+ 				status = "disabled";
++
++				pcie_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+diff --git a/arch/arm/boot/dts/kirkwood-6281.dtsi b/arch/arm/boot/dts/kirkwood-6281.dtsi
+index faa05849a40d..d08a9a5ecc26 100644
+--- a/arch/arm/boot/dts/kirkwood-6281.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6281.dtsi
+@@ -26,12 +26,22 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 9>;
++				interrupt-names = "intx";
++				interrupts = <9>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie_intc 0>,
++						<0 0 0 2 &pcie_intc 1>,
++						<0 0 0 3 &pcie_intc 2>,
++						<0 0 0 4 &pcie_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gate_clk 2>;
+ 				status = "disabled";
++
++				pcie_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+diff --git a/arch/arm/boot/dts/kirkwood-6282.dtsi b/arch/arm/boot/dts/kirkwood-6282.dtsi
+index e84c54b77dea..2eea5b304f47 100644
+--- a/arch/arm/boot/dts/kirkwood-6282.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6282.dtsi
+@@ -30,12 +30,22 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 9>;
++				interrupt-names = "intx";
++				interrupts = <9>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
++						<0 0 0 2 &pcie0_intc 1>,
++						<0 0 0 3 &pcie0_intc 2>,
++						<0 0 0 4 &pcie0_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gate_clk 2>;
+ 				status = "disabled";
++
++				pcie0_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie1: pcie@2,0 {
+@@ -48,12 +58,22 @@ pcie1: pcie@2,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 10>;
++				interrupt-names = "intx";
++				interrupts = <10>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gate_clk 18>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+diff --git a/arch/arm/boot/dts/kirkwood-98dx4122.dtsi b/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
+index 299c147298c3..070bc13242b8 100644
+--- a/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
++++ b/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
+@@ -26,12 +26,22 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 9>;
++				interrupt-names = "intx";
++				interrupts = <9>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie_intc 0>,
++						<0 0 0 2 &pcie_intc 1>,
++						<0 0 0 3 &pcie_intc 2>,
++						<0 0 0 4 &pcie_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gate_clk 2>;
+ 				status = "disabled";
++
++				pcie_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0036-ARM-dts-dove-Add-definitions-for-PCIe-legacy-INTx-in.patch b/target/linux/generic/pending-5.15/0036-ARM-dts-dove-Add-definitions-for-PCIe-legacy-INTx-in.patch
new file mode 100644
index 0000000000..fd511e553b
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0036-ARM-dts-dove-Add-definitions-for-PCIe-legacy-INTx-in.patch
@@ -0,0 +1,63 @@
+From bec69dde1c0cbabc5a35d32af0ff3d6dbb4e4fec Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:17:27 +0200
+Subject: [PATCH 36/90] ARM: dts: dove: Add definitions for PCIe legacy INTx
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/dove.dtsi | 28 ++++++++++++++++++++++++----
+ 1 file changed, 24 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi
+index 89e0bdaf3a85..96ba47c061a7 100644
+--- a/arch/arm/boot/dts/dove.dtsi
++++ b/arch/arm/boot/dts/dove.dtsi
+@@ -122,8 +122,18 @@ pcie0: pcie@1 {
+ 				bus-range = <0x00 0xff>;
+ 
+ 				#interrupt-cells = <1>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 16>;
++				interrupt-names = "intx";
++				interrupts = <16>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
++						<0 0 0 2 &pcie0_intc 1>,
++						<0 0 0 3 &pcie0_intc 2>,
++						<0 0 0 4 &pcie0_intc 3>;
++
++				pcie0_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie1: pcie@2 {
+@@ -141,8 +151,18 @@ pcie1: pcie@2 {
+ 				bus-range = <0x00 0xff>;
+ 
+ 				#interrupt-cells = <1>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &intc 18>;
++				interrupt-names = "intx";
++				interrupts = <18>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0037-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-leg.patch b/target/linux/generic/pending-5.15/0037-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-leg.patch
new file mode 100644
index 0000000000..02d4717b23
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0037-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-leg.patch
@@ -0,0 +1,79 @@
+From 19977423f7549278ed5f4fae7f171d96c31f5817 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:24:58 +0200
+Subject: [PATCH 37/90] ARM: dts: armada-370.dtsi: Add definitions for PCIe
+ legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-370.dtsi | 28 ++++++++++++++++++++++++----
+ 1 file changed, 24 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-370.dtsi b/arch/arm/boot/dts/armada-370.dtsi
+index 46e6d3ed8f35..9dc928859ad3 100644
+--- a/arch/arm/boot/dts/armada-370.dtsi
++++ b/arch/arm/boot/dts/armada-370.dtsi
+@@ -60,16 +60,26 @@ pcie0: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 58>;
+ 				#interrupt-cells = <1>;
+                                 ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+                                           0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 58>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
++						<0 0 0 2 &pcie0_intc 1>,
++						<0 0 0 3 &pcie0_intc 2>,
++						<0 0 0 4 &pcie0_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie0_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie2: pcie@2,0 {
+@@ -78,16 +88,26 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 62>;
+ 				#interrupt-cells = <1>;
+                                 ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+                                           0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 62>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 9>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0038-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch b/target/linux/generic/pending-5.15/0038-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
new file mode 100644
index 0000000000..f2dfbae634
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0038-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
@@ -0,0 +1,50 @@
+From c1c851bad2eb2c04a24f80dca20bfeb69d8263f3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:02:23 +0200
+Subject: [PATCH 38/90] ARM: dts: armada-xp-98dx3236.dtsi: Add definitions for
+ PCIe legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-98dx3236.dtsi | 14 ++++++++++++--
+ 1 file changed, 12 insertions(+), 2 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-98dx3236.dtsi b/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
+index 38a052a0312d..b21ffb819b1d 100644
+--- a/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
++++ b/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
+@@ -76,16 +76,26 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 58>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 58>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0039-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0039-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..a6a60a5650
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0039-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,166 @@
+From 7cf39d981b03d76923f797115dabbf8d8db9bd74 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 19:26:59 +0200
+Subject: [PATCH 39/90] ARM: dts: armada-xp-mv78230.dtsi: Add definitions for
+ PCIe legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78230.dtsi | 70 ++++++++++++++++++++----
+ 1 file changed, 60 insertions(+), 10 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78230.dtsi b/arch/arm/boot/dts/armada-xp-mv78230.dtsi
+index 8558bf6bb54c..bf9360f41e0a 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78230.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78230.dtsi
+@@ -83,16 +83,26 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 58>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 58>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie2: pcie@2,0 {
+@@ -101,16 +111,26 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 59>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 59>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie3: pcie@3,0 {
+@@ -119,16 +139,26 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 60>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 60>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <2>;
+ 				clocks = <&gateclk 7>;
+ 				status = "disabled";
++
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie4: pcie@4,0 {
+@@ -137,16 +167,26 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 61>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 61>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie4_intc 0>,
++						<0 0 0 2 &pcie4_intc 1>,
++						<0 0 0 3 &pcie4_intc 2>,
++						<0 0 0 4 &pcie4_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <3>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++
++				pcie4_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie5: pcie@5,0 {
+@@ -155,16 +195,26 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 62>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 62>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie5_intc 0>,
++						<0 0 0 2 &pcie5_intc 1>,
++						<0 0 0 3 &pcie5_intc 2>,
++						<0 0 0 4 &pcie5_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 9>;
+ 				status = "disabled";
++
++				pcie5_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0040-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0040-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..9ac3d91232
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0040-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,282 @@
+From 4c45fc119653486c76c2931cd4cfb05c4770f1e8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 19:54:06 +0200
+Subject: [PATCH 40/90] ARM: dts: armada-xp-mv78260.dtsi: Add definitions for
+ PCIe legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78260.dtsi | 126 +++++++++++++++++++----
+ 1 file changed, 108 insertions(+), 18 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78260.dtsi b/arch/arm/boot/dts/armada-xp-mv78260.dtsi
+index 2d85fe8ac327..0714af52e607 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78260.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78260.dtsi
+@@ -98,16 +98,26 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 58>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 58>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie2: pcie@2,0 {
+@@ -116,16 +126,26 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 59>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 59>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie3: pcie@3,0 {
+@@ -134,16 +154,26 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 60>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 60>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <2>;
+ 				clocks = <&gateclk 7>;
+ 				status = "disabled";
++
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie4: pcie@4,0 {
+@@ -152,16 +182,26 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 61>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 61>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie4_intc 0>,
++						<0 0 0 2 &pcie4_intc 1>,
++						<0 0 0 3 &pcie4_intc 2>,
++						<0 0 0 4 &pcie4_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <3>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++
++				pcie4_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie5: pcie@5,0 {
+@@ -170,16 +210,26 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 62>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 62>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie5_intc 0>,
++						<0 0 0 2 &pcie5_intc 1>,
++						<0 0 0 3 &pcie5_intc 2>,
++						<0 0 0 4 &pcie5_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 9>;
+ 				status = "disabled";
++
++				pcie5_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie6: pcie@6,0 {
+@@ -188,16 +238,26 @@ pcie6: pcie@6,0 {
+ 				reg = <0x3000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 63>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x6 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x6 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 63>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie6_intc 0>,
++						<0 0 0 2 &pcie6_intc 1>,
++						<0 0 0 3 &pcie6_intc 2>,
++						<0 0 0 4 &pcie6_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 10>;
+ 				status = "disabled";
++
++				pcie6_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie7: pcie@7,0 {
+@@ -206,16 +266,26 @@ pcie7: pcie@7,0 {
+ 				reg = <0x3800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 64>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x7 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x7 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 64>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie7_intc 0>,
++						<0 0 0 2 &pcie7_intc 1>,
++						<0 0 0 3 &pcie7_intc 2>,
++						<0 0 0 4 &pcie7_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <2>;
+ 				clocks = <&gateclk 11>;
+ 				status = "disabled";
++
++				pcie7_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie8: pcie@8,0 {
+@@ -224,16 +294,26 @@ pcie8: pcie@8,0 {
+ 				reg = <0x4000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 65>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x8 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x8 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 65>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie8_intc 0>,
++						<0 0 0 2 &pcie8_intc 1>,
++						<0 0 0 3 &pcie8_intc 2>,
++						<0 0 0 4 &pcie8_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <3>;
+ 				clocks = <&gateclk 12>;
+ 				status = "disabled";
++
++				pcie8_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie9: pcie@9,0 {
+@@ -242,16 +322,26 @@ pcie9: pcie@9,0 {
+ 				reg = <0x4800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 99>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x9 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x9 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 99>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie9_intc 0>,
++						<0 0 0 2 &pcie9_intc 1>,
++						<0 0 0 3 &pcie9_intc 2>,
++						<0 0 0 4 &pcie9_intc 3>;
+ 				marvell,pcie-port = <2>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 26>;
+ 				status = "disabled";
++
++				pcie9_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0041-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0041-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..e987e420a9
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0041-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,311 @@
+From 7d19ddf1d053706976824ccc9153c2bd7caf4f94 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 19:58:06 +0200
+Subject: [PATCH 41/90] ARM: dts: armada-xp-mv78460.dtsi: Add definitions for
+ PCIe legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78460.dtsi | 140 +++++++++++++++++++----
+ 1 file changed, 120 insertions(+), 20 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78460.dtsi b/arch/arm/boot/dts/armada-xp-mv78460.dtsi
+index 230a3fd36b30..16185edf9aa5 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78460.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78460.dtsi
+@@ -119,16 +119,26 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 58>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 58>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie2: pcie@2,0 {
+@@ -137,16 +147,26 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 59>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 59>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie3: pcie@3,0 {
+@@ -155,16 +175,26 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 60>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 60>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <2>;
+ 				clocks = <&gateclk 7>;
+ 				status = "disabled";
++
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie4: pcie@4,0 {
+@@ -173,16 +203,26 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 61>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 61>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie4_intc 0>,
++						<0 0 0 2 &pcie4_intc 1>,
++						<0 0 0 3 &pcie4_intc 2>,
++						<0 0 0 4 &pcie4_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <3>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++
++				pcie4_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie5: pcie@5,0 {
+@@ -191,16 +231,26 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 62>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 62>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie5_intc 0>,
++						<0 0 0 2 &pcie5_intc 1>,
++						<0 0 0 3 &pcie5_intc 2>,
++						<0 0 0 4 &pcie5_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 9>;
+ 				status = "disabled";
++
++				pcie5_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie6: pcie@6,0 {
+@@ -209,16 +259,26 @@ pcie6: pcie@6,0 {
+ 				reg = <0x3000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 63>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x6 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x6 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 63>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie6_intc 0>,
++						<0 0 0 2 &pcie6_intc 1>,
++						<0 0 0 3 &pcie6_intc 2>,
++						<0 0 0 4 &pcie6_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 10>;
+ 				status = "disabled";
++
++				pcie6_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie7: pcie@7,0 {
+@@ -227,16 +287,26 @@ pcie7: pcie@7,0 {
+ 				reg = <0x3800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 64>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x7 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x7 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 64>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie7_intc 0>,
++						<0 0 0 2 &pcie7_intc 1>,
++						<0 0 0 3 &pcie7_intc 2>,
++						<0 0 0 4 &pcie7_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <2>;
+ 				clocks = <&gateclk 11>;
+ 				status = "disabled";
++
++				pcie7_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie8: pcie@8,0 {
+@@ -245,16 +315,26 @@ pcie8: pcie@8,0 {
+ 				reg = <0x4000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 65>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x8 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x8 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 65>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie8_intc 0>,
++						<0 0 0 2 &pcie8_intc 1>,
++						<0 0 0 3 &pcie8_intc 2>,
++						<0 0 0 4 &pcie8_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <3>;
+ 				clocks = <&gateclk 12>;
+ 				status = "disabled";
++
++				pcie8_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie9: pcie@9,0 {
+@@ -263,16 +343,26 @@ pcie9: pcie@9,0 {
+ 				reg = <0x4800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 99>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x9 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x9 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 99>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie9_intc 0>,
++						<0 0 0 2 &pcie9_intc 1>,
++						<0 0 0 3 &pcie9_intc 2>,
++						<0 0 0 4 &pcie9_intc 3>;
+ 				marvell,pcie-port = <2>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 26>;
+ 				status = "disabled";
++
++				pcie9_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie10: pcie@a,0 {
+@@ -281,16 +371,26 @@ pcie10: pcie@a,0 {
+ 				reg = <0x5000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&mpic 103>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0xa 0 1 0
+ 					  0x81000000 0 0 0x81000000 0xa 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &mpic 103>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie10_intc 0>,
++						<0 0 0 2 &pcie10_intc 1>,
++						<0 0 0 3 &pcie10_intc 2>,
++						<0 0 0 4 &pcie10_intc 3>;
+ 				marvell,pcie-port = <3>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 27>;
+ 				status = "disabled";
++
++				pcie10_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0042-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-leg.patch b/target/linux/generic/pending-5.15/0042-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-leg.patch
new file mode 100644
index 0000000000..0f5ce95cd2
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0042-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-leg.patch
@@ -0,0 +1,79 @@
+From d1655b563fd705b6a9bf25a37e85076716bb1c93 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:38:11 +0200
+Subject: [PATCH 42/90] ARM: dts: armada-375.dtsi: Add definitions for PCIe
+ legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-375.dtsi | 28 ++++++++++++++++++++++++----
+ 1 file changed, 24 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-375.dtsi b/arch/arm/boot/dts/armada-375.dtsi
+index 7f2f24a29e6c..929deaf312a5 100644
+--- a/arch/arm/boot/dts/armada-375.dtsi
++++ b/arch/arm/boot/dts/armada-375.dtsi
+@@ -568,16 +568,26 @@ pcie0: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
++						<0 0 0 2 &pcie0_intc 1>,
++						<0 0 0 3 &pcie0_intc 2>,
++						<0 0 0 4 &pcie0_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie0_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			pcie1: pcie@2,0 {
+@@ -586,16 +596,26 @@ pcie1: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <1>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 		};
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0043-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-leg.patch b/target/linux/generic/pending-5.15/0043-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-leg.patch
new file mode 100644
index 0000000000..319396c524
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0043-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-leg.patch
@@ -0,0 +1,108 @@
+From c13a941742f4496f0a73ccc9f1fcb535548d7067 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:39:06 +0200
+Subject: [PATCH 43/90] ARM: dts: armada-380.dtsi: Add definitions for PCIe
+ legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-380.dtsi | 42 ++++++++++++++++++++++++++-----
+ 1 file changed, 36 insertions(+), 6 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-380.dtsi b/arch/arm/boot/dts/armada-380.dtsi
+index cff1269f3fbf..ce1dddb2269b 100644
+--- a/arch/arm/boot/dts/armada-380.dtsi
++++ b/arch/arm/boot/dts/armada-380.dtsi
+@@ -64,16 +64,26 @@ pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -83,16 +93,26 @@ pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -102,16 +122,26 @@ pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <2>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0044-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-leg.patch b/target/linux/generic/pending-5.15/0044-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-leg.patch
new file mode 100644
index 0000000000..be96c7279c
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0044-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-leg.patch
@@ -0,0 +1,138 @@
+From 080d8811f806c957992baa43edffa2ec017be274 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:56:58 +0200
+Subject: [PATCH 44/90] ARM: dts: armada-385.dtsi: Add definitions for PCIe
+ legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+With this change legacy INTA, INTB, INTC and INTD interrupts are reported
+separately and not mixed into one Linux virq source anymore.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+Tested-by: Luis Mendes <luis.p.mendes@gmail.com>
+---
+ arch/arm/boot/dts/armada-385.dtsi | 52 ++++++++++++++++++++++++++-----
+ 1 file changed, 44 insertions(+), 8 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-385.dtsi b/arch/arm/boot/dts/armada-385.dtsi
+index f0022d10c715..83392b92dae2 100644
+--- a/arch/arm/boot/dts/armada-385.dtsi
++++ b/arch/arm/boot/dts/armada-385.dtsi
+@@ -69,16 +69,25 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -88,16 +97,25 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -107,16 +125,25 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <2>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/*
+@@ -129,16 +156,25 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie4_intc 0>,
++						<0 0 0 2 &pcie4_intc 1>,
++						<0 0 0 3 &pcie4_intc 2>,
++						<0 0 0 4 &pcie4_intc 3>;
+ 				marvell,pcie-port = <3>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 7>;
+ 				status = "disabled";
++				pcie4_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 	};
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0045-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-leg.patch b/target/linux/generic/pending-5.15/0045-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-leg.patch
new file mode 100644
index 0000000000..6264dcb1d5
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0045-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-leg.patch
@@ -0,0 +1,137 @@
+From 6538b798220816625295fb0d3a15fe44ac2445d8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:47:53 +0200
+Subject: [PATCH 45/90] ARM: dts: armada-39x.dtsi: Add definitions for PCIe
+ legacy INTx interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-39x.dtsi | 56 ++++++++++++++++++++++++++-----
+ 1 file changed, 48 insertions(+), 8 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-39x.dtsi b/arch/arm/boot/dts/armada-39x.dtsi
+index e0b7c2099831..923b035a3ab3 100644
+--- a/arch/arm/boot/dts/armada-39x.dtsi
++++ b/arch/arm/boot/dts/armada-39x.dtsi
+@@ -438,16 +438,26 @@ pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
++						<0 0 0 2 &pcie1_intc 1>,
++						<0 0 0 3 &pcie1_intc 2>,
++						<0 0 0 4 &pcie1_intc 3>;
+ 				marvell,pcie-port = <0>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 8>;
+ 				status = "disabled";
++
++				pcie1_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -457,16 +467,26 @@ pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie2_intc 0>,
++						<0 0 0 2 &pcie2_intc 1>,
++						<0 0 0 3 &pcie2_intc 2>,
++						<0 0 0 4 &pcie2_intc 3>;
+ 				marvell,pcie-port = <1>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 5>;
+ 				status = "disabled";
++
++				pcie2_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/* x1 port */
+@@ -476,16 +496,26 @@ pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie3_intc 0>,
++						<0 0 0 2 &pcie3_intc 1>,
++						<0 0 0 3 &pcie3_intc 2>,
++						<0 0 0 4 &pcie3_intc 3>;
+ 				marvell,pcie-port = <2>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 6>;
+ 				status = "disabled";
++
++				pcie3_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			/*
+@@ -498,16 +528,26 @@ pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
++				interrupt-names = "intx";
++				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-map-mask = <0 0 0 0>;
+-				interrupt-map = <0 0 0 0 &gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-map-mask = <0 0 0 7>;
++				interrupt-map = <0 0 0 1 &pcie4_intc 0>,
++						<0 0 0 2 &pcie4_intc 1>,
++						<0 0 0 3 &pcie4_intc 2>,
++						<0 0 0 4 &pcie4_intc 3>;
+ 				marvell,pcie-port = <3>;
+ 				marvell,pcie-lane = <0>;
+ 				clocks = <&gateclk 7>;
+ 				status = "disabled";
++
++				pcie4_intc: interrupt-controller {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 		};
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0046-PCI-Add-PCI_EXP_SLTCTL_ASPL_DISABLE-macro.patch b/target/linux/generic/pending-5.15/0046-PCI-Add-PCI_EXP_SLTCTL_ASPL_DISABLE-macro.patch
new file mode 100644
index 0000000000..35af36442a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0046-PCI-Add-PCI_EXP_SLTCTL_ASPL_DISABLE-macro.patch
@@ -0,0 +1,33 @@
+From 864663e14d534b51c066d7a686f43c2502bb311a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 2 Apr 2021 22:53:01 +0200
+Subject: [PATCH 46/90] PCI: Add PCI_EXP_SLTCTL_ASPL_DISABLE macro
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add macro defining Auto Slot Power Limit Disable bit in Slot Control
+Register.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Acked-by: Bjorn Helgaas <bhelgaas@google.com>
+---
+ include/uapi/linux/pci_regs.h | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h
+index ff6ccbc6efe9..e3456b8050f5 100644
+--- a/include/uapi/linux/pci_regs.h
++++ b/include/uapi/linux/pci_regs.h
+@@ -616,6 +616,7 @@
+ #define  PCI_EXP_SLTCTL_PWR_OFF        0x0400 /* Power Off */
+ #define  PCI_EXP_SLTCTL_EIC	0x0800	/* Electromechanical Interlock Control */
+ #define  PCI_EXP_SLTCTL_DLLSCE	0x1000	/* Data Link Layer State Changed Enable */
++#define  PCI_EXP_SLTCTL_ASPL_DISABLE	0x2000 /* Auto Slot Power Limit Disable */
+ #define  PCI_EXP_SLTCTL_IBPD_DISABLE	0x4000 /* In-band PD disable */
+ #define PCI_EXP_SLTSTA		26	/* Slot Status */
+ #define  PCI_EXP_SLTSTA_ABP	0x0001	/* Attention Button Pressed */
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0047-dt-bindings-Add-slot-power-limit-milliwatt-PCIe-port.patch b/target/linux/generic/pending-5.15/0047-dt-bindings-Add-slot-power-limit-milliwatt-PCIe-port.patch
new file mode 100644
index 0000000000..ebe671dae8
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0047-dt-bindings-Add-slot-power-limit-milliwatt-PCIe-port.patch
@@ -0,0 +1,46 @@
+From 0b9d2e40cc7379a4ad00dc198f755748eb654b49 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 31 Oct 2021 16:07:05 +0100
+Subject: [PATCH 47/90] dt-bindings: Add 'slot-power-limit-milliwatt' PCIe port
+ property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This property specifies slot power limit in mW unit. It is a form-factor
+and board specific value and must be initialized by hardware.
+
+Some PCIe controllers delegate this work to software to allow hardware
+flexibility and therefore this property basically specifies what should
+host bridge program into PCIe Slot Capabilities registers.
+
+The property needs to be specified in mW unit instead of the special format
+defined by Slot Capabilities (which encodes scaling factor or different
+unit). Host drivers should convert the value from mW to needed format.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ Documentation/devicetree/bindings/pci/pci.txt | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/Documentation/devicetree/bindings/pci/pci.txt b/Documentation/devicetree/bindings/pci/pci.txt
+index 6a8f2874a24d..b0cc133ed00d 100644
+--- a/Documentation/devicetree/bindings/pci/pci.txt
++++ b/Documentation/devicetree/bindings/pci/pci.txt
+@@ -32,6 +32,12 @@ driver implementation may support the following properties:
+    root port to downstream device and host bridge drivers can do programming
+    which depends on CLKREQ signal existence. For example, programming root port
+    not to advertise ASPM L1 Sub-States support if there is no CLKREQ signal.
++- slot-power-limit-milliwatt:
++   If present, this property specifies slot power limit in milliwatts. Host
++   drivers can parse this property and use it for programming Root Port or host
++   bridge, or for composing and sending PCIe Set_Slot_Power_Limit messages
++   through the Root Port or host bridge when transitioning PCIe link from a
++   non-DL_Up Status to a DL_Up Status.
+ 
+ PCI-PCI Bridge properties
+ -------------------------
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0048-PCI-Add-function-for-parsing-slot-power-limit-milliw.patch b/target/linux/generic/pending-5.15/0048-PCI-Add-function-for-parsing-slot-power-limit-milliw.patch
new file mode 100644
index 0000000000..4518849d69
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0048-PCI-Add-function-for-parsing-slot-power-limit-milliw.patch
@@ -0,0 +1,135 @@
+From 3514828cb2cf52e545fe71bb7dc2d105d8b0084e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 31 Oct 2021 16:07:06 +0100
+Subject: [PATCH 48/90] PCI: Add function for parsing
+ 'slot-power-limit-milliwatt' DT property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add function of_pci_get_slot_power_limit(), which parses the
+'slot-power-limit-milliwatt' DT property, returning the value in
+milliwatts and in format ready for the PCIe Slot Capabilities Register.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Rob Herring <robh@kernel.org>
+---
+ drivers/pci/of.c  | 70 +++++++++++++++++++++++++++++++++++++++++++++++
+ drivers/pci/pci.h | 15 ++++++++++
+ 2 files changed, 85 insertions(+)
+
+diff --git a/drivers/pci/of.c b/drivers/pci/of.c
+index d84381ce82b5..1372da653929 100644
+--- a/drivers/pci/of.c
++++ b/drivers/pci/of.c
+@@ -627,3 +627,73 @@ int of_pci_get_max_link_speed(struct device_node *node)
+ 	return max_link_speed;
+ }
+ EXPORT_SYMBOL_GPL(of_pci_get_max_link_speed);
++
++/**
++ * of_pci_get_slot_power_limit - Parses the "slot-power-limit-milliwatt"
++ *				 property.
++ *
++ * @node: device tree node with the slot power limit information
++ * @slot_power_limit_value: pointer where the value should be stored in PCIe
++ *			    Slot Capabilities Register format
++ * @slot_power_limit_scale: pointer where the scale should be stored in PCIe
++ *			    Slot Capabilities Register format
++ *
++ * Returns the slot power limit in milliwatts and if @slot_power_limit_value
++ * and @slot_power_limit_scale pointers are non-NULL, fills in the value and
++ * scale in format used by PCIe Slot Capabilities Register.
++ *
++ * If the property is not found or is invalid, returns 0.
++ */
++u32 of_pci_get_slot_power_limit(struct device_node *node,
++				u8 *slot_power_limit_value,
++				u8 *slot_power_limit_scale)
++{
++	u32 slot_power_limit_mw;
++	u8 value, scale;
++
++	if (of_property_read_u32(node, "slot-power-limit-milliwatt",
++				 &slot_power_limit_mw))
++		slot_power_limit_mw = 0;
++
++	/* Calculate Slot Power Limit Value and Slot Power Limit Scale */
++	if (slot_power_limit_mw == 0) {
++		value = 0x00;
++		scale = 0;
++	} else if (slot_power_limit_mw <= 255) {
++		value = slot_power_limit_mw;
++		scale = 3;
++	} else if (slot_power_limit_mw <= 255*10) {
++		value = slot_power_limit_mw / 10;
++		scale = 2;
++		slot_power_limit_mw = slot_power_limit_mw / 10 * 10;
++	} else if (slot_power_limit_mw <= 255*100) {
++		value = slot_power_limit_mw / 100;
++		scale = 1;
++		slot_power_limit_mw = slot_power_limit_mw / 100 * 100;
++	} else if (slot_power_limit_mw <= 239*1000) {
++		value = slot_power_limit_mw / 1000;
++		scale = 0;
++		slot_power_limit_mw = slot_power_limit_mw / 1000 * 1000;
++	} else if (slot_power_limit_mw < 250*1000) {
++		value = 0xEF;
++		scale = 0;
++		slot_power_limit_mw = 239*1000;
++	} else if (slot_power_limit_mw <= 600*1000) {
++		value = 0xF0 + (slot_power_limit_mw / 1000 - 250) / 25;
++		scale = 0;
++		slot_power_limit_mw = slot_power_limit_mw / (1000*25) * (1000*25);
++	} else {
++		value = 0xFE;
++		scale = 0;
++		slot_power_limit_mw = 600*1000;
++	}
++
++	if (slot_power_limit_value)
++		*slot_power_limit_value = value;
++
++	if (slot_power_limit_scale)
++		*slot_power_limit_scale = scale;
++
++	return slot_power_limit_mw;
++}
++EXPORT_SYMBOL_GPL(of_pci_get_slot_power_limit);
+diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
+index 1cce56c2aea0..9352278141be 100644
+--- a/drivers/pci/pci.h
++++ b/drivers/pci/pci.h
+@@ -665,6 +665,9 @@ struct device_node;
+ int of_pci_parse_bus_range(struct device_node *node, struct resource *res);
+ int of_get_pci_domain_nr(struct device_node *node);
+ int of_pci_get_max_link_speed(struct device_node *node);
++u32 of_pci_get_slot_power_limit(struct device_node *node,
++				u8 *slot_power_limit_value,
++				u8 *slot_power_limit_scale);
+ void pci_set_of_node(struct pci_dev *dev);
+ void pci_release_of_node(struct pci_dev *dev);
+ void pci_set_bus_of_node(struct pci_bus *bus);
+@@ -691,6 +694,18 @@ of_pci_get_max_link_speed(struct device_node *node)
+ 	return -EINVAL;
+ }
+ 
++static inline u32
++of_pci_get_slot_power_limit(struct device_node *node,
++			    u8 *slot_power_limit_value,
++			    u8 *slot_power_limit_scale)
++{
++	if (slot_power_limit_value)
++		*slot_power_limit_value = 0;
++	if (slot_power_limit_scale)
++		*slot_power_limit_scale = 0;
++	return 0;
++}
++
+ static inline void pci_set_of_node(struct pci_dev *dev) { }
+ static inline void pci_release_of_node(struct pci_dev *dev) { }
+ static inline void pci_set_bus_of_node(struct pci_bus *bus) { }
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0049-PCI-mvebu-Add-support-for-sending-Set_Slot_Power_Lim.patch b/target/linux/generic/pending-5.15/0049-PCI-mvebu-Add-support-for-sending-Set_Slot_Power_Lim.patch
new file mode 100644
index 0000000000..4c526f6277
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0049-PCI-mvebu-Add-support-for-sending-Set_Slot_Power_Lim.patch
@@ -0,0 +1,210 @@
+From 5c87d5ff707236098214303289cd5724aebbd0ab Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:25:33 +0200
+Subject: [PATCH 49/90] PCI: mvebu: Add support for sending
+ Set_Slot_Power_Limit message
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+If DT supplies the 'slot-power-limit-milliwatt' property, program
+the value in the Slot Power Limit in the Slot Capabilities register
+and program the Root Port to send a Set_Slot_Power_Limit Message
+when the Link transitions to DL_Up.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Rob Herring <robh@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 97 ++++++++++++++++++++++++++++--
+ 1 file changed, 92 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index c9311829dfe3..3c48b15e3948 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -8,6 +8,7 @@
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/pci.h>
++#include <linux/bitfield.h>
+ #include <linux/clk.h>
+ #include <linux/delay.h>
+ #include <linux/gpio.h>
+@@ -66,6 +67,12 @@
+ #define  PCIE_STAT_BUS                  0xff00
+ #define  PCIE_STAT_DEV                  0x1f0000
+ #define  PCIE_STAT_LINK_DOWN		BIT(0)
++#define PCIE_SSPL_OFF		0x1a0c
++#define  PCIE_SSPL_VALUE_SHIFT		0
++#define  PCIE_SSPL_VALUE_MASK		GENMASK(7, 0)
++#define  PCIE_SSPL_SCALE_SHIFT		8
++#define  PCIE_SSPL_SCALE_MASK		GENMASK(9, 8)
++#define  PCIE_SSPL_ENABLE		BIT(16)
+ #define PCIE_RC_RTSTA		0x1a14
+ #define PCIE_DEBUG_CTRL         0x1a60
+ #define  PCIE_DEBUG_SOFT_RESET		BIT(20)
+@@ -111,6 +118,8 @@ struct mvebu_pcie_port {
+ 	struct mvebu_pcie_window iowin;
+ 	u32 saved_pcie_stat;
+ 	struct resource regs;
++	u8 slot_power_limit_value;
++	u8 slot_power_limit_scale;
+ 	struct irq_domain *intx_irq_domain;
+ 	raw_spinlock_t irq_lock;
+ 	int intx_irq;
+@@ -239,7 +248,7 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)
+ 
+ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ {
+-	u32 ctrl, lnkcap, cmd, dev_rev, unmask;
++	u32 ctrl, lnkcap, cmd, dev_rev, unmask, sspl;
+ 
+ 	/* Setup PCIe controller to Root Complex mode. */
+ 	ctrl = mvebu_readl(port, PCIE_CTRL_OFF);
+@@ -292,6 +301,20 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	/* Point PCIe unit MBUS decode windows to DRAM space. */
+ 	mvebu_pcie_setup_wins(port);
+ 
++	/*
++	 * Program Root Port to automatically send Set_Slot_Power_Limit
++	 * PCIe Message when changing status from Dl_Down to Dl_Up and valid
++	 * slot power limit was specified.
++	 */
++	sspl = mvebu_readl(port, PCIE_SSPL_OFF);
++	sspl &= ~(PCIE_SSPL_VALUE_MASK | PCIE_SSPL_SCALE_MASK | PCIE_SSPL_ENABLE);
++	if (port->slot_power_limit_value) {
++		sspl |= port->slot_power_limit_value << PCIE_SSPL_VALUE_SHIFT;
++		sspl |= port->slot_power_limit_scale << PCIE_SSPL_SCALE_SHIFT;
++		sspl |= PCIE_SSPL_ENABLE;
++	}
++	mvebu_writel(port, sspl, PCIE_SSPL_OFF);
++
+ 	/* Mask all interrupt sources. */
+ 	mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);
+ 
+@@ -633,9 +656,24 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 			  (PCI_EXP_LNKSTA_DLLLA << 16) : 0);
+ 		break;
+ 
+-	case PCI_EXP_SLTCTL:
+-		*value = PCI_EXP_SLTSTA_PDS << 16;
++	case PCI_EXP_SLTCTL: {
++		u16 slotctl = le16_to_cpu(bridge->pcie_conf.slotctl);
++		u16 slotsta = le16_to_cpu(bridge->pcie_conf.slotsta);
++		u32 val = 0;
++		/*
++		 * When slot power limit was not specified in DT then
++		 * ASPL_DISABLE bit is stored only in emulated config space.
++		 * Otherwise reflect status of PCIE_SSPL_ENABLE bit in HW.
++		 */
++		if (!port->slot_power_limit_value)
++			val |= slotctl & PCI_EXP_SLTCTL_ASPL_DISABLE;
++		else if (!(mvebu_readl(port, PCIE_SSPL_OFF) & PCIE_SSPL_ENABLE))
++			val |= PCI_EXP_SLTCTL_ASPL_DISABLE;
++		/* This callback is 32-bit and in high bits is slot status. */
++		val |= slotsta << 16;
++		*value = val;
+ 		break;
++	}
+ 
+ 	case PCI_EXP_RTSTA:
+ 		*value = mvebu_readl(port, PCIE_RC_RTSTA);
+@@ -779,6 +817,22 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);
+ 		break;
+ 
++	case PCI_EXP_SLTCTL:
++		/*
++		 * Allow to change PCIE_SSPL_ENABLE bit only when slot power
++		 * limit was specified in DT and configured into HW.
++		 */
++		if ((mask & PCI_EXP_SLTCTL_ASPL_DISABLE) &&
++		    port->slot_power_limit_value) {
++			u32 sspl = mvebu_readl(port, PCIE_SSPL_OFF);
++			if (new & PCI_EXP_SLTCTL_ASPL_DISABLE)
++				sspl &= ~PCIE_SSPL_ENABLE;
++			else
++				sspl |= PCIE_SSPL_ENABLE;
++			mvebu_writel(port, sspl, PCIE_SSPL_OFF);
++		}
++		break;
++
+ 	case PCI_EXP_RTSTA:
+ 		/*
+ 		 * PME Status bit in Root Status Register (PCIE_RC_RTSTA)
+@@ -873,8 +927,26 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	/*
+ 	 * Older mvebu hardware provides PCIe Capability structure only in
+ 	 * version 1. New hardware provides it in version 2.
++	 * Enable slot support which is emulated.
+ 	 */
+-	bridge->pcie_conf.cap = cpu_to_le16(pcie_cap_ver);
++	bridge->pcie_conf.cap = cpu_to_le16(pcie_cap_ver | PCI_EXP_FLAGS_SLOT);
++
++	/*
++	 * Set Presence Detect State bit permanently as there is no support for
++	 * unplugging PCIe card from the slot. Assume that PCIe card is always
++	 * connected in slot.
++	 *
++	 * Set physical slot number to port+1 as mvebu ports are indexed from
++	 * zero and zero value is reserved for ports within the same silicon
++	 * as Root Port which is not mvebu case.
++	 *
++	 * Also set correct slot power limit.
++	 */
++	bridge->pcie_conf.slotcap = cpu_to_le32(
++		FIELD_PREP(PCI_EXP_SLTCAP_SPLV, port->slot_power_limit_value) |
++		FIELD_PREP(PCI_EXP_SLTCAP_SPLS, port->slot_power_limit_scale) |
++		FIELD_PREP(PCI_EXP_SLTCAP_PSN, port->port+1));
++	bridge->pcie_conf.slotsta = cpu_to_le16(PCI_EXP_SLTSTA_PDS);
+ 
+ 	bridge->subsystem_vendor_id = ssdev_id & 0xffff;
+ 	bridge->subsystem_id = ssdev_id >> 16;
+@@ -1198,6 +1270,7 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+ 	enum of_gpio_flags flags;
++	u32 slot_power_limit;
+ 	int reset_gpio, ret;
+ 	u32 num_lanes;
+ 
+@@ -1298,6 +1371,15 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 		port->reset_gpio = gpio_to_desc(reset_gpio);
+ 	}
+ 
++	slot_power_limit = of_pci_get_slot_power_limit(child,
++				&port->slot_power_limit_value,
++				&port->slot_power_limit_scale);
++	if (slot_power_limit)
++		dev_info(dev, "%s: Slot power limit %u.%uW\n",
++			 port->name,
++			 slot_power_limit / 1000,
++			 (slot_power_limit / 100) % 10);
++
+ 	port->clk = of_clk_get_by_name(child, NULL);
+ 	if (IS_ERR(port->clk)) {
+ 		dev_err(dev, "%s: cannot get clock\n", port->name);
+@@ -1595,7 +1677,7 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ {
+ 	struct mvebu_pcie *pcie = platform_get_drvdata(pdev);
+ 	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
+-	u32 cmd;
++	u32 cmd, sspl;
+ 	int i;
+ 
+ 	/* Remove PCI bus with all devices. */
+@@ -1632,6 +1714,11 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+ 
++		/* Disable sending Set_Slot_Power_Limit PCIe Message. */
++		sspl = mvebu_readl(port, PCIE_SSPL_OFF);
++		sspl &= ~(PCIE_SSPL_VALUE_MASK | PCIE_SSPL_SCALE_MASK | PCIE_SSPL_ENABLE);
++		mvebu_writel(port, sspl, PCIE_SSPL_OFF);
++
+ 		/* Disable and clear BARs and windows. */
+ 		mvebu_pcie_disable_wins(port);
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0050-ARM-dts-turris-omnia-Set-PCIe-slot-power-limit-milli.patch b/target/linux/generic/pending-5.15/0050-ARM-dts-turris-omnia-Set-PCIe-slot-power-limit-milli.patch
new file mode 100644
index 0000000000..f14ff4d406
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0050-ARM-dts-turris-omnia-Set-PCIe-slot-power-limit-milli.patch
@@ -0,0 +1,43 @@
+From f06d18dc4bdc230d247370c54a9ad9d4676ceb6d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Sep 2021 11:40:05 +0200
+Subject: [PATCH 50/90] ARM: dts: turris-omnia: Set PCIe
+ slot-power-limit-milliwatt properties
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+All 3 miniPCIe slots in Turris Omnia are designed for 10 W.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dts | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dts b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+index 5bd6a66d2c2b..f240018148f6 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dts
+@@ -71,16 +71,19 @@ pcie {
+ 			pcie@1,0 {
+ 				/* Port 0, Lane 0 */
+ 				status = "okay";
++				slot-power-limit-milliwatt = <10000>;
+ 			};
+ 
+ 			pcie@2,0 {
+ 				/* Port 1, Lane 0 */
+ 				status = "okay";
++				slot-power-limit-milliwatt = <10000>;
+ 			};
+ 
+ 			pcie@3,0 {
+ 				/* Port 2, Lane 0 */
+ 				status = "okay";
++				slot-power-limit-milliwatt = <10000>;
+ 			};
+ 		};
+ 	};
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0051-PCI-pci-bridge-emul-Set-position-of-PCI-capabilities.patch b/target/linux/generic/pending-5.15/0051-PCI-pci-bridge-emul-Set-position-of-PCI-capabilities.patch
new file mode 100644
index 0000000000..0d3b16034f
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0051-PCI-pci-bridge-emul-Set-position-of-PCI-capabilities.patch
@@ -0,0 +1,164 @@
+From f0a61d9c1f4396e7f3a241b9be1378ed4e5bb947 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 3 Jul 2022 12:40:13 +0200
+Subject: [PATCH 51/90] PCI: pci-bridge-emul: Set position of PCI capabilities
+ to real HW value
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+mvebu and aardvark HW have PCIe capabilities on different offset in PCI
+config space. Extend pci-bridge-emul.c code to allow setting custom driver
+custom value where PCIe capabilities starts.
+
+With this change PCIe capabilities of both drivers are reported at the same
+location as where they are reported by U-Boot - in their real HW offset.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c |  1 +
+ drivers/pci/controller/pci-mvebu.c    |  1 +
+ drivers/pci/pci-bridge-emul.c         | 48 +++++++++++++++++----------
+ drivers/pci/pci-bridge-emul.h         |  2 ++
+ 4 files changed, 35 insertions(+), 17 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-aardvark.c b/drivers/pci/controller/pci-aardvark.c
+index 3fe4d3329267..4ed1b3ed3d35 100644
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -984,6 +984,7 @@ static int advk_sw_pci_bridge_init(struct advk_pcie *pcie)
+ 	bridge->pcie_conf.rootcap = cpu_to_le16(PCI_EXP_RTCAP_CRSVIS);
+ 
+ 	bridge->has_pcie = true;
++	bridge->pcie_start = PCIE_CORE_PCIEXP_CAP;
+ 	bridge->data = pcie;
+ 	bridge->ops = &advk_pci_bridge_emul_ops;
+ 
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 3c48b15e3948..8205b4d1f04c 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -951,6 +951,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	bridge->subsystem_vendor_id = ssdev_id & 0xffff;
+ 	bridge->subsystem_id = ssdev_id >> 16;
+ 	bridge->has_pcie = true;
++	bridge->pcie_start = PCIE_CAP_PCIEXP;
+ 	bridge->data = port;
+ 	bridge->ops = &mvebu_pci_bridge_emul_ops;
+ 
+diff --git a/drivers/pci/pci-bridge-emul.c b/drivers/pci/pci-bridge-emul.c
+index a5b662cc89d0..7a8a7c804050 100644
+--- a/drivers/pci/pci-bridge-emul.c
++++ b/drivers/pci/pci-bridge-emul.c
+@@ -22,11 +22,7 @@
+ 
+ #define PCI_BRIDGE_CONF_END	PCI_STD_HEADER_SIZEOF
+ #define PCI_CAP_SSID_SIZEOF	(PCI_SSVID_DEVICE_ID + 2)
+-#define PCI_CAP_SSID_START	PCI_BRIDGE_CONF_END
+-#define PCI_CAP_SSID_END	(PCI_CAP_SSID_START + PCI_CAP_SSID_SIZEOF)
+ #define PCI_CAP_PCIE_SIZEOF	(PCI_EXP_SLTSTA2 + 2)
+-#define PCI_CAP_PCIE_START	PCI_CAP_SSID_END
+-#define PCI_CAP_PCIE_END	(PCI_CAP_PCIE_START + PCI_CAP_PCIE_SIZEOF)
+ 
+ /**
+  * struct pci_bridge_reg_behavior - register bits behaviors
+@@ -324,7 +320,7 @@ pci_bridge_emul_read_ssid(struct pci_bridge_emul *bridge, int reg, u32 *value)
+ 	switch (reg) {
+ 	case PCI_CAP_LIST_ID:
+ 		*value = PCI_CAP_ID_SSVID |
+-			(bridge->has_pcie ? (PCI_CAP_PCIE_START << 8) : 0);
++			((bridge->pcie_start > bridge->ssid_start) ? (bridge->pcie_start << 8) : 0);
+ 		return PCI_BRIDGE_EMUL_HANDLED;
+ 
+ 	case PCI_SSVID_VENDOR_ID:
+@@ -363,18 +359,33 @@ int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+ 	if (!bridge->pci_regs_behavior)
+ 		return -ENOMEM;
+ 
+-	if (bridge->subsystem_vendor_id)
+-		bridge->conf.capabilities_pointer = PCI_CAP_SSID_START;
+-	else if (bridge->has_pcie)
+-		bridge->conf.capabilities_pointer = PCI_CAP_PCIE_START;
+-	else
+-		bridge->conf.capabilities_pointer = 0;
++	/* If ssid_start and pcie_start were not specified then choose the lowest possible value. */
++	if (!bridge->ssid_start && !bridge->pcie_start) {
++		if (bridge->subsystem_vendor_id)
++			bridge->ssid_start = PCI_BRIDGE_CONF_END;
++		if (bridge->has_pcie)
++			bridge->pcie_start = bridge->ssid_start + PCI_CAP_SSID_SIZEOF;
++	} else if (!bridge->ssid_start && bridge->subsystem_vendor_id) {
++		if (bridge->pcie_start - PCI_BRIDGE_CONF_END >= PCI_CAP_SSID_SIZEOF)
++			bridge->ssid_start = PCI_BRIDGE_CONF_END;
++		else
++			bridge->ssid_start = bridge->pcie_start + PCI_CAP_PCIE_SIZEOF;
++	} else if (!bridge->pcie_start && bridge->has_pcie) {
++		if (bridge->ssid_start - PCI_BRIDGE_CONF_END >= PCI_CAP_PCIE_SIZEOF)
++			bridge->pcie_start = PCI_BRIDGE_CONF_END;
++		else
++			bridge->pcie_start = bridge->ssid_start + PCI_CAP_SSID_SIZEOF;
++	}
++
++	bridge->conf.capabilities_pointer = min(bridge->ssid_start, bridge->pcie_start);
+ 
+ 	if (bridge->conf.capabilities_pointer)
+ 		bridge->conf.status |= cpu_to_le16(PCI_STATUS_CAP_LIST);
+ 
+ 	if (bridge->has_pcie) {
+ 		bridge->pcie_conf.cap_id = PCI_CAP_ID_EXP;
++		bridge->pcie_conf.next = (bridge->ssid_start > bridge->pcie_start) ?
++					 bridge->ssid_start : 0;
+ 		bridge->pcie_conf.cap |= cpu_to_le16(PCI_EXP_TYPE_ROOT_PORT << 4);
+ 		bridge->pcie_cap_regs_behavior =
+ 			kmemdup(pcie_cap_regs_behavior,
+@@ -457,15 +468,17 @@ int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+ 		read_op = bridge->ops->read_base;
+ 		cfgspace = (__le32 *) &bridge->conf;
+ 		behavior = bridge->pci_regs_behavior;
+-	} else if (reg >= PCI_CAP_SSID_START && reg < PCI_CAP_SSID_END && bridge->subsystem_vendor_id) {
++	} else if (reg >= bridge->ssid_start && reg < bridge->ssid_start + PCI_CAP_SSID_SIZEOF &&
++		   bridge->subsystem_vendor_id) {
+ 		/* Emulated PCI Bridge Subsystem Vendor ID capability */
+-		reg -= PCI_CAP_SSID_START;
++		reg -= bridge->ssid_start;
+ 		read_op = pci_bridge_emul_read_ssid;
+ 		cfgspace = NULL;
+ 		behavior = NULL;
+-	} else if (reg >= PCI_CAP_PCIE_START && reg < PCI_CAP_PCIE_END && bridge->has_pcie) {
++	} else if (reg >= bridge->pcie_start && reg < bridge->pcie_start + PCI_CAP_PCIE_SIZEOF &&
++		   bridge->has_pcie) {
+ 		/* Our emulated PCIe capability */
+-		reg -= PCI_CAP_PCIE_START;
++		reg -= bridge->pcie_start;
+ 		read_op = bridge->ops->read_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+@@ -536,9 +549,10 @@ int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+ 		write_op = bridge->ops->write_base;
+ 		cfgspace = (__le32 *) &bridge->conf;
+ 		behavior = bridge->pci_regs_behavior;
+-	} else if (reg >= PCI_CAP_PCIE_START && reg < PCI_CAP_PCIE_END && bridge->has_pcie) {
++	} else if (reg >= bridge->pcie_start && reg < bridge->pcie_start + PCI_CAP_PCIE_SIZEOF &&
++		   bridge->has_pcie) {
+ 		/* Our emulated PCIe capability */
+-		reg -= PCI_CAP_PCIE_START;
++		reg -= bridge->pcie_start;
+ 		write_op = bridge->ops->write_pcie;
+ 		cfgspace = (__le32 *) &bridge->pcie_conf;
+ 		behavior = bridge->pcie_cap_regs_behavior;
+diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
+index 71392b67471d..2a0e59c7f0d9 100644
+--- a/drivers/pci/pci-bridge-emul.h
++++ b/drivers/pci/pci-bridge-emul.h
+@@ -131,6 +131,8 @@ struct pci_bridge_emul {
+ 	struct pci_bridge_reg_behavior *pci_regs_behavior;
+ 	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
+ 	void *data;
++	u8 pcie_start;
++	u8 ssid_start;
+ 	bool has_pcie;
+ 	u16 subsystem_vendor_id;
+ 	u16 subsystem_id;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0053-PCI-mvebu-Use-devm_request_irq-for-registering-inter.patch b/target/linux/generic/pending-5.15/0053-PCI-mvebu-Use-devm_request_irq-for-registering-inter.patch
new file mode 100644
index 0000000000..d09446fc5a
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0053-PCI-mvebu-Use-devm_request_irq-for-registering-inter.patch
@@ -0,0 +1,99 @@
+From 149b6e20ecbc96ede412736d5c26496382d382e7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 24 May 2022 13:57:37 +0200
+Subject: [PATCH 53/90] PCI: mvebu: Use devm_request_irq() for registering
+ interrupt handler
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Same as in commit a3b69dd0ad62 ("Revert "PCI: aardvark: Rewrite IRQ code to
+chained IRQ handler"") for pci-aardvark driver, use devm_request_irq()
+instead of chained IRQ handler in pci-mvebu.c driver.
+
+This change fixes affinity support and allows to pin interrupts from
+different PCIe controllers to different CPU cores.
+
+Fixes: ec075262648f ("PCI: mvebu: Implement support for legacy INTx interrupts")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 30 +++++++++++++++++-------------
+ 1 file changed, 17 insertions(+), 13 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 8205b4d1f04c..d8cba09649ba 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -1097,16 +1097,13 @@ static int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)
+ 	return 0;
+ }
+ 
+-static void mvebu_pcie_irq_handler(struct irq_desc *desc)
++static irqreturn_t mvebu_pcie_irq_handler(int irq, void *arg)
+ {
+-	struct mvebu_pcie_port *port = irq_desc_get_handler_data(desc);
+-	struct irq_chip *chip = irq_desc_get_chip(desc);
++	struct mvebu_pcie_port *port = arg;
+ 	struct device *dev = &port->pcie->pdev->dev;
+ 	u32 cause, unmask, status;
+ 	int i;
+ 
+-	chained_irq_enter(chip, desc);
+-
+ 	cause = mvebu_readl(port, PCIE_INT_CAUSE_OFF);
+ 	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
+ 	status = cause & unmask;
+@@ -1120,7 +1117,7 @@ static void mvebu_pcie_irq_handler(struct irq_desc *desc)
+ 			dev_err_ratelimited(dev, "unexpected INT%c IRQ\n", (char)i+'A');
+ 	}
+ 
+-	chained_irq_exit(chip, desc);
++	return status ? IRQ_HANDLED : IRQ_NONE;
+ }
+ 
+ static int mvebu_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+@@ -1580,9 +1577,20 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 				mvebu_pcie_powerdown(port);
+ 				continue;
+ 			}
+-			irq_set_chained_handler_and_data(irq,
+-							 mvebu_pcie_irq_handler,
+-							 port);
++
++			ret = devm_request_irq(dev, irq, mvebu_pcie_irq_handler,
++					       IRQF_SHARED | IRQF_NO_THREAD,
++					       port->name, port);
++			if (ret) {
++				dev_err(dev, "%s: cannot register interrupt handler: %d\n",
++					port->name, ret);
++				irq_domain_remove(port->intx_irq_domain);
++				pci_bridge_emul_cleanup(&port->bridge);
++				devm_iounmap(dev, port->base);
++				port->base = NULL;
++				mvebu_pcie_powerdown(port);
++				continue;
++			}
+ 		}
+ 
+ 		/*
+@@ -1689,7 +1697,6 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = &pcie->ports[i];
+-		int irq = port->intx_irq;
+ 
+ 		if (!port->base)
+ 			continue;
+@@ -1705,9 +1712,6 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 		/* Clear all interrupt causes. */
+ 		mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);
+ 
+-		if (irq > 0)
+-			irq_set_chained_handler_and_data(irq, NULL, NULL);
+-
+ 		/* Remove IRQ domains. */
+ 		if (port->intx_irq_domain)
+ 			irq_domain_remove(port->intx_irq_domain);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0054-PCI-mvebu-Dispose-INTx-irqs-prior-to-removing-INTx-d.patch b/target/linux/generic/pending-5.15/0054-PCI-mvebu-Dispose-INTx-irqs-prior-to-removing-INTx-d.patch
new file mode 100644
index 0000000000..cd1f82fd0c
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0054-PCI-mvebu-Dispose-INTx-irqs-prior-to-removing-INTx-d.patch
@@ -0,0 +1,47 @@
+From a3502251f0a195b584efc6b29ecac0ac53ac582a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sat, 9 Jul 2022 16:12:40 +0200
+Subject: [PATCH 54/90] PCI: mvebu: Dispose INTx irqs prior to removing INTx
+ domain
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Documentation for irq_domain_remove() says that all mapping within the
+domain must be disposed prior to domain remove.
+
+Currently INTx irqs are not disposed in pci-mvebu.c device unbind callback
+which cause that kernel crashes after unloading driver and trying to read
+/sys/kernel/debug/irq/irqs/<num> or /proc/interrupts.
+
+Fixes: ec075262648f ("PCI: mvebu: Implement support for legacy INTx interrupts")
+Reported-by: Hajo Noerenberg <hajo-linux-bugzilla@noerenberg.de>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index d8cba09649ba..0122c65b0269 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -1713,8 +1713,15 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 		mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);
+ 
+ 		/* Remove IRQ domains. */
+-		if (port->intx_irq_domain)
++		if (port->intx_irq_domain) {
++			int virq, j;
++			for (j = 0; j < PCI_NUM_INTX; j++) {
++				virq = irq_find_mapping(port->intx_irq_domain, j);
++				if (virq > 0)
++					irq_dispose_mapping(virq);
++			}
+ 			irq_domain_remove(port->intx_irq_domain);
++		}
+ 
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0055-PCI-Assign-PCI-domain-by-ida_alloc.patch b/target/linux/generic/pending-5.15/0055-PCI-Assign-PCI-domain-by-ida_alloc.patch
new file mode 100644
index 0000000000..b639b72a2c
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0055-PCI-Assign-PCI-domain-by-ida_alloc.patch
@@ -0,0 +1,215 @@
+From 4194dcecf85a825287ce0d4931cf27c36ba899ce Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sat, 2 Jul 2022 21:37:51 +0200
+Subject: [PATCH 55/90] PCI: Assign PCI domain by ida_alloc()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Replace assignment of PCI domain from atomic_inc_return() to ida_alloc().
+
+Use two IDAs, one for static domain allocations (those which are defined in
+device tree) and second for dynamic allocations (all other).
+
+During removal of root bus / host bridge release also allocated domain id.
+So released id can be reused again, for example in situation when
+dynamically loading and unloading native PCI host bridge drivers.
+
+This change also allows to mix static device tree assignment and dynamic by
+kernel as all static allocations are reserved in dynamic pool.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/pci.c    | 103 +++++++++++++++++++++++++------------------
+ drivers/pci/probe.c  |   5 +++
+ drivers/pci/remove.c |   6 +++
+ include/linux/pci.h  |   1 +
+ 4 files changed, 72 insertions(+), 43 deletions(-)
+
+diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
+index 2bfff2328cf8..99aaf6d8d92c 100644
+--- a/drivers/pci/pci.c
++++ b/drivers/pci/pci.c
+@@ -6679,60 +6679,70 @@ static void pci_no_domains(void)
+ }
+ 
+ #ifdef CONFIG_PCI_DOMAINS_GENERIC
+-static atomic_t __domain_nr = ATOMIC_INIT(-1);
++static DEFINE_IDA(pci_domain_nr_static_ida);
++static DEFINE_IDA(pci_domain_nr_dynamic_ida);
+ 
+-static int pci_get_new_domain_nr(void)
++static void of_pci_reserve_static_domain_nr(void)
+ {
+-	return atomic_inc_return(&__domain_nr);
++	struct device_node *np;
++	int domain_nr;
++
++	for_each_node_by_type(np, "pci") {
++		domain_nr = of_get_pci_domain_nr(np);
++		if (domain_nr < 0)
++			continue;
++		/*
++		 * Permanently allocate domain_nr in dynamic_ida
++		 * to prevent it from dynamic allocation.
++		 */
++		ida_alloc_range(&pci_domain_nr_dynamic_ida,
++				domain_nr, domain_nr, GFP_KERNEL);
++	}
+ }
+ 
+ static int of_pci_bus_find_domain_nr(struct device *parent)
+ {
+-	static int use_dt_domains = -1;
+-	int domain = -1;
++	static bool static_domains_reserved = false;
++	int domain_nr;
+ 
+-	if (parent)
+-		domain = of_get_pci_domain_nr(parent->of_node);
++	/* On the first call scan device tree for static allocations. */
++	if (!static_domains_reserved) {
++		of_pci_reserve_static_domain_nr();
++		static_domains_reserved = true;
++	}
++
++	if (parent) {
++		/*
++		 * If domain is in DT then allocate it in static IDA.
++		 * This prevent duplicate static allocations in case
++		 * of errors in DT.
++		 */
++		domain_nr = of_get_pci_domain_nr(parent->of_node);
++		if (domain_nr >= 0)
++			return ida_alloc_range(&pci_domain_nr_static_ida,
++					       domain_nr, domain_nr,
++					       GFP_KERNEL);
++	}
+ 
+ 	/*
+-	 * Check DT domain and use_dt_domains values.
+-	 *
+-	 * If DT domain property is valid (domain >= 0) and
+-	 * use_dt_domains != 0, the DT assignment is valid since this means
+-	 * we have not previously allocated a domain number by using
+-	 * pci_get_new_domain_nr(); we should also update use_dt_domains to
+-	 * 1, to indicate that we have just assigned a domain number from
+-	 * DT.
+-	 *
+-	 * If DT domain property value is not valid (ie domain < 0), and we
+-	 * have not previously assigned a domain number from DT
+-	 * (use_dt_domains != 1) we should assign a domain number by
+-	 * using the:
+-	 *
+-	 * pci_get_new_domain_nr()
+-	 *
+-	 * API and update the use_dt_domains value to keep track of method we
+-	 * are using to assign domain numbers (use_dt_domains = 0).
+-	 *
+-	 * All other combinations imply we have a platform that is trying
+-	 * to mix domain numbers obtained from DT and pci_get_new_domain_nr(),
+-	 * which is a recipe for domain mishandling and it is prevented by
+-	 * invalidating the domain value (domain = -1) and printing a
+-	 * corresponding error.
++	 * If domain was not specified in DT then choose free id from dynamic
++	 * allocations. All domain numbers from DT are permanently in dynamic
++	 * allocations to prevent assigning them to other DT nodes without
++	 * static domain.
+ 	 */
+-	if (domain >= 0 && use_dt_domains) {
+-		use_dt_domains = 1;
+-	} else if (domain < 0 && use_dt_domains != 1) {
+-		use_dt_domains = 0;
+-		domain = pci_get_new_domain_nr();
+-	} else {
+-		if (parent)
+-			pr_err("Node %pOF has ", parent->of_node);
+-		pr_err("Inconsistent \"linux,pci-domain\" property in DT\n");
+-		domain = -1;
+-	}
++	return ida_alloc(&pci_domain_nr_dynamic_ida, GFP_KERNEL);
++}
+ 
+-	return domain;
++static void of_pci_bus_release_domain_nr(struct pci_bus *bus, struct device *parent)
++{
++	if (bus->domain_nr < 0)
++		return;
++
++	/* Release domain from ida in which was it allocated. */
++	if (of_get_pci_domain_nr(parent->of_node) == bus->domain_nr)
++		ida_free(&pci_domain_nr_static_ida, bus->domain_nr);
++	else
++		ida_free(&pci_domain_nr_dynamic_ida, bus->domain_nr);
+ }
+ 
+ int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
+@@ -6740,6 +6750,13 @@ int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
+ 	return acpi_disabled ? of_pci_bus_find_domain_nr(parent) :
+ 			       acpi_pci_bus_find_domain_nr(bus);
+ }
++
++void pci_bus_release_domain_nr(struct pci_bus *bus, struct device *parent)
++{
++	if (!acpi_disabled)
++		return;
++	of_pci_bus_release_domain_nr(bus, parent);
++}
+ #endif
+ 
+ /**
+diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
+index d9fc02a71baa..1b6f817454e2 100644
+--- a/drivers/pci/probe.c
++++ b/drivers/pci/probe.c
+@@ -908,6 +908,8 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
+ 		bus->domain_nr = pci_bus_find_domain_nr(bus, parent);
+ 	else
+ 		bus->domain_nr = bridge->domain_nr;
++	if (bus->domain_nr < 0)
++		goto free;
+ #endif
+ 
+ 	b = pci_find_bus(pci_domain_nr(bus), bridge->busnr);
+@@ -1007,6 +1009,9 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
+ 	device_del(&bridge->dev);
+ 
+ free:
++#ifdef CONFIG_PCI_DOMAINS_GENERIC
++	pci_bus_release_domain_nr(bus, parent);
++#endif
+ 	kfree(bus);
+ 	return err;
+ }
+diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
+index 4c54c75050dc..0145aef1b930 100644
+--- a/drivers/pci/remove.c
++++ b/drivers/pci/remove.c
+@@ -160,6 +160,12 @@ void pci_remove_root_bus(struct pci_bus *bus)
+ 	pci_remove_bus(bus);
+ 	host_bridge->bus = NULL;
+ 
++#ifdef CONFIG_PCI_DOMAINS_GENERIC
++	/* Release domain_nr if it was dynamically allocated */
++	if (host_bridge->domain_nr == PCI_DOMAIN_NR_NOT_SET)
++		pci_bus_release_domain_nr(bus, host_bridge->dev.parent);
++#endif
++
+ 	/* remove the host bridge */
+ 	device_del(&host_bridge->dev);
+ }
+diff --git a/include/linux/pci.h b/include/linux/pci.h
+index 9d6e75222868..e127ef7c3930 100644
+--- a/include/linux/pci.h
++++ b/include/linux/pci.h
+@@ -1707,6 +1707,7 @@ static inline int acpi_pci_bus_find_domain_nr(struct pci_bus *bus)
+ { return 0; }
+ #endif
+ int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent);
++void pci_bus_release_domain_nr(struct pci_bus *bus, struct device *parent);
+ #endif
+ 
+ /* Some architectures require additional setup to direct VGA traffic */
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0056-PCI-mvebu-Fix-endianity-when-accessing-pci-emul-brid.patch b/target/linux/generic/pending-5.15/0056-PCI-mvebu-Fix-endianity-when-accessing-pci-emul-brid.patch
new file mode 100644
index 0000000000..323e8bccd1
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0056-PCI-mvebu-Fix-endianity-when-accessing-pci-emul-brid.patch
@@ -0,0 +1,68 @@
+From 600952067c786972461d1ec16bfd71221066341f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 12 Aug 2022 11:09:11 +0200
+Subject: [PATCH 56/90] PCI: mvebu: Fix endianity when accessing pci emul
+ bridge members
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+PCI emul bridge members iolimitupper, iobaseupper, memlimit and membase are
+of type __le16, so correctly access these members via le16_to_cpu() macros.
+
+Fixes: 4ded69473adb ("PCI: mvebu: Propagate errors when updating PCI_IO_BASE and PCI_MEM_BASE registers")
+Reported-by: kernel test robot <lkp@intel.com>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 0122c65b0269..c5e5bc085a9d 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -528,7 +528,7 @@ static int mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
+ 
+ 	/* Are the new iobase/iolimit values invalid? */
+ 	if (conf->iolimit < conf->iobase ||
+-	    conf->iolimitupper < conf->iobaseupper)
++	    le16_to_cpu(conf->iolimitupper) < le16_to_cpu(conf->iobaseupper))
+ 		return mvebu_pcie_set_window(port, port->io_target, port->io_attr,
+ 					     &desired, &port->iowin);
+ 
+@@ -540,10 +540,10 @@ static int mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)
+ 	 * is the CPU address.
+ 	 */
+ 	desired.remap = ((conf->iobase & 0xF0) << 8) |
+-			(conf->iobaseupper << 16);
++			(le16_to_cpu(conf->iobaseupper) << 16);
+ 	desired.base = port->pcie->io.start + desired.remap;
+ 	desired.size = ((0xFFF | ((conf->iolimit & 0xF0) << 8) |
+-			 (conf->iolimitupper << 16)) -
++			 (le16_to_cpu(conf->iolimitupper) << 16)) -
+ 			desired.remap) +
+ 		       1;
+ 
+@@ -557,7 +557,7 @@ static int mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)
+ 	struct pci_bridge_emul_conf *conf = &port->bridge.conf;
+ 
+ 	/* Are the new membase/memlimit values invalid? */
+-	if (conf->memlimit < conf->membase)
++	if (le16_to_cpu(conf->memlimit) < le16_to_cpu(conf->membase))
+ 		return mvebu_pcie_set_window(port, port->mem_target, port->mem_attr,
+ 					     &desired, &port->memwin);
+ 
+@@ -567,8 +567,8 @@ static int mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)
+ 	 * window to setup, according to the PCI-to-PCI bridge
+ 	 * specifications.
+ 	 */
+-	desired.base = ((conf->membase & 0xFFF0) << 16);
+-	desired.size = (((conf->memlimit & 0xFFF0) << 16) | 0xFFFFF) -
++	desired.base = ((le16_to_cpu(conf->membase) & 0xFFF0) << 16);
++	desired.size = (((le16_to_cpu(conf->memlimit) & 0xFFF0) << 16) | 0xFFFFF) -
+ 		       desired.base + 1;
+ 
+ 	return mvebu_pcie_set_window(port, port->mem_target, port->mem_attr, &desired,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0063-irqchip-armada-370-xp-Do-not-call-ipi_resume-when-IP.patch b/target/linux/generic/pending-5.15/0063-irqchip-armada-370-xp-Do-not-call-ipi_resume-when-IP.patch
new file mode 100644
index 0000000000..867e6dd691
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0063-irqchip-armada-370-xp-Do-not-call-ipi_resume-when-IP.patch
@@ -0,0 +1,49 @@
+From 748cb95b78593cba8dd0abbbb7d466322c46bde2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 11 Aug 2022 10:57:05 +0200
+Subject: [PATCH 63/90] irqchip/armada-370-xp: Do not call ipi_resume() when
+ IPI is not used
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+When IPI is not used then ipi_resume() does nothing. IPI is used only on
+systems where mpic controller does not parent GIC IRQ (e.g. on Armada XP).
+For documentation purpose add condition when ipi_resume() should be called.
+This simplify understanding of irq-armada-370-xp.c driver when individual
+driver functions are called when they do something. No functional change.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/irqchip/irq-armada-370-xp.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-armada-370-xp.c
+index 3fa6bd70684b..11b6ce81d17e 100644
+--- a/drivers/irqchip/irq-armada-370-xp.c
++++ b/drivers/irqchip/irq-armada-370-xp.c
+@@ -509,7 +509,9 @@ static void armada_xp_mpic_reenable_percpu(void)
+ 		armada_370_xp_irq_unmask(data);
+ 	}
+ 
+-	ipi_resume();
++	/* IPI is used only when we do not have parent irq */
++	if (parent_irq <= 0)
++		ipi_resume();
+ }
+ 
+ static int armada_xp_mpic_starting_cpu(unsigned int cpu)
+@@ -735,7 +737,9 @@ static void armada_370_xp_mpic_resume(void)
+ 	if (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)
+ 		writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+ 
+-	ipi_resume();
++	/* IPI is used only when we do not have parent irq */
++	if (parent_irq <= 0)
++		ipi_resume();
+ }
+ 
+ static struct syscore_ops armada_370_xp_mpic_syscore_ops = {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0064-irqchip-armada-370-xp-Fix-comment-about-unmasking-mp.patch b/target/linux/generic/pending-5.15/0064-irqchip-armada-370-xp-Fix-comment-about-unmasking-mp.patch
new file mode 100644
index 0000000000..e50699bbcf
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0064-irqchip-armada-370-xp-Fix-comment-about-unmasking-mp.patch
@@ -0,0 +1,35 @@
+From e5a5d4fd63c10ff98847e9c1cfa3c6161f4b69e8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 11 Aug 2022 11:15:56 +0200
+Subject: [PATCH 64/90] irqchip/armada-370-xp: Fix comment about unmasking mpic
+ source 1
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+mpic source 1 unmasks MSI interrupts, not IPI interrupt (IPI has source 0).
+Function armada_370_xp_msi_init() is used for initializing MSI interrupts,
+so code is correct (it should enable MSI interrupts; not IPI), just comment
+was wrong.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/irqchip/irq-armada-370-xp.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-armada-370-xp.c
+index 11b6ce81d17e..9b28e6269176 100644
+--- a/drivers/irqchip/irq-armada-370-xp.c
++++ b/drivers/irqchip/irq-armada-370-xp.c
+@@ -293,7 +293,7 @@ static int armada_370_xp_msi_init(struct device_node *node,
+ 	writel(reg, per_cpu_int_base +
+ 	       ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+ 
+-	/* Unmask IPI interrupt */
++	/* Unmask MSI interrupt */
+ 	writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+ 
+ 	return 0;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0065-irqchip-armada-370-xp-Do-not-touch-IPI-registers-on-.patch b/target/linux/generic/pending-5.15/0065-irqchip-armada-370-xp-Do-not-touch-IPI-registers-on-.patch
new file mode 100644
index 0000000000..038ce8ed48
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0065-irqchip-armada-370-xp-Do-not-touch-IPI-registers-on-.patch
@@ -0,0 +1,67 @@
+From bfe14db697196f06c0a7abe7f0d44edac04f0c11 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 11 Aug 2022 11:35:53 +0200
+Subject: [PATCH 65/90] irqchip/armada-370-xp: Do not touch IPI registers on
+ platforms without IPI
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+IPI is used only when we do not have parent irq. On platforms with parent
+irq are those IPI registers used for additional set of MSI interrupts
+(which are currently unused). So do not touch these registers when IPI is
+not used.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/irqchip/irq-armada-370-xp.c | 14 ++++++++++++--
+ 1 file changed, 12 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-armada-370-xp.c
+index 9b28e6269176..397bacf638a2 100644
+--- a/drivers/irqchip/irq-armada-370-xp.c
++++ b/drivers/irqchip/irq-armada-370-xp.c
+@@ -478,6 +478,10 @@ static void armada_xp_mpic_smp_cpu_init(void)
+ 	for (i = 0; i < nr_irqs; i++)
+ 		writel(i, per_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);
+ 
++	/* IPI is not used when we do have parent irq */
++	if (parent_irq > 0)
++		return;
++
+ 	/* Disable all IPIs */
+ 	writel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+ 
+@@ -732,7 +736,8 @@ static void armada_370_xp_mpic_resume(void)
+ 	/* Reconfigure doorbells for IPIs and MSIs */
+ 	writel(doorbell_mask_reg,
+ 	       per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+-	if (doorbell_mask_reg & IPI_DOORBELL_MASK)
++	/* IPI is used only when we do not have parent irq */
++	if (parent_irq <= 0 && (doorbell_mask_reg & IPI_DOORBELL_MASK))
+ 		writel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+ 	if (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)
+ 		writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+@@ -784,13 +789,18 @@ static int __init armada_370_xp_mpic_of_init(struct device_node *node,
+ 	BUG_ON(!armada_370_xp_mpic_domain);
+ 	irq_domain_update_bus_token(armada_370_xp_mpic_domain, DOMAIN_BUS_WIRED);
+ 
++	/*
++	 * parent_irq is used for distinguish between IPI and non-IPI platforms.
++	 * So initialize it before calling any other driver functions.
++	 */
++	parent_irq = irq_of_parse_and_map(node, 0);
++
+ 	/* Setup for the boot CPU */
+ 	armada_xp_mpic_perf_init();
+ 	armada_xp_mpic_smp_cpu_init();
+ 
+ 	armada_370_xp_msi_init(node, main_int_res.start);
+ 
+-	parent_irq = irq_of_parse_and_map(node, 0);
+ 	if (parent_irq <= 0) {
+ 		irq_set_default_host(armada_370_xp_mpic_domain);
+ 		set_handle_irq(armada_370_xp_handle_irq);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0066-irqchip-armada-370-xp-Add-support-for-32-MSI-interru.patch b/target/linux/generic/pending-5.15/0066-irqchip-armada-370-xp-Add-support-for-32-MSI-interru.patch
new file mode 100644
index 0000000000..0eefb9a584
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0066-irqchip-armada-370-xp-Add-support-for-32-MSI-interru.patch
@@ -0,0 +1,181 @@
+From adf4ef16f1869c4f8a35bfb95ce95e0d418f72b9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 11 Aug 2022 13:16:26 +0200
+Subject: [PATCH 66/90] irqchip/armada-370-xp: Add support for 32 MSI
+ interrupts on non-IPI platforms
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Currently only upper 16 MSI interrupts on non-IPI platforms are used.
+Low 16 MSI interrupts on non-IPI platforms are mapped into IPI registers.
+Implement support also for low 16 MSI interrupts which allow increase
+number of MSI interrupts on non-IPI platforms from 16 to 32.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/irqchip/irq-armada-370-xp.c | 54 +++++++++++++++++++++--------
+ 1 file changed, 40 insertions(+), 14 deletions(-)
+
+diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-armada-370-xp.c
+index 397bacf638a2..8abc70ed30c1 100644
+--- a/drivers/irqchip/irq-armada-370-xp.c
++++ b/drivers/irqchip/irq-armada-370-xp.c
+@@ -135,6 +135,7 @@
+ 
+ #define ARMADA_370_XP_MAX_PER_CPU_IRQS		(28)
+ 
++/* IPI and MSI interrupt definitions for IPI platforms */
+ #define IPI_DOORBELL_START                      (0)
+ #define IPI_DOORBELL_END                        (8)
+ #define IPI_DOORBELL_MASK                       0xFF
+@@ -143,6 +144,12 @@
+ #define PCI_MSI_DOORBELL_END                    (32)
+ #define PCI_MSI_DOORBELL_MASK                   0xFFFF0000
+ 
++/* MSI interrupt definitions for non-IPI platforms */
++#define PCI_MSI_FULL_DOORBELL_START		(0)
++#define PCI_MSI_FULL_DOORBELL_NR		(32)
++#define PCI_MSI_FULL_DOORBELL_END		(32)
++#define PCI_MSI_FULL_DOORBELL_MASK		(0xFFFFFFFF)
++
+ static void __iomem *per_cpu_int_base;
+ static void __iomem *main_int_base;
+ static struct irq_domain *armada_370_xp_mpic_domain;
+@@ -151,7 +158,7 @@ static int parent_irq;
+ #ifdef CONFIG_PCI_MSI
+ static struct irq_domain *armada_370_xp_msi_domain;
+ static struct irq_domain *armada_370_xp_msi_inner_domain;
+-static DECLARE_BITMAP(msi_used, PCI_MSI_DOORBELL_NR);
++static DECLARE_BITMAP(msi_used, PCI_MSI_FULL_DOORBELL_NR);
+ static DEFINE_MUTEX(msi_used_lock);
+ static phys_addr_t msi_doorbell_addr;
+ #endif
+@@ -209,9 +216,10 @@ static struct msi_domain_info armada_370_xp_msi_domain_info = {
+ 
+ static void armada_370_xp_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
+ {
++	u32 msi_start = (parent_irq <= 0) ? PCI_MSI_DOORBELL_START : PCI_MSI_FULL_DOORBELL_START;
+ 	msg->address_lo = lower_32_bits(msi_doorbell_addr);
+ 	msg->address_hi = upper_32_bits(msi_doorbell_addr);
+-	msg->data = 0xf00 | (data->hwirq + PCI_MSI_DOORBELL_START);
++	msg->data = 0xf00 | (data->hwirq + msi_start);
+ }
+ 
+ static int armada_370_xp_msi_set_affinity(struct irq_data *irq_data,
+@@ -229,10 +237,11 @@ static struct irq_chip armada_370_xp_msi_bottom_irq_chip = {
+ static int armada_370_xp_msi_alloc(struct irq_domain *domain, unsigned int virq,
+ 				   unsigned int nr_irqs, void *args)
+ {
++	unsigned int msi_nr = (parent_irq <= 0) ? PCI_MSI_DOORBELL_NR : PCI_MSI_FULL_DOORBELL_NR;
+ 	int hwirq, i;
+ 
+ 	mutex_lock(&msi_used_lock);
+-	hwirq = bitmap_find_free_region(msi_used, PCI_MSI_DOORBELL_NR,
++	hwirq = bitmap_find_free_region(msi_used, msi_nr,
+ 					order_base_2(nr_irqs));
+ 	mutex_unlock(&msi_used_lock);
+ 
+@@ -267,13 +276,15 @@ static const struct irq_domain_ops armada_370_xp_msi_domain_ops = {
+ static int armada_370_xp_msi_init(struct device_node *node,
+ 				  phys_addr_t main_int_phys_base)
+ {
++	unsigned int msi_nr = (parent_irq <= 0) ? PCI_MSI_DOORBELL_NR : PCI_MSI_FULL_DOORBELL_NR;
++	u32 msi_mask = (parent_irq <= 0) ? PCI_MSI_DOORBELL_MASK: PCI_MSI_FULL_DOORBELL_MASK;
+ 	u32 reg;
+ 
+ 	msi_doorbell_addr = main_int_phys_base +
+ 		ARMADA_370_XP_SW_TRIG_INT_OFFS;
+ 
+ 	armada_370_xp_msi_inner_domain =
+-		irq_domain_add_linear(NULL, PCI_MSI_DOORBELL_NR,
++		irq_domain_add_linear(NULL, msi_nr,
+ 				      &armada_370_xp_msi_domain_ops, NULL);
+ 	if (!armada_370_xp_msi_inner_domain)
+ 		return -ENOMEM;
+@@ -288,7 +299,7 @@ static int armada_370_xp_msi_init(struct device_node *node,
+ 	}
+ 
+ 	reg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS)
+-		| PCI_MSI_DOORBELL_MASK;
++		| msi_mask;
+ 
+ 	writel(reg, per_cpu_int_base +
+ 	       ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+@@ -296,6 +307,10 @@ static int armada_370_xp_msi_init(struct device_node *node,
+ 	/* Unmask MSI interrupt */
+ 	writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+ 
++	/* Unmask low 16 MSI irqs on non-IPI platforms */
++	if (parent_irq > 0)
++		writel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++
+ 	return 0;
+ }
+ #else
+@@ -586,23 +601,25 @@ static const struct irq_domain_ops armada_370_xp_mpic_irq_ops = {
+ #ifdef CONFIG_PCI_MSI
+ static void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)
+ {
++	u32 msi_start = (parent_irq <= 0) ? PCI_MSI_DOORBELL_START : PCI_MSI_FULL_DOORBELL_START;
++	u32 msi_end = (parent_irq <= 0) ? PCI_MSI_DOORBELL_END : PCI_MSI_FULL_DOORBELL_END;
++	u32 msi_mask = (parent_irq <= 0) ? PCI_MSI_DOORBELL_MASK: PCI_MSI_FULL_DOORBELL_MASK;
+ 	u32 msimask, msinr;
+ 
+ 	msimask = readl_relaxed(per_cpu_int_base +
+ 				ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)
+-		& PCI_MSI_DOORBELL_MASK;
++		& msi_mask;
+ 
+ 	writel(~msimask, per_cpu_int_base +
+ 	       ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);
+ 
+-	for (msinr = PCI_MSI_DOORBELL_START;
+-	     msinr < PCI_MSI_DOORBELL_END; msinr++) {
++	for (msinr = msi_start; msinr < msi_end; msinr++) {
+ 		unsigned int irq;
+ 
+ 		if (!(msimask & BIT(msinr)))
+ 			continue;
+ 
+-		irq = msinr - PCI_MSI_DOORBELL_START;
++		irq = msinr - msi_start;
+ 
+ 		if (is_chained)
+ 			generic_handle_domain_irq(armada_370_xp_msi_inner_domain,
+@@ -636,7 +653,7 @@ static void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)
+ 		if (!(irqsrc & ARMADA_370_XP_INT_IRQ_FIQ_MASK(cpuid)))
+ 			continue;
+ 
+-		if (irqn == 1) {
++		if (irqn == 0 || irqn == 1) {
+ 			armada_370_xp_handle_msi_irq(NULL, true);
+ 			continue;
+ 		}
+@@ -737,10 +754,19 @@ static void armada_370_xp_mpic_resume(void)
+ 	writel(doorbell_mask_reg,
+ 	       per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+ 	/* IPI is used only when we do not have parent irq */
+-	if (parent_irq <= 0 && (doorbell_mask_reg & IPI_DOORBELL_MASK))
+-		writel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+-	if (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)
+-		writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++	if (parent_irq <= 0) {
++		/* On IPI platforms is source 0 used for IPI and source 1 for MSI */
++		if (doorbell_mask_reg & IPI_DOORBELL_MASK)
++			writel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++		if (doorbell_mask_reg & PCI_MSI_DOORBELL_MASK)
++			writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++	} else {
++		/* On non-IPI platforms is source 0 used for MSI 0-15 and 1 for MSI 16-31 */
++		if (doorbell_mask_reg & GENMASK(15, 0))
++			writel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++		if (doorbell_mask_reg & GENMASK(31, 16))
++			writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++	}
+ 
+ 	/* IPI is used only when we do not have parent irq */
+ 	if (parent_irq <= 0)
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0067-dt-bindings-PCI-mvebu-Update-information-about-error.patch b/target/linux/generic/pending-5.15/0067-dt-bindings-PCI-mvebu-Update-information-about-error.patch
new file mode 100644
index 0000000000..c0e08dd915
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0067-dt-bindings-PCI-mvebu-Update-information-about-error.patch
@@ -0,0 +1,32 @@
+From 71d68bf335708fe14724bd520d72afcd71ee56dd Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 2 Nov 2021 11:06:18 +0100
+Subject: [PATCH 67/90] dt-bindings: PCI: mvebu: Update information about error
+ interrupt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+mvebu error interrupt is triggered by any non-intx event, which is mainly
+some pcie error.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ Documentation/devicetree/bindings/pci/mvebu-pci.txt | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/Documentation/devicetree/bindings/pci/mvebu-pci.txt b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+index 6d022a9d36ee..8f0bca42113f 100644
+--- a/Documentation/devicetree/bindings/pci/mvebu-pci.txt
++++ b/Documentation/devicetree/bindings/pci/mvebu-pci.txt
+@@ -83,6 +83,7 @@ and the following optional properties:
+   specified will default to 100ms, as required by the PCIe specification.
+ - interrupt-names: list of interrupt names, supported are:
+    - "intx" - interrupt line triggered by one of the legacy interrupt
++   - "error" - interrupt line triggered by any other event (non-intx)
+ - interrupts or interrupts-extended: List of the interrupt sources which
+   corresponding to the "interrupt-names". If non-empty then also additional
+   'interrupt-controller' subnode must be defined.
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0068-PCI-mvebu-Implement-support-for-interrupts-on-emulat.patch b/target/linux/generic/pending-5.15/0068-PCI-mvebu-Implement-support-for-interrupts-on-emulat.patch
new file mode 100644
index 0000000000..a26cd8aece
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0068-PCI-mvebu-Implement-support-for-interrupts-on-emulat.patch
@@ -0,0 +1,437 @@
+From 580e9959e0110a244ffec06c4007921737955748 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:40:17 +0200
+Subject: [PATCH 68/90] PCI: mvebu: Implement support for interrupts on
+ emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for PME and ERR interrupts reported by emulated bridge
+(for PME and AER kernel drivers) via new Root Port irq chip as these
+interrupts from PCIe Root Ports are handled by mvebu hardware completely
+separately from INTx and MSI interrupts send by real PCIe devices.
+
+With this change, kernel PME and AER drivers start working as they can
+acquire required interrupt lines (provided by mvebu rp virtual irq chip).
+
+Note that for this support, device tree files has to be properly adjusted
+to provide "interrupts" or "interrupts-extended" property with error
+interrupt source and "interrupt-names" property with "error" string.
+
+If device tree files do not provide these properties then driver would work
+as before and would not provide interrupts on emulated bridge, like before.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 256 ++++++++++++++++++++++++++---
+ 1 file changed, 237 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index c5e5bc085a9d..319cd2b98545 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -56,8 +56,16 @@
+ #define PCIE_CONF_DATA_OFF	0x18fc
+ #define PCIE_INT_CAUSE_OFF	0x1900
+ #define PCIE_INT_UNMASK_OFF	0x1910
++#define  PCIE_INT_DET_COR		BIT(8)
++#define  PCIE_INT_DET_NONFATAL		BIT(9)
++#define  PCIE_INT_DET_FATAL		BIT(10)
++#define  PCIE_INT_ERR_FATAL		BIT(16)
++#define  PCIE_INT_ERR_NONFATAL		BIT(17)
++#define  PCIE_INT_ERR_COR		BIT(18)
+ #define  PCIE_INT_INTX(i)		BIT(24+i)
+ #define  PCIE_INT_PM_PME		BIT(28)
++#define  PCIE_INT_DET_MASK		(PCIE_INT_DET_COR | PCIE_INT_DET_NONFATAL | PCIE_INT_DET_FATAL)
++#define  PCIE_INT_ERR_MASK		(PCIE_INT_ERR_FATAL | PCIE_INT_ERR_NONFATAL | PCIE_INT_ERR_COR)
+ #define  PCIE_INT_ALL_MASK		GENMASK(31, 0)
+ #define PCIE_CTRL_OFF		0x1a00
+ #define  PCIE_CTRL_X1_MODE		0x0001
+@@ -120,9 +128,12 @@ struct mvebu_pcie_port {
+ 	struct resource regs;
+ 	u8 slot_power_limit_value;
+ 	u8 slot_power_limit_scale;
++	struct irq_domain *rp_irq_domain;
+ 	struct irq_domain *intx_irq_domain;
+ 	raw_spinlock_t irq_lock;
++	int error_irq;
+ 	int intx_irq;
++	bool pme_pending;
+ };
+ 
+ static inline void mvebu_writel(struct mvebu_pcie_port *port, u32 val, u32 reg)
+@@ -321,9 +332,19 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	/* Clear all interrupt causes. */
+ 	mvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);
+ 
+-	/* Check if "intx" interrupt was specified in DT. */
+-	if (port->intx_irq > 0)
+-		return;
++	/*
++	 * Unmask all error interrupts which are internally generated.
++	 * They cannot be disabled by SERR# Enable bit in PCI Command register,
++	 * see Figure 6-3: Pseudo Logic Diagram for Error Message Controls in
++	 * PCIe base specification.
++	 * Internally generated mvebu interrupts are reported via mvebu summary
++	 * interrupt which requires "error" interrupt to be specified in DT.
++	 */
++	if (port->error_irq > 0) {
++		unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++		unmask |= PCIE_INT_DET_MASK;
++		mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	}
+ 
+ 	/*
+ 	 * Fallback code when "intx" interrupt was not specified in DT:
+@@ -335,10 +356,12 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	 * performance penalty as every PCIe interrupt handler needs to be
+ 	 * called when some interrupt is triggered.
+ 	 */
+-	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
+-	unmask |= PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |
+-		  PCIE_INT_INTX(2) | PCIE_INT_INTX(3);
+-	mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	if (port->intx_irq <= 0) {
++		unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++		unmask |= PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |
++			  PCIE_INT_INTX(2) | PCIE_INT_INTX(3);
++		mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	}
+ }
+ 
+ static struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,
+@@ -603,11 +626,16 @@ mvebu_pci_bridge_emul_base_conf_read(struct pci_bridge_emul *bridge,
+ 	case PCI_INTERRUPT_LINE: {
+ 		/*
+ 		 * From the whole 32bit register we support reading from HW only
+-		 * one bit: PCI_BRIDGE_CTL_BUS_RESET.
++		 * two bits: PCI_BRIDGE_CTL_BUS_RESET and PCI_BRIDGE_CTL_SERR.
+ 		 * Other bits are retrieved only from emulated config buffer.
+ 		 */
+ 		__le32 *cfgspace = (__le32 *)&bridge->conf;
+ 		u32 val = le32_to_cpu(cfgspace[PCI_INTERRUPT_LINE / 4]);
++		if ((mvebu_readl(port, PCIE_INT_UNMASK_OFF) &
++		      PCIE_INT_ERR_MASK) == PCIE_INT_ERR_MASK)
++			val |= PCI_BRIDGE_CTL_SERR << 16;
++		else
++			val &= ~(PCI_BRIDGE_CTL_SERR << 16);
+ 		if (mvebu_readl(port, PCIE_CTRL_OFF) & PCIE_CTRL_MASTER_HOT_RESET)
+ 			val |= PCI_BRIDGE_CTL_BUS_RESET << 16;
+ 		else
+@@ -675,6 +703,11 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 		break;
+ 	}
+ 
++	case PCI_EXP_RTCTL:
++		*value = (mvebu_readl(port, PCIE_INT_UNMASK_OFF) &
++			  PCIE_INT_PM_PME) ? PCI_EXP_RTCTL_PMEIE : 0;
++		break;
++
+ 	case PCI_EXP_RTSTA:
+ 		*value = mvebu_readl(port, PCIE_RC_RTSTA);
+ 		break;
+@@ -780,6 +813,14 @@ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 		break;
+ 
+ 	case PCI_INTERRUPT_LINE:
++		if ((mask & (PCI_BRIDGE_CTL_SERR << 16)) && port->error_irq > 0) {
++			u32 unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++			if (new & (PCI_BRIDGE_CTL_SERR << 16))
++				unmask |= PCIE_INT_ERR_MASK;
++			else
++				unmask &= ~PCIE_INT_ERR_MASK;
++			mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++		}
+ 		if (mask & (PCI_BRIDGE_CTL_BUS_RESET << 16)) {
+ 			u32 ctrl = mvebu_readl(port, PCIE_CTRL_OFF);
+ 			if (new & (PCI_BRIDGE_CTL_BUS_RESET << 16))
+@@ -838,10 +879,25 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 		 * PME Status bit in Root Status Register (PCIE_RC_RTSTA)
+ 		 * is read-only and can be cleared only by writing 0b to the
+ 		 * Interrupt Cause RW0C register (PCIE_INT_CAUSE_OFF). So
+-		 * clear PME via Interrupt Cause.
++		 * clear PME via Interrupt Cause and also set port->pme_pending
++		 * variable to false value to start processing PME interrupts
++		 * in interrupt handler again.
+ 		 */
+-		if (new & PCI_EXP_RTSTA_PME)
++		if (new & PCI_EXP_RTSTA_PME) {
+ 			mvebu_writel(port, ~PCIE_INT_PM_PME, PCIE_INT_CAUSE_OFF);
++			port->pme_pending = false;
++		}
++		break;
++
++	case PCI_EXP_RTCTL:
++		if ((mask & PCI_EXP_RTCTL_PMEIE) && port->error_irq > 0) {
++			u32 unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++			if (new & PCI_EXP_RTCTL_PMEIE)
++				unmask |= PCIE_INT_PM_PME;
++			else
++				unmask &= ~PCIE_INT_PM_PME;
++			mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++		}
+ 		break;
+ 
+ 	case PCI_EXP_DEVCTL2:
+@@ -924,6 +980,14 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 		bridge_flags |= PCI_BRIDGE_EMUL_NO_IO_FORWARD;
+ 	}
+ 
++	/*
++	 * Interrupts on emulated bridge are supported only when "error"
++	 * interrupt was specified in DT. Without it emulated bridge cannot
++	 * emulate interrupts.
++	 */
++	if (port->error_irq > 0)
++		bridge->conf.intpin = PCI_INTERRUPT_INTA;
++
+ 	/*
+ 	 * Older mvebu hardware provides PCIe Capability structure only in
+ 	 * version 1. New hardware provides it in version 2.
+@@ -1072,6 +1136,26 @@ static const struct irq_domain_ops mvebu_pcie_intx_irq_domain_ops = {
+ 	.xlate = irq_domain_xlate_onecell,
+ };
+ 
++static struct irq_chip rp_irq_chip = {
++	.name = "mvebu-rp",
++};
++
++static int mvebu_pcie_rp_irq_map(struct irq_domain *h,
++				   unsigned int virq, irq_hw_number_t hwirq)
++{
++	struct mvebu_pcie_port *port = h->host_data;
++
++	irq_set_chip_and_handler(virq, &rp_irq_chip, handle_simple_irq);
++	irq_set_chip_data(virq, port);
++
++	return 0;
++}
++
++static const struct irq_domain_ops mvebu_pcie_rp_irq_domain_ops = {
++	.map = mvebu_pcie_rp_irq_map,
++	.xlate = irq_domain_xlate_onecell,
++};
++
+ static int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)
+ {
+ 	struct device *dev = &port->pcie->pdev->dev;
+@@ -1094,10 +1178,72 @@ static int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)
+ 		return -ENOMEM;
+ 	}
+ 
++	/*
++	 * When "error" interrupt was not specified in DT then there is no
++	 * support for interrupts on emulated root bridge. So skip following
++	 * initialization.
++	 */
++	if (port->error_irq <= 0)
++		return 0;
++
++	port->rp_irq_domain = irq_domain_add_linear(NULL, 1,
++						      &mvebu_pcie_rp_irq_domain_ops,
++						      port);
++	if (!port->rp_irq_domain) {
++		irq_domain_remove(port->intx_irq_domain);
++		dev_err(dev, "Failed to add Root Port IRQ domain for %s\n", port->name);
++		return -ENOMEM;
++	}
++
+ 	return 0;
+ }
+ 
+-static irqreturn_t mvebu_pcie_irq_handler(int irq, void *arg)
++static irqreturn_t mvebu_pcie_error_irq_handler(int irq, void *arg)
++{
++	struct mvebu_pcie_port *port = arg;
++	struct device *dev = &port->pcie->pdev->dev;
++	u32 cause, unmask, status;
++
++	cause = mvebu_readl(port, PCIE_INT_CAUSE_OFF);
++	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++	status = cause & unmask;
++
++	/* "error" interrupt handler does not process INTX interrupts */
++	status &= ~(PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |
++		    PCIE_INT_INTX(2) | PCIE_INT_INTX(3));
++
++	/* Process PME interrupt */
++	if ((status & PCIE_INT_PM_PME) && !port->pme_pending) {
++		/*
++		 * Do not clear PME interrupt bit in Cause Register as it
++		 * invalidates also content of Root Status Register. Instead
++		 * set port->pme_pending variable to true to indicate that
++		 * next time PME interrupt should be ignored until variable
++		 * is back to the false value.
++		 */
++		port->pme_pending = true;
++		if (generic_handle_domain_irq(port->rp_irq_domain, 0) == -EINVAL)
++			dev_err_ratelimited(dev, "unhandled PME IRQ\n");
++	}
++
++	/* Process ERR interrupt */
++	if (status & PCIE_INT_ERR_MASK) {
++		mvebu_writel(port, ~PCIE_INT_ERR_MASK, PCIE_INT_CAUSE_OFF);
++		if (generic_handle_domain_irq(port->rp_irq_domain, 0) == -EINVAL)
++			dev_err_ratelimited(dev, "unhandled ERR IRQ\n");
++	}
++
++	/* Process local ERR interrupt */
++	if (status & PCIE_INT_DET_MASK) {
++		mvebu_writel(port, ~PCIE_INT_DET_MASK, PCIE_INT_CAUSE_OFF);
++		if (generic_handle_domain_irq(port->rp_irq_domain, 0) == -EINVAL)
++			dev_err_ratelimited(dev, "unhandled ERR IRQ\n");
++	}
++
++	return status ? IRQ_HANDLED : IRQ_NONE;
++}
++
++static irqreturn_t mvebu_pcie_intx_irq_handler(int irq, void *arg)
+ {
+ 	struct mvebu_pcie_port *port = arg;
+ 	struct device *dev = &port->pcie->pdev->dev;
+@@ -1108,6 +1254,10 @@ static irqreturn_t mvebu_pcie_irq_handler(int irq, void *arg)
+ 	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
+ 	status = cause & unmask;
+ 
++	/* "intx" interrupt handler process only INTX interrupts */
++	status &= PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |
++		  PCIE_INT_INTX(2) | PCIE_INT_INTX(3);
++
+ 	/* Process legacy INTx interrupts */
+ 	for (i = 0; i < PCI_NUM_INTX; i++) {
+ 		if (!(status & PCIE_INT_INTX(i)))
+@@ -1122,9 +1272,29 @@ static irqreturn_t mvebu_pcie_irq_handler(int irq, void *arg)
+ 
+ static int mvebu_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+ {
+-	/* Interrupt support on mvebu emulated bridges is not implemented yet */
+-	if (dev->bus->number == 0)
+-		return 0; /* Proper return code 0 == NO_IRQ */
++	struct mvebu_pcie_port *port;
++	struct mvebu_pcie *pcie;
++
++	if (dev->bus->number == 0) {
++		/*
++		 * Each emulated root bridge for every mvebu port has its own
++		 * Root Port irq chip and irq domain. Argument pin is the INTx
++		 * pin (1=INTA, 2=INTB, 3=INTC, 4=INTD) and hwirq for function
++		 * irq_create_mapping() is indexed from zero.
++		 */
++		pcie = dev->bus->sysdata;
++		port = mvebu_pcie_find_port(pcie, dev->bus, PCI_DEVFN(slot, 0));
++		if (!port)
++			return 0; /* Proper return code 0 == NO_IRQ */
++		/*
++		 * port->rp_irq_domain is available only when "error" interrupt
++		 * was specified in DT. When is not available then interrupts
++		 * for emulated root bridge are not provided.
++		 */
++		if (port->error_irq <= 0)
++			return 0; /* Proper return code 0 == NO_IRQ */
++		return irq_create_mapping(port->rp_irq_domain, pin - 1);
++	}
+ 
+ 	return of_irq_parse_and_map_pci(dev, slot, pin);
+ }
+@@ -1333,6 +1503,21 @@ static int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,
+ 			 port->name, child);
+ 	}
+ 
++	/*
++	 * Old DT bindings do not contain "error" interrupt
++	 * so do not fail probing driver when interrupt does not exist.
++	 */
++	port->error_irq = of_irq_get_byname(child, "error");
++	if (port->error_irq == -EPROBE_DEFER) {
++		ret = port->error_irq;
++		goto err;
++	}
++	if (port->error_irq <= 0) {
++		dev_warn(dev, "%s: interrupts on Root Port are unsupported, "
++			      "%pOF does not contain error interrupt\n",
++			 port->name, child);
++	}
++
+ 	reset_gpio = of_get_named_gpio_flags(child, "reset-gpios", 0, &flags);
+ 	if (reset_gpio == -EPROBE_DEFER) {
+ 		ret = reset_gpio;
+@@ -1538,7 +1723,6 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 
+ 	for (i = 0; i < pcie->nports; i++) {
+ 		struct mvebu_pcie_port *port = &pcie->ports[i];
+-		int irq = port->intx_irq;
+ 
+ 		child = port->dn;
+ 		if (!child)
+@@ -1566,7 +1750,7 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 			continue;
+ 		}
+ 
+-		if (irq > 0) {
++		if (port->error_irq > 0 || port->intx_irq > 0) {
+ 			ret = mvebu_pcie_init_irq_domain(port);
+ 			if (ret) {
+ 				dev_err(dev, "%s: cannot init irq domain\n",
+@@ -1577,14 +1761,42 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 				mvebu_pcie_powerdown(port);
+ 				continue;
+ 			}
++		}
++
++		if (port->error_irq > 0) {
++			ret = devm_request_irq(dev, port->error_irq,
++					       mvebu_pcie_error_irq_handler,
++					       IRQF_SHARED | IRQF_NO_THREAD,
++					       port->name, port);
++			if (ret) {
++				dev_err(dev, "%s: cannot register error interrupt handler: %d\n",
++					port->name, ret);
++				if (port->intx_irq_domain)
++					irq_domain_remove(port->intx_irq_domain);
++				if (port->rp_irq_domain)
++					irq_domain_remove(port->rp_irq_domain);
++				pci_bridge_emul_cleanup(&port->bridge);
++				devm_iounmap(dev, port->base);
++				port->base = NULL;
++				mvebu_pcie_powerdown(port);
++				continue;
++			}
++		}
+ 
+-			ret = devm_request_irq(dev, irq, mvebu_pcie_irq_handler,
++		if (port->intx_irq > 0) {
++			ret = devm_request_irq(dev, port->intx_irq,
++					       mvebu_pcie_intx_irq_handler,
+ 					       IRQF_SHARED | IRQF_NO_THREAD,
+ 					       port->name, port);
+ 			if (ret) {
+-				dev_err(dev, "%s: cannot register interrupt handler: %d\n",
++				dev_err(dev, "%s: cannot register intx interrupt handler: %d\n",
+ 					port->name, ret);
+-				irq_domain_remove(port->intx_irq_domain);
++				if (port->error_irq > 0)
++					devm_free_irq(dev, port->error_irq, port);
++				if (port->intx_irq_domain)
++					irq_domain_remove(port->intx_irq_domain);
++				if (port->rp_irq_domain)
++					irq_domain_remove(port->rp_irq_domain);
+ 				pci_bridge_emul_cleanup(&port->bridge);
+ 				devm_iounmap(dev, port->base);
+ 				port->base = NULL;
+@@ -1722,6 +1934,12 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 			}
+ 			irq_domain_remove(port->intx_irq_domain);
+ 		}
++		if (port->rp_irq_domain) {
++			int virq = irq_find_mapping(port->rp_irq_domain, 0);
++			if (virq > 0)
++				irq_dispose_mapping(virq);
++			irq_domain_remove(port->rp_irq_domain);
++		}
+ 
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0069-ARM-dts-kirkwood-Add-definitions-for-PCIe-error-inte.patch b/target/linux/generic/pending-5.15/0069-ARM-dts-kirkwood-Add-definitions-for-PCIe-error-inte.patch
new file mode 100644
index 0000000000..e1b97f94cd
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0069-ARM-dts-kirkwood-Add-definitions-for-PCIe-error-inte.patch
@@ -0,0 +1,94 @@
+From 1e7448b4d20311d861dd8e7e9cfa60fea643b001 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:15:56 +0200
+Subject: [PATCH 69/90] ARM: dts: kirkwood: Add definitions for PCIe error
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+First PCIe controller on Kirkwood SoC reports error interrupt via IRQ 44
+and second PCIe controller via IRQ 45.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/kirkwood-6192.dtsi     | 4 ++--
+ arch/arm/boot/dts/kirkwood-6281.dtsi     | 4 ++--
+ arch/arm/boot/dts/kirkwood-6282.dtsi     | 8 ++++----
+ arch/arm/boot/dts/kirkwood-98dx4122.dtsi | 4 ++--
+ 4 files changed, 10 insertions(+), 10 deletions(-)
+
+diff --git a/arch/arm/boot/dts/kirkwood-6192.dtsi b/arch/arm/boot/dts/kirkwood-6192.dtsi
+index 07f4f7f98c0c..705c0d7effed 100644
+--- a/arch/arm/boot/dts/kirkwood-6192.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6192.dtsi
+@@ -26,8 +26,8 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-names = "intx";
+-				interrupts = <9>;
++				interrupt-names = "intx", "error";
++				interrupts = <9>, <44>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie_intc 0>,
+ 						<0 0 0 2 &pcie_intc 1>,
+diff --git a/arch/arm/boot/dts/kirkwood-6281.dtsi b/arch/arm/boot/dts/kirkwood-6281.dtsi
+index d08a9a5ecc26..8e311165fd13 100644
+--- a/arch/arm/boot/dts/kirkwood-6281.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6281.dtsi
+@@ -26,8 +26,8 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-names = "intx";
+-				interrupts = <9>;
++				interrupt-names = "intx", "error";
++				interrupts = <9>, <44>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie_intc 0>,
+ 						<0 0 0 2 &pcie_intc 1>,
+diff --git a/arch/arm/boot/dts/kirkwood-6282.dtsi b/arch/arm/boot/dts/kirkwood-6282.dtsi
+index 2eea5b304f47..e33723160ce7 100644
+--- a/arch/arm/boot/dts/kirkwood-6282.dtsi
++++ b/arch/arm/boot/dts/kirkwood-6282.dtsi
+@@ -30,8 +30,8 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-names = "intx";
+-				interrupts = <9>;
++				interrupt-names = "intx", "error";
++				interrupts = <9>, <44>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
+ 						<0 0 0 2 &pcie0_intc 1>,
+@@ -58,8 +58,8 @@ pcie1: pcie@2,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-names = "intx";
+-				interrupts = <10>;
++				interrupt-names = "intx", "error";
++				interrupts = <10>, <45>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
+ 						<0 0 0 2 &pcie1_intc 1>,
+diff --git a/arch/arm/boot/dts/kirkwood-98dx4122.dtsi b/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
+index 070bc13242b8..c3469a2fc58a 100644
+--- a/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
++++ b/arch/arm/boot/dts/kirkwood-98dx4122.dtsi
+@@ -26,8 +26,8 @@ pcie0: pcie@1,0 {
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+ 				bus-range = <0x00 0xff>;
+-				interrupt-names = "intx";
+-				interrupts = <9>;
++				interrupt-names = "intx", "error";
++				interrupts = <9>, <44>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie_intc 0>,
+ 						<0 0 0 2 &pcie_intc 1>,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0070-ARM-dts-dove-Add-definitions-for-PCIe-error-interrup.patch b/target/linux/generic/pending-5.15/0070-ARM-dts-dove-Add-definitions-for-PCIe-error-interrup.patch
new file mode 100644
index 0000000000..194d64eb72
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0070-ARM-dts-dove-Add-definitions-for-PCIe-error-interrup.patch
@@ -0,0 +1,46 @@
+From db1cf8c55bbea9735a91e550bcea4b2d9abf1d39 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:18:11 +0200
+Subject: [PATCH 70/90] ARM: dts: dove: Add definitions for PCIe error
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+First PCIe controller on Dove SoC reports error interrupt via IRQ 15
+and second PCIe controller via IRQ 17.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/dove.dtsi | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi
+index 70d45d2b1258..9aee3cfd3e98 100644
+--- a/arch/arm/boot/dts/dove.dtsi
++++ b/arch/arm/boot/dts/dove.dtsi
+@@ -122,8 +122,8 @@ pcie0: pcie@1 {
+ 				bus-range = <0x00 0xff>;
+ 
+ 				#interrupt-cells = <1>;
+-				interrupt-names = "intx";
+-				interrupts = <16>;
++				interrupt-names = "intx", "error";
++				interrupts = <16>, <15>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie0_intc 0>,
+ 						<0 0 0 2 &pcie0_intc 1>,
+@@ -151,8 +151,8 @@ pcie1: pcie@2 {
+ 				bus-range = <0x00 0xff>;
+ 
+ 				#interrupt-cells = <1>;
+-				interrupt-names = "intx";
+-				interrupts = <18>;
++				interrupt-names = "intx", "error";
++				interrupts = <18>, <17>;
+ 				interrupt-map-mask = <0 0 0 7>;
+ 				interrupt-map = <0 0 0 1 &pcie1_intc 0>,
+ 						<0 0 0 2 &pcie1_intc 1>,
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0071-dt-bindings-irqchip-armada-370-xp-Update-information.patch b/target/linux/generic/pending-5.15/0071-dt-bindings-irqchip-armada-370-xp-Update-information.patch
new file mode 100644
index 0000000000..2819708f5b
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0071-dt-bindings-irqchip-armada-370-xp-Update-information.patch
@@ -0,0 +1,42 @@
+From 7324692109764dbd416a308e796ef1d463d07100 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 6 May 2022 14:22:28 +0200
+Subject: [PATCH 71/90] dt-bindings: irqchip: armada-370-xp: Update information
+ about MPIC SoC Error
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ .../interrupt-controller/marvell,armada-370-xp-mpic.txt  | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/Documentation/devicetree/bindings/interrupt-controller/marvell,armada-370-xp-mpic.txt b/Documentation/devicetree/bindings/interrupt-controller/marvell,armada-370-xp-mpic.txt
+index 5fc03134a999..8cddbc16ddbd 100644
+--- a/Documentation/devicetree/bindings/interrupt-controller/marvell,armada-370-xp-mpic.txt
++++ b/Documentation/devicetree/bindings/interrupt-controller/marvell,armada-370-xp-mpic.txt
+@@ -24,6 +24,11 @@ Optional properties:
+   connected as a slave to the Cortex-A9 GIC. The provided interrupt
+   indicate to which GIC interrupt the MPIC output is connected.
+ 
++Optional subnodes:
++
++- interrupt-controller@20 with interrupt-controller property for
++  MPIC SoC Error IRQ controller
++
+ Example:
+ 
+         mpic: interrupt-controller@d0020000 {
+@@ -35,4 +40,8 @@ Example:
+               msi-controller;
+               reg = <0xd0020a00 0x1d0>,
+                     <0xd0021070 0x58>;
++              soc_err: interrupt-controller@20 {
++                    interrupt-controller;
++                    #interrupt-cells = <1>;
++              };
+         };
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0072-irqchip-armada-370-xp-Implement-SoC-Error-interrupts.patch b/target/linux/generic/pending-5.15/0072-irqchip-armada-370-xp-Implement-SoC-Error-interrupts.patch
new file mode 100644
index 0000000000..5bd67868bc
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0072-irqchip-armada-370-xp-Implement-SoC-Error-interrupts.patch
@@ -0,0 +1,348 @@
+From e4f14222579ceded47baafcbe10fc78f080e538b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 18 Apr 2022 00:04:32 +0200
+Subject: [PATCH 72/90] irqchip/armada-370-xp: Implement SoC Error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+MPIC IRQ 4 is used as SoC Error Summary interrupt and provides access to
+another hierarchy of SoC Error interrupts. Implement a new IRQ chip and
+domain for accessing this IRQ hierarchy.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/irqchip/irq-armada-370-xp.c | 212 +++++++++++++++++++++++++++-
+ 1 file changed, 209 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/irqchip/irq-armada-370-xp.c b/drivers/irqchip/irq-armada-370-xp.c
+index 8abc70ed30c1..2df9e21e1559 100644
+--- a/drivers/irqchip/irq-armada-370-xp.c
++++ b/drivers/irqchip/irq-armada-370-xp.c
+@@ -117,6 +117,8 @@
+ /* Registers relative to main_int_base */
+ #define ARMADA_370_XP_INT_CONTROL		(0x00)
+ #define ARMADA_370_XP_SW_TRIG_INT_OFFS		(0x04)
++#define ARMADA_370_XP_INT_SOC_ERR_0_CAUSE_OFFS	(0x20)
++#define ARMADA_370_XP_INT_SOC_ERR_1_CAUSE_OFFS	(0x24)
+ #define ARMADA_370_XP_INT_SET_ENABLE_OFFS	(0x30)
+ #define ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS	(0x34)
+ #define ARMADA_370_XP_INT_SOURCE_CTL(irq)	(0x100 + irq*4)
+@@ -130,6 +132,8 @@
+ #define ARMADA_370_XP_CPU_INTACK_OFFS		(0x44)
+ #define ARMADA_370_XP_INT_SET_MASK_OFFS		(0x48)
+ #define ARMADA_370_XP_INT_CLEAR_MASK_OFFS	(0x4C)
++#define ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF	(0x50)
++#define ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF	(0x54)
+ #define ARMADA_370_XP_INT_FABRIC_MASK_OFFS	(0x54)
+ #define ARMADA_370_XP_INT_CAUSE_PERF(cpu)	(1 << cpu)
+ 
+@@ -153,6 +157,8 @@
+ static void __iomem *per_cpu_int_base;
+ static void __iomem *main_int_base;
+ static struct irq_domain *armada_370_xp_mpic_domain;
++static struct irq_domain *armada_370_xp_soc_err_domain;
++static unsigned int soc_err_irq_num_regs;
+ static u32 doorbell_mask_reg;
+ static int parent_irq;
+ #ifdef CONFIG_PCI_MSI
+@@ -163,6 +169,8 @@ static DEFINE_MUTEX(msi_used_lock);
+ static phys_addr_t msi_doorbell_addr;
+ #endif
+ 
++static void armada_370_xp_soc_err_irq_unmask(struct irq_data *d);
++
+ static inline bool is_percpu_irq(irq_hw_number_t irq)
+ {
+ 	if (irq <= ARMADA_370_XP_MAX_PER_CPU_IRQS)
+@@ -528,6 +536,27 @@ static void armada_xp_mpic_reenable_percpu(void)
+ 		armada_370_xp_irq_unmask(data);
+ 	}
+ 
++	/* Re-enable per-CPU SoC Error interrupts that were enabled before suspend */
++	for (irq = 0; irq < soc_err_irq_num_regs * 32; irq++) {
++		struct irq_data *data;
++		int virq;
++
++		virq = irq_linear_revmap(armada_370_xp_soc_err_domain, irq);
++		if (virq == 0)
++			continue;
++
++		data = irq_get_irq_data(virq);
++
++		if (!irq_percpu_is_enabled(virq))
++			continue;
++
++		armada_370_xp_soc_err_irq_unmask(data);
++	}
++
++	/* Unmask summary SoC Error Interrupt */
++	if (soc_err_irq_num_regs > 0)
++		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++
+ 	/* IPI is used only when we do not have parent irq */
+ 	if (parent_irq <= 0)
+ 		ipi_resume();
+@@ -567,8 +596,8 @@ static struct irq_chip armada_370_xp_irq_chip = {
+ static int armada_370_xp_mpic_irq_map(struct irq_domain *h,
+ 				      unsigned int virq, irq_hw_number_t hw)
+ {
+-	/* IRQs 0 and 1 cannot be mapped, they are handled internally */
+-	if (hw <= 1)
++	/* IRQs 0, 1 and 4 cannot be mapped, they are handled internally */
++	if (hw <= 1 || hw == 4)
+ 		return -EINVAL;
+ 
+ 	armada_370_xp_irq_mask(irq_get_irq_data(virq));
+@@ -598,6 +627,98 @@ static const struct irq_domain_ops armada_370_xp_mpic_irq_ops = {
+ 	.xlate = irq_domain_xlate_onecell,
+ };
+ 
++static DEFINE_RAW_SPINLOCK(armada_370_xp_soc_err_lock);
++
++static void armada_370_xp_soc_err_irq_mask(struct irq_data *d)
++{
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 reg, mask;
++
++	reg = hwirq >= 32 ? ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF
++			  : ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF;
++
++	raw_spin_lock(&armada_370_xp_soc_err_lock);
++	mask = readl(per_cpu_int_base + reg);
++	mask &= ~BIT(hwirq % 32);
++	writel(mask, per_cpu_int_base + reg);
++	raw_spin_unlock(&armada_370_xp_soc_err_lock);
++}
++
++static void armada_370_xp_soc_err_irq_unmask(struct irq_data *d)
++{
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	u32 reg, mask;
++
++	reg = hwirq >= 32 ? ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF
++			  : ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF;
++
++	raw_spin_lock(&armada_370_xp_soc_err_lock);
++	mask = readl(per_cpu_int_base + reg);
++	mask |= BIT(hwirq % 32);
++	writel(mask, per_cpu_int_base + reg);
++	raw_spin_unlock(&armada_370_xp_soc_err_lock);
++}
++
++static int armada_370_xp_soc_err_irq_mask_on_cpu(void *par)
++{
++	struct irq_data *d = par;
++	armada_370_xp_soc_err_irq_mask(d);
++	return 0;
++}
++
++static int armada_370_xp_soc_err_irq_unmask_on_cpu(void *par)
++{
++	struct irq_data *d = par;
++	armada_370_xp_soc_err_irq_unmask(d);
++	return 0;
++}
++
++static int armada_xp_soc_err_irq_set_affinity(struct irq_data *d,
++					      const struct cpumask *mask,
++					      bool force)
++{
++	unsigned int cpu;
++
++	cpus_read_lock();
++
++	/* First disable IRQ on all cores */
++	for_each_online_cpu(cpu)
++		smp_call_on_cpu(cpu, armada_370_xp_soc_err_irq_mask_on_cpu, d, true);
++
++	/* Select a single core from the affinity mask which is online */
++	cpu = cpumask_any_and(mask, cpu_online_mask);
++	smp_call_on_cpu(cpu, armada_370_xp_soc_err_irq_unmask_on_cpu, d, true);
++
++	cpus_read_unlock();
++
++	irq_data_update_effective_affinity(d, cpumask_of(cpu));
++
++	return IRQ_SET_MASK_OK;
++}
++
++static struct irq_chip armada_370_xp_soc_err_irq_chip = {
++	.name = "MPIC SOC",
++	.irq_mask = armada_370_xp_soc_err_irq_mask,
++	.irq_unmask = armada_370_xp_soc_err_irq_unmask,
++	.irq_set_affinity = armada_xp_soc_err_irq_set_affinity,
++};
++
++static int armada_370_xp_soc_err_irq_map(struct irq_domain *h,
++					 unsigned int virq, irq_hw_number_t hw)
++{
++	armada_370_xp_soc_err_irq_mask(irq_get_irq_data(virq));
++	irq_set_status_flags(virq, IRQ_LEVEL);
++	irq_set_chip_and_handler(virq, &armada_370_xp_soc_err_irq_chip,
++				 handle_level_irq);
++	irq_set_probe(virq);
++	return 0;
++}
++
++static const struct irq_domain_ops armada_370_xp_soc_err_irq_ops = {
++	.map = armada_370_xp_soc_err_irq_map,
++	.xlate = irq_domain_xlate_onecell,
++};
++
+ #ifdef CONFIG_PCI_MSI
+ static void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)
+ {
+@@ -633,6 +754,32 @@ static void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)
+ static void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}
+ #endif
+ 
++static void armada_370_xp_handle_soc_err_irq(void)
++{
++	unsigned long status, bit;
++	u32 mask, cause;
++
++	if (soc_err_irq_num_regs < 1)
++		return;
++
++	mask = readl(per_cpu_int_base + ARMADA_370_XP_INT_SOC_ERR_0_MASK_OFF);
++	cause = readl(main_int_base + ARMADA_370_XP_INT_SOC_ERR_0_CAUSE_OFFS);
++	status = cause & mask;
++
++	for_each_set_bit(bit, &status, 32)
++		generic_handle_domain_irq(armada_370_xp_soc_err_domain, bit);
++
++	if (soc_err_irq_num_regs < 2)
++		return;
++
++	mask = readl(per_cpu_int_base + ARMADA_370_XP_INT_SOC_ERR_1_MASK_OFF);
++	cause = readl(main_int_base + ARMADA_370_XP_INT_SOC_ERR_1_CAUSE_OFFS);
++	status = cause & mask;
++
++	for_each_set_bit(bit, &status, 32)
++		generic_handle_domain_irq(armada_370_xp_soc_err_domain, bit + 32);
++}
++
+ static void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)
+ {
+ 	struct irq_chip *chip = irq_desc_get_chip(desc);
+@@ -658,6 +805,11 @@ static void armada_370_xp_mpic_handle_cascade_irq(struct irq_desc *desc)
+ 			continue;
+ 		}
+ 
++		if (irqn == 4) {
++			armada_370_xp_handle_soc_err_irq();
++			continue;
++		}
++
+ 		generic_handle_domain_irq(armada_370_xp_mpic_domain, irqn);
+ 	}
+ 
+@@ -677,7 +829,7 @@ armada_370_xp_handle_irq(struct pt_regs *regs)
+ 		if (irqnr > 1022)
+ 			break;
+ 
+-		if (irqnr > 1) {
++		if (irqnr > 1 && irqnr != 4) {
+ 			handle_domain_irq(armada_370_xp_mpic_domain,
+ 					  irqnr, regs);
+ 			continue;
+@@ -687,6 +839,10 @@ armada_370_xp_handle_irq(struct pt_regs *regs)
+ 		if (irqnr == 1)
+ 			armada_370_xp_handle_msi_irq(regs, false);
+ 
++		/* SoC Error handling */
++		if (irqnr == 4)
++			armada_370_xp_handle_soc_err_irq();
++
+ #ifdef CONFIG_SMP
+ 		/* IPI Handling */
+ 		if (irqnr == 0) {
+@@ -750,6 +906,26 @@ static void armada_370_xp_mpic_resume(void)
+ 		}
+ 	}
+ 
++	/* Re-enable per-CPU SoC Error interrupts */
++	for (irq = 0; irq < soc_err_irq_num_regs * 32; irq++) {
++		struct irq_data *data;
++		int virq;
++
++		virq = irq_linear_revmap(armada_370_xp_soc_err_domain, irq);
++		if (virq == 0)
++			continue;
++
++		data = irq_get_irq_data(virq);
++
++		/*
++		 * Re-enable on the current CPU,
++		 * armada_xp_mpic_reenable_percpu() will take
++		 * care of secondary CPUs when they come up.
++		 */
++		if (irq_percpu_is_enabled(virq))
++			armada_370_xp_soc_err_irq_unmask(data);
++	}
++
+ 	/* Reconfigure doorbells for IPIs and MSIs */
+ 	writel(doorbell_mask_reg,
+ 	       per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS);
+@@ -768,6 +944,10 @@ static void armada_370_xp_mpic_resume(void)
+ 			writel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
+ 	}
+ 
++	/* Unmask summary SoC Error Interrupt */
++	if (soc_err_irq_num_regs > 0)
++		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++
+ 	/* IPI is used only when we do not have parent irq */
+ 	if (parent_irq <= 0)
+ 		ipi_resume();
+@@ -782,6 +962,7 @@ static int __init armada_370_xp_mpic_of_init(struct device_node *node,
+ 					     struct device_node *parent)
+ {
+ 	struct resource main_int_res, per_cpu_int_res;
++	struct device_node *soc_err_node;
+ 	int nr_irqs, i;
+ 	u32 control;
+ 
+@@ -815,6 +996,27 @@ static int __init armada_370_xp_mpic_of_init(struct device_node *node,
+ 	BUG_ON(!armada_370_xp_mpic_domain);
+ 	irq_domain_update_bus_token(armada_370_xp_mpic_domain, DOMAIN_BUS_WIRED);
+ 
++	soc_err_node = of_get_next_child(node, NULL);
++	if (!soc_err_node) {
++		pr_warn("Missing SoC Error Interrupt Controller node\n");
++		pr_warn("Extended interrupts are not supported\n");
++	} else {
++		pr_info("Registering MPIC SoC Error Interrupt Controller\n");
++		/*
++		 * Armada 370 and XP have only 32 SoC Error IRQs in one register
++		 * and other Armada platforms have 64 IRQs in two registers.
++		 */
++		soc_err_irq_num_regs =
++			of_machine_is_compatible("marvell,armada-370-xp") ? 1 : 2;
++		armada_370_xp_soc_err_domain =
++			irq_domain_add_hierarchy(armada_370_xp_mpic_domain, 0,
++						 soc_err_irq_num_regs * 32,
++						 soc_err_node,
++						 &armada_370_xp_soc_err_irq_ops,
++						 NULL);
++		BUG_ON(!armada_370_xp_soc_err_domain);
++	}
++
+ 	/*
+ 	 * parent_irq is used for distinguish between IPI and non-IPI platforms.
+ 	 * So initialize it before calling any other driver functions.
+@@ -827,6 +1029,10 @@ static int __init armada_370_xp_mpic_of_init(struct device_node *node,
+ 
+ 	armada_370_xp_msi_init(node, main_int_res.start);
+ 
++	/* Unmask summary SoC Error Interrupt */
++	if (soc_err_irq_num_regs > 0)
++		writel(4, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);
++
+ 	if (parent_irq <= 0) {
+ 		irq_set_default_host(armada_370_xp_mpic_domain);
+ 		set_handle_irq(armada_370_xp_handle_irq);
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0073-ARM-dts-armada-370-xp.dtsi-Add-node-for-MPIC-SoC-Err.patch b/target/linux/generic/pending-5.15/0073-ARM-dts-armada-370-xp.dtsi-Add-node-for-MPIC-SoC-Err.patch
new file mode 100644
index 0000000000..6dec138c6c
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0073-ARM-dts-armada-370-xp.dtsi-Add-node-for-MPIC-SoC-Err.patch
@@ -0,0 +1,33 @@
+From e43fb41649eb974e62b64debc234cba8aed4f978 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:25:39 +0200
+Subject: [PATCH 73/90] ARM: dts: armada-370-xp.dtsi: Add node for MPIC SoC
+ Error IRQ controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-370-xp.dtsi | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-370-xp.dtsi b/arch/arm/boot/dts/armada-370-xp.dtsi
+index 0b8c2a64b36f..7aedacff2c00 100644
+--- a/arch/arm/boot/dts/armada-370-xp.dtsi
++++ b/arch/arm/boot/dts/armada-370-xp.dtsi
+@@ -171,6 +171,11 @@ mpic: interrupt-controller@20a00 {
+ 				#size-cells = <1>;
+ 				interrupt-controller;
+ 				msi-controller;
++
++				soc_err: interrupt-controller@20 {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			coherencyfab: coherency-fabric@20200 {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0074-ARM-dts-armada-375.dtsi-Add-node-for-MPIC-SoC-Error-.patch b/target/linux/generic/pending-5.15/0074-ARM-dts-armada-375.dtsi-Add-node-for-MPIC-SoC-Error-.patch
new file mode 100644
index 0000000000..410109cf10
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0074-ARM-dts-armada-375.dtsi-Add-node-for-MPIC-SoC-Error-.patch
@@ -0,0 +1,33 @@
+From 2a2f2b633f0ecce7a56322c17a8ed91db71977eb Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:43:14 +0200
+Subject: [PATCH 74/90] ARM: dts: armada-375.dtsi: Add node for MPIC SoC Error
+ IRQ controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-375.dtsi | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-375.dtsi b/arch/arm/boot/dts/armada-375.dtsi
+index c310ef26d1cc..82f0a59d112f 100644
+--- a/arch/arm/boot/dts/armada-375.dtsi
++++ b/arch/arm/boot/dts/armada-375.dtsi
+@@ -376,6 +376,11 @@ mpic: interrupt-controller@20a00 {
+ 				interrupt-controller;
+ 				msi-controller;
+ 				interrupts = <GIC_PPI 15 IRQ_TYPE_LEVEL_HIGH>;
++
++				soc_err: interrupt-controller@20 {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			timer1: timer@20300 {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0075-ARM-dts-armada-38x.dtsi-Add-node-for-MPIC-SoC-Error-.patch b/target/linux/generic/pending-5.15/0075-ARM-dts-armada-38x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
new file mode 100644
index 0000000000..67d1064e75
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0075-ARM-dts-armada-38x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
@@ -0,0 +1,35 @@
+From 29284b9f12db226af974191bdf2164bc3155c2c3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 18 Apr 2022 00:39:52 +0200
+Subject: [PATCH 75/90] ARM: dts: armada-38x.dtsi: Add node for MPIC SoC Error
+ IRQ controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It is child of the MPIC IRQ controller.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-38x.dtsi | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
+index df3c8d1d8f64..099f167b65aa 100644
+--- a/arch/arm/boot/dts/armada-38x.dtsi
++++ b/arch/arm/boot/dts/armada-38x.dtsi
+@@ -398,6 +398,11 @@ mpic: interrupt-controller@20a00 {
+ 				interrupt-controller;
+ 				msi-controller;
+ 				interrupts = <GIC_PPI 15 IRQ_TYPE_LEVEL_HIGH>;
++
++				soc_err: interrupt-controller@20 {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			timer: timer@20300 {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0076-ARM-dts-armada-39x.dtsi-Add-node-for-MPIC-SoC-Error-.patch b/target/linux/generic/pending-5.15/0076-ARM-dts-armada-39x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
new file mode 100644
index 0000000000..bf59a959fe
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0076-ARM-dts-armada-39x.dtsi-Add-node-for-MPIC-SoC-Error-.patch
@@ -0,0 +1,33 @@
+From add0bae184216783b6f6bc67c6d4b48fec781ad5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:49:36 +0200
+Subject: [PATCH 76/90] ARM: dts: armada-39x.dtsi: Add node for MPIC SoC Error
+ IRQ controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-39x.dtsi | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-39x.dtsi b/arch/arm/boot/dts/armada-39x.dtsi
+index 9d1cac49c022..f21231a1f244 100644
+--- a/arch/arm/boot/dts/armada-39x.dtsi
++++ b/arch/arm/boot/dts/armada-39x.dtsi
+@@ -272,6 +272,11 @@ mpic: interrupt-controller@20a00 {
+ 				interrupt-controller;
+ 				msi-controller;
+ 				interrupts = <GIC_PPI 15 IRQ_TYPE_LEVEL_HIGH>;
++
++				soc_err: interrupt-controller@20 {
++					interrupt-controller;
++					#interrupt-cells = <1>;
++				};
+ 			};
+ 
+ 			timer@20300 {
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0077-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-err.patch b/target/linux/generic/pending-5.15/0077-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-err.patch
new file mode 100644
index 0000000000..2093cfd1da
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0077-ARM-dts-armada-370.dtsi-Add-definitions-for-PCIe-err.patch
@@ -0,0 +1,43 @@
+From 9740547f8b4a338e7d67760db774ef49033ed033 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:31:57 +0200
+Subject: [PATCH 77/90] ARM: dts: armada-370.dtsi: Add definitions for PCIe
+ error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-370.dtsi | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-370.dtsi b/arch/arm/boot/dts/armada-370.dtsi
+index 2013a5ccecd3..9daece786a53 100644
+--- a/arch/arm/boot/dts/armada-370.dtsi
++++ b/arch/arm/boot/dts/armada-370.dtsi
+@@ -60,8 +60,8 @@ pcie0: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 58>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 58>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+                                 ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+                                           0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -88,8 +88,8 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 62>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 62>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+                                 ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+                                           0x81000000 0 0 0x81000000 0x2 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0078-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0078-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..e8ced753d9
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0078-ARM-dts-armada-xp-mv78230.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,79 @@
+From d7af6212b6962f75c52dd61516ab92eb448a83bb Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 19:33:45 +0200
+Subject: [PATCH 78/90] ARM: dts: armada-xp-mv78230.dtsi: Add definitions for
+ PCIe error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+PCIe controllers on Marvell Port 0 share MPIC SoC Error IRQ 4 and PCIe
+controller on Marvell Port 1 uses MPIC SoC Error IRQ 5.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78230.dtsi | 20 ++++++++++----------
+ 1 file changed, 10 insertions(+), 10 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78230.dtsi b/arch/arm/boot/dts/armada-xp-mv78230.dtsi
+index 5ea9d509cd30..b8d169c4feec 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78230.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78230.dtsi
+@@ -83,8 +83,8 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 58>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 58>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -111,8 +111,8 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 59>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 59>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -139,8 +139,8 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 60>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 60>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+@@ -167,8 +167,8 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 61>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 61>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+@@ -195,8 +195,8 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 62>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 62>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0079-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0079-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..de93813727
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0079-ARM-dts-armada-xp-mv78260.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,124 @@
+From 9197b016f20750c4df3e33b48c9252fbb5972425 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:02:26 +0200
+Subject: [PATCH 79/90] ARM: dts: armada-xp-mv78260.dtsi: Add definitions for
+ PCIe error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+PCIe controllers on Marvell Port 0 share MPIC SoC Error IRQ 4, PCIe
+controllers on Marvell Port 1 share MPIC SoC Error IRQ 5 and PCIe
+controller on Marvell Port 2 uses MPIC SoC Error IRQ 15.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78260.dtsi | 36 ++++++++++++------------
+ 1 file changed, 18 insertions(+), 18 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78260.dtsi b/arch/arm/boot/dts/armada-xp-mv78260.dtsi
+index 6c6fbb9faf5a..febd9d98a44e 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78260.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78260.dtsi
+@@ -98,8 +98,8 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 58>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 58>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -126,8 +126,8 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 59>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 59>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -154,8 +154,8 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 60>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 60>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+@@ -182,8 +182,8 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 61>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 61>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+@@ -210,8 +210,8 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 62>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 62>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+@@ -238,8 +238,8 @@ pcie6: pcie@6,0 {
+ 				reg = <0x3000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 63>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 63>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x6 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x6 0 1 0>;
+@@ -266,8 +266,8 @@ pcie7: pcie@7,0 {
+ 				reg = <0x3800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 64>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 64>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x7 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x7 0 1 0>;
+@@ -294,8 +294,8 @@ pcie8: pcie@8,0 {
+ 				reg = <0x4000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 65>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 65>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x8 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x8 0 1 0>;
+@@ -322,8 +322,8 @@ pcie9: pcie@9,0 {
+ 				reg = <0x4800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 99>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 99>, <&soc_err 15>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x9 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x9 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0080-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch b/target/linux/generic/pending-5.15/0080-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
new file mode 100644
index 0000000000..cdea44feaa
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0080-ARM-dts-armada-xp-mv78460.dtsi-Add-definitions-for-P.patch
@@ -0,0 +1,136 @@
+From 20d6c3c5af016a0a2c176e4bed82a7fede362462 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 20:05:35 +0200
+Subject: [PATCH 80/90] ARM: dts: armada-xp-mv78460.dtsi: Add definitions for
+ PCIe error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+PCIe controllers on Marvell Port 0 share MPIC SoC Error IRQ 4, PCIe
+controllers on Marvell Port 1 share MPIC SoC Error IRQ 5, PCIe
+controller on Marvell Port 2 uses MPIC SoC Error IRQ 15 and PCIe
+controller on Marvell Port 3 uses MPIC SoC Error IRQ 16.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-mv78460.dtsi | 40 ++++++++++++------------
+ 1 file changed, 20 insertions(+), 20 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-mv78460.dtsi b/arch/arm/boot/dts/armada-xp-mv78460.dtsi
+index 16185edf9aa5..3b8adbc89a06 100644
+--- a/arch/arm/boot/dts/armada-xp-mv78460.dtsi
++++ b/arch/arm/boot/dts/armada-xp-mv78460.dtsi
+@@ -119,8 +119,8 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 58>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 58>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -147,8 +147,8 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 59>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 59>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -175,8 +175,8 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 60>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 60>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+@@ -203,8 +203,8 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 61>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 61>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+@@ -231,8 +231,8 @@ pcie5: pcie@5,0 {
+ 				reg = <0x2800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 62>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 62>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x5 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x5 0 1 0>;
+@@ -259,8 +259,8 @@ pcie6: pcie@6,0 {
+ 				reg = <0x3000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 63>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 63>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x6 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x6 0 1 0>;
+@@ -287,8 +287,8 @@ pcie7: pcie@7,0 {
+ 				reg = <0x3800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 64>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 64>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x7 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x7 0 1 0>;
+@@ -315,8 +315,8 @@ pcie8: pcie@8,0 {
+ 				reg = <0x4000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 65>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 65>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x8 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x8 0 1 0>;
+@@ -343,8 +343,8 @@ pcie9: pcie@9,0 {
+ 				reg = <0x4800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 99>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 99>, <&soc_err 15>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x9 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x9 0 1 0>;
+@@ -371,8 +371,8 @@ pcie10: pcie@a,0 {
+ 				reg = <0x5000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 103>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 103>, <&soc_err 16>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0xa 0 1 0
+ 					  0x81000000 0 0 0x81000000 0xa 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0081-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch b/target/linux/generic/pending-5.15/0081-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
new file mode 100644
index 0000000000..814d003fce
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0081-ARM-dts-armada-xp-98dx3236.dtsi-Add-definitions-for-.patch
@@ -0,0 +1,32 @@
+From 776df9728a4b2d3ae935487d815fbf8570b86701 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:30:55 +0200
+Subject: [PATCH 81/90] ARM: dts: armada-xp-98dx3236.dtsi: Add definitions for
+ PCIe error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-xp-98dx3236.dtsi | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-xp-98dx3236.dtsi b/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
+index b21ffb819b1d..0d021f3b86be 100644
+--- a/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
++++ b/arch/arm/boot/dts/armada-xp-98dx3236.dtsi
+@@ -76,8 +76,8 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&mpic 58>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&mpic 58>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0082-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-err.patch b/target/linux/generic/pending-5.15/0082-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-err.patch
new file mode 100644
index 0000000000..93d506c86f
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0082-ARM-dts-armada-375.dtsi-Add-definitions-for-PCIe-err.patch
@@ -0,0 +1,43 @@
+From 3fca9286a8603517109f21d743bac3bf657b39b0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 16:45:29 +0200
+Subject: [PATCH 82/90] ARM: dts: armada-375.dtsi: Add definitions for PCIe
+ error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-375.dtsi | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-375.dtsi b/arch/arm/boot/dts/armada-375.dtsi
+index 82f0a59d112f..71b01a089c81 100644
+--- a/arch/arm/boot/dts/armada-375.dtsi
++++ b/arch/arm/boot/dts/armada-375.dtsi
+@@ -573,8 +573,8 @@ pcie0: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>, <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -601,8 +601,8 @@ pcie1: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>, <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0083-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-err.patch b/target/linux/generic/pending-5.15/0083-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-err.patch
new file mode 100644
index 0000000000..1c5ddb2c36
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0083-ARM-dts-armada-380.dtsi-Add-definitions-for-PCIe-err.patch
@@ -0,0 +1,57 @@
+From 8bbc60f9c76f529c929def04a9feb39bf05dc355 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:41:39 +0200
+Subject: [PATCH 83/90] ARM: dts: armada-380.dtsi: Add definitions for PCIe
+ error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-380.dtsi | 15 +++++++++------
+ 1 file changed, 9 insertions(+), 6 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-380.dtsi b/arch/arm/boot/dts/armada-380.dtsi
+index e94f22b0e9b5..970ac6820db9 100644
+--- a/arch/arm/boot/dts/armada-380.dtsi
++++ b/arch/arm/boot/dts/armada-380.dtsi
+@@ -64,8 +64,9 @@ pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -93,8 +94,9 @@ pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -122,8 +124,9 @@ pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 15>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0084-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-err.patch b/target/linux/generic/pending-5.15/0084-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-err.patch
new file mode 100644
index 0000000000..b4aaf8b2c7
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0084-ARM-dts-armada-385.dtsi-Add-definitions-for-PCIe-err.patch
@@ -0,0 +1,71 @@
+From bb12d452fcc9386758e8d144c3090eddb0ef3fcd Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 18 Apr 2022 00:40:05 +0200
+Subject: [PATCH 84/90] ARM: dts: armada-385.dtsi: Add definitions for PCIe
+ error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+PCIe error interrupt is reported by MPIC SoC Error IRQ controller.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-385.dtsi | 20 ++++++++++++--------
+ 1 file changed, 12 insertions(+), 8 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-385.dtsi b/arch/arm/boot/dts/armada-385.dtsi
+index be8d607c59b2..d603de5aa574 100644
+--- a/arch/arm/boot/dts/armada-385.dtsi
++++ b/arch/arm/boot/dts/armada-385.dtsi
+@@ -69,8 +69,9 @@ pcie1: pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -97,8 +98,9 @@ pcie2: pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -125,8 +127,9 @@ pcie3: pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 15>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+@@ -156,8 +159,9 @@ pcie4: pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 16>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0085-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-err.patch b/target/linux/generic/pending-5.15/0085-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-err.patch
new file mode 100644
index 0000000000..1b0be454fe
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0085-ARM-dts-armada-39x.dtsi-Add-definitions-for-PCIe-err.patch
@@ -0,0 +1,69 @@
+From 3eb30a9715bc5754c09341c20d296d968d7885a0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 27 Jun 2022 17:50:54 +0200
+Subject: [PATCH 85/90] ARM: dts: armada-39x.dtsi: Add definitions for PCIe
+ error interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ arch/arm/boot/dts/armada-39x.dtsi | 20 ++++++++++++--------
+ 1 file changed, 12 insertions(+), 8 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-39x.dtsi b/arch/arm/boot/dts/armada-39x.dtsi
+index f21231a1f244..f58bd456e5ad 100644
+--- a/arch/arm/boot/dts/armada-39x.dtsi
++++ b/arch/arm/boot/dts/armada-39x.dtsi
+@@ -443,8 +443,9 @@ pcie@1,0 {
+ 				reg = <0x0800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 4>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x1 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x1 0 1 0>;
+@@ -472,8 +473,9 @@ pcie@2,0 {
+ 				reg = <0x1000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 5>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x2 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x2 0 1 0>;
+@@ -501,8 +503,9 @@ pcie@3,0 {
+ 				reg = <0x1800 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 15>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x3 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x3 0 1 0>;
+@@ -533,8 +536,9 @@ pcie@4,0 {
+ 				reg = <0x2000 0 0 0 0>;
+ 				#address-cells = <3>;
+ 				#size-cells = <2>;
+-				interrupt-names = "intx";
+-				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "intx", "error";
++				interrupts-extended = <&gic GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
++						      <&soc_err 16>;
+ 				#interrupt-cells = <1>;
+ 				ranges = <0x82000000 0 0 0x82000000 0x4 0 1 0
+ 					  0x81000000 0 0 0x81000000 0x4 0 1 0>;
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0086-PCI-pciehp-Enable-DLLSC-interrupt-only-if-supported.patch b/target/linux/generic/pending-5.15/0086-PCI-pciehp-Enable-DLLSC-interrupt-only-if-supported.patch
new file mode 100644
index 0000000000..51b8d5578d
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0086-PCI-pciehp-Enable-DLLSC-interrupt-only-if-supported.patch
@@ -0,0 +1,139 @@
+From ff967b37402c672f475854be60f6b47a69732a59 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 31 Mar 2021 15:12:50 +0200
+Subject: [PATCH 86/90] PCI: pciehp: Enable DLLSC interrupt only if supported
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Don't enable Data Link Layer State Changed interrupt if it isn't
+supported.
+
+Data Link Layer Link Active Reporting Capable bit in Link Capabilities
+register indicates if Data Link Layer State Changed Enable is supported.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/hotplug/pciehp_hpc.c | 32 ++++++++++++++++++++++++--------
+ drivers/pci/hotplug/pnv_php.c    | 13 +++++++++----
+ 2 files changed, 33 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c
+index 60098a701e83..5b0d48435b36 100644
+--- a/drivers/pci/hotplug/pciehp_hpc.c
++++ b/drivers/pci/hotplug/pciehp_hpc.c
+@@ -788,6 +788,7 @@ static int pciehp_poll(void *data)
+ static void pcie_enable_notification(struct controller *ctrl)
+ {
+ 	u16 cmd, mask;
++	u32 link_cap;
+ 
+ 	/*
+ 	 * TBD: Power fault detected software notification support.
+@@ -800,12 +801,17 @@ static void pcie_enable_notification(struct controller *ctrl)
+ 	 * next power fault detected interrupt was notified again.
+ 	 */
+ 
++	pcie_capability_read_dword(ctrl_dev(ctrl), PCI_EXP_LNKCAP, &link_cap);
++
+ 	/*
+-	 * Always enable link events: thus link-up and link-down shall
+-	 * always be treated as hotplug and unplug respectively. Enable
+-	 * presence detect only if Attention Button is not present.
+-	 */
+-	cmd = PCI_EXP_SLTCTL_DLLSCE;
++	 * Enable link events if their support is indicated in Link Capability
++	 * register: thus link-up and link-down shall always be treated as
++	 * hotplug and unplug respectively. Enable presence detect only if
++	 * Attention Button is not present.
++	*/
++	cmd = 0;
++	if (link_cap & PCI_EXP_LNKCAP_DLLLARC)
++		cmd |= PCI_EXP_SLTCTL_DLLSCE;
+ 	if (ATTN_BUTTN(ctrl))
+ 		cmd |= PCI_EXP_SLTCTL_ABPE;
+ 	else
+@@ -845,8 +851,13 @@ void pcie_clear_hotplug_events(struct controller *ctrl)
+ void pcie_enable_interrupt(struct controller *ctrl)
+ {
+ 	u16 mask;
++	u32 link_cap;
+ 
+-	mask = PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_DLLSCE;
++	pcie_capability_read_dword(ctrl_dev(ctrl), PCI_EXP_LNKCAP, &link_cap);
++
++	mask = PCI_EXP_SLTCTL_HPIE;
++	if (link_cap & PCI_EXP_LNKCAP_DLLLARC)
++		mask |= PCI_EXP_SLTCTL_DLLSCE;
+ 	pcie_write_cmd(ctrl, mask, mask);
+ }
+ 
+@@ -904,19 +915,24 @@ int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, bool probe)
+ 	struct controller *ctrl = to_ctrl(hotplug_slot);
+ 	struct pci_dev *pdev = ctrl_dev(ctrl);
+ 	u16 stat_mask = 0, ctrl_mask = 0;
++	u32 link_cap;
+ 	int rc;
+ 
+ 	if (probe)
+ 		return 0;
+ 
++	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
++
+ 	down_write_nested(&ctrl->reset_lock, ctrl->depth);
+ 
+ 	if (!ATTN_BUTTN(ctrl)) {
+ 		ctrl_mask |= PCI_EXP_SLTCTL_PDCE;
+ 		stat_mask |= PCI_EXP_SLTSTA_PDC;
+ 	}
+-	ctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;
+-	stat_mask |= PCI_EXP_SLTSTA_DLLSC;
++	if (link_cap & PCI_EXP_LNKCAP_DLLLARC) {
++		ctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;
++		stat_mask |= PCI_EXP_SLTSTA_DLLSC;
++	}
+ 
+ 	pcie_write_cmd(ctrl, 0, ctrl_mask);
+ 	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
+diff --git a/drivers/pci/hotplug/pnv_php.c b/drivers/pci/hotplug/pnv_php.c
+index f4c2e6e01be0..41b86fae41c8 100644
+--- a/drivers/pci/hotplug/pnv_php.c
++++ b/drivers/pci/hotplug/pnv_php.c
+@@ -839,6 +839,7 @@ static void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)
+ {
+ 	struct pci_dev *pdev = php_slot->pdev;
+ 	u32 broken_pdc = 0;
++	u32 link_cap;
+ 	u16 sts, ctrl;
+ 	int ret;
+ 
+@@ -873,17 +874,21 @@ static void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)
+ 		return;
+ 	}
+ 
++	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
++
+ 	/* Enable the interrupts */
+ 	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);
+ 	if (php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC) {
+ 		ctrl &= ~PCI_EXP_SLTCTL_PDCE;
+-		ctrl |= (PCI_EXP_SLTCTL_HPIE |
+-			 PCI_EXP_SLTCTL_DLLSCE);
++		ctrl |= PCI_EXP_SLTCTL_HPIE;
+ 	} else {
+ 		ctrl |= (PCI_EXP_SLTCTL_HPIE |
+-			 PCI_EXP_SLTCTL_PDCE |
+-			 PCI_EXP_SLTCTL_DLLSCE);
++				PCI_EXP_SLTCTL_PDCE);
+ 	}
++	if (link_cap & PCI_EXP_LNKCAP_DLLLARC)
++		ctrl |= PCI_EXP_SLTCTL_DLLSCE;
++	else
++		ctrl &= ~PCI_EXP_SLTCTL_DLLSCE;
+ 	pcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);
+ 
+ 	/* The interrupt is initialized successfully when @irq is valid */
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0087-PCI-pciehp-Enable-Command-Completed-Interrupt-only-i.patch b/target/linux/generic/pending-5.15/0087-PCI-pciehp-Enable-Command-Completed-Interrupt-only-i.patch
new file mode 100644
index 0000000000..af62890ce5
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0087-PCI-pciehp-Enable-Command-Completed-Interrupt-only-i.patch
@@ -0,0 +1,38 @@
+From 589599f1ebbfa109bbcad2758af525b48c01b495 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 31 Mar 2021 15:14:29 +0200
+Subject: [PATCH 87/90] PCI: pciehp: Enable Command Completed Interrupt only if
+ supported
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The No Command Completed Support bit in the Slot Capabilities register
+indicates whether Command Completed Interrupt Enable is unsupported.
+
+Enable this interrupt only in the case it is supported.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/hotplug/pciehp_hpc.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c
+index 5b0d48435b36..701031d809f5 100644
+--- a/drivers/pci/hotplug/pciehp_hpc.c
++++ b/drivers/pci/hotplug/pciehp_hpc.c
+@@ -817,7 +817,9 @@ static void pcie_enable_notification(struct controller *ctrl)
+ 	else
+ 		cmd |= PCI_EXP_SLTCTL_PDCE;
+ 	if (!pciehp_poll_mode)
+-		cmd |= PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE;
++		cmd |= PCI_EXP_SLTCTL_HPIE;
++	if (!pciehp_poll_mode && !NO_CMD_CMPL(ctrl))
++		cmd |= PCI_EXP_SLTCTL_CCIE;
+ 
+ 	mask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |
+ 		PCI_EXP_SLTCTL_PFDE |
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0088-PCI-mvebu-Add-support-for-PCI_EXP_SLTSTA_DLLSC-via-h.patch b/target/linux/generic/pending-5.15/0088-PCI-mvebu-Add-support-for-PCI_EXP_SLTSTA_DLLSC-via-h.patch
new file mode 100644
index 0000000000..ad01551f6d
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0088-PCI-mvebu-Add-support-for-PCI_EXP_SLTSTA_DLLSC-via-h.patch
@@ -0,0 +1,297 @@
+From 38251bffc7552d62689e5fd6831f0aae1d842438 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:53:11 +0200
+Subject: [PATCH 88/90] PCI: mvebu: Add support for PCI_EXP_SLTSTA_DLLSC via
+ hot plug interrupt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+If link up/down state is changed in mvebu_pcie_link_up() then trigger
+hot plug interrupt with DLLSC state change.
+
+Also triggers hot plug interrupt when mvebu triggers Link Failure interrupt
+which indicates that link was changed from active state or when mvebu
+triggers TxReq No Link interrupt which indicates that link is down while
+trying to transmit PCIe transaction.
+
+And this hot plug interrupt also when explicit Link Disable or PCIe Host
+Reset is issued as mvebu does not trigger Link Failure when dropping to
+Detect via Hot Reset or Link Disable.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/Kconfig     |   3 +
+ drivers/pci/controller/pci-mvebu.c | 147 ++++++++++++++++++++++++++++-
+ 2 files changed, 149 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/pci/controller/Kconfig b/drivers/pci/controller/Kconfig
+index 46fa9bbff177..c217ea3bc703 100644
+--- a/drivers/pci/controller/Kconfig
++++ b/drivers/pci/controller/Kconfig
+@@ -10,6 +10,9 @@ config PCI_MVEBU
+ 	depends on ARM
+ 	depends on OF
+ 	select PCI_BRIDGE_EMUL
++	select PCIEPORTBUS
++	select HOTPLUG_PCI
++	select HOTPLUG_PCI_PCIE
+ 	help
+ 	 Add support for Marvell EBU PCIe controller. This PCIe controller
+ 	 is used on 32-bit Marvell ARM SoCs: Dove, Kirkwood, Armada 370,
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 319cd2b98545..2792b02278b9 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -56,12 +56,14 @@
+ #define PCIE_CONF_DATA_OFF	0x18fc
+ #define PCIE_INT_CAUSE_OFF	0x1900
+ #define PCIE_INT_UNMASK_OFF	0x1910
++#define  PCIE_INT_TXREQ_NOLINK		BIT(0)
+ #define  PCIE_INT_DET_COR		BIT(8)
+ #define  PCIE_INT_DET_NONFATAL		BIT(9)
+ #define  PCIE_INT_DET_FATAL		BIT(10)
+ #define  PCIE_INT_ERR_FATAL		BIT(16)
+ #define  PCIE_INT_ERR_NONFATAL		BIT(17)
+ #define  PCIE_INT_ERR_COR		BIT(18)
++#define  PCIE_INT_LINK_FAIL		BIT(23)
+ #define  PCIE_INT_INTX(i)		BIT(24+i)
+ #define  PCIE_INT_PM_PME		BIT(28)
+ #define  PCIE_INT_DET_MASK		(PCIE_INT_DET_COR | PCIE_INT_DET_NONFATAL | PCIE_INT_DET_FATAL)
+@@ -134,6 +136,8 @@ struct mvebu_pcie_port {
+ 	int error_irq;
+ 	int intx_irq;
+ 	bool pme_pending;
++	struct timer_list link_irq_timer;
++	bool link_was_up;
+ };
+ 
+ static inline void mvebu_writel(struct mvebu_pcie_port *port, u32 val, u32 reg)
+@@ -153,7 +157,26 @@ static inline bool mvebu_has_ioport(struct mvebu_pcie_port *port)
+ 
+ static bool mvebu_pcie_link_up(struct mvebu_pcie_port *port)
+ {
+-	return !(mvebu_readl(port, PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
++	bool link_is_up;
++	u16 slotsta;
++
++	link_is_up = !(mvebu_readl(port, PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
++
++	if (link_is_up != port->link_was_up) {
++		port->link_was_up = link_is_up;
++		/*
++		 * Link IRQ timer/handler is available only when "error"
++		 * interrupt was specified in DT.
++		 */
++		if (port->error_irq > 0) {
++			slotsta = le16_to_cpu(port->bridge.pcie_conf.slotsta);
++			port->bridge.pcie_conf.slotsta =
++				cpu_to_le16(slotsta | PCI_EXP_SLTSTA_DLLSC);
++			mod_timer(&port->link_irq_timer, jiffies + 1);
++		}
++	}
++
++	return link_is_up;
+ }
+ 
+ static u8 mvebu_pcie_get_local_bus_nr(struct mvebu_pcie_port *port)
+@@ -346,6 +369,19 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 		mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
+ 	}
+ 
++	/*
++	 * Unmask No Link and Link Failure interrupts to process Link Down
++	 * events. These events are reported as Data Link Layer State Changed
++	 * notification via Hot Plug Interrupt. Other parts of Link change
++	 * events are available only when "error" interrupt was specified in DT.
++	 * So enable these interrupts under same conditions.
++	 */
++	if (port->error_irq > 0) {
++		unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
++		unmask |= PCIE_INT_TXREQ_NOLINK | PCIE_INT_LINK_FAIL;
++		mvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);
++	}
++
+ 	/*
+ 	 * Fallback code when "intx" interrupt was not specified in DT:
+ 	 * Unmask all legacy INTx interrupts as driver does not provide a way
+@@ -697,6 +733,14 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 			val |= slotctl & PCI_EXP_SLTCTL_ASPL_DISABLE;
+ 		else if (!(mvebu_readl(port, PCIE_SSPL_OFF) & PCIE_SSPL_ENABLE))
+ 			val |= PCI_EXP_SLTCTL_ASPL_DISABLE;
++		/*
++		 * HPIE and DLLSCE bits are stored only in emulated config
++		 * space buffer and are supported only when or "error" interrupt
++		 * was specified in DT.
++		 */
++		if (port->error_irq > 0)
++			val |= slotctl & (PCI_EXP_SLTCTL_HPIE |
++					  PCI_EXP_SLTCTL_DLLSCE);
+ 		/* This callback is 32-bit and in high bits is slot status. */
+ 		val |= slotsta << 16;
+ 		*value = val;
+@@ -828,6 +872,25 @@ mvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,
+ 			else
+ 				ctrl &= ~PCIE_CTRL_MASTER_HOT_RESET;
+ 			mvebu_writel(port, ctrl, PCIE_CTRL_OFF);
++			/*
++			 * When dropping to Detect via Hot Reset, Disable Link
++			 * or Loopback states, the Link Failure interrupt is not
++			 * asserted. So when setting Secondary Bus Reset / Hot
++			 * Reset bit, call link IRQ timer/handler manually.
++			 */
++			if ((ctrl & PCIE_CTRL_MASTER_HOT_RESET) && port->link_was_up) {
++				port->link_was_up = false;
++				/*
++				 * Link IRQ timer/handler is available only when
++				 * "error" interrupt was specified in DT.
++				 */
++				if (port->error_irq > 0) {
++					u16 slotsta = le16_to_cpu(port->bridge.pcie_conf.slotsta);
++					port->bridge.pcie_conf.slotsta =
++						cpu_to_le16(slotsta | PCI_EXP_SLTSTA_DLLSC);
++					mod_timer(&port->link_irq_timer, jiffies + 1);
++				}
++			}
+ 		}
+ 		break;
+ 
+@@ -856,6 +919,25 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 		new &= ~PCI_EXP_LNKCTL_CLKREQ_EN;
+ 
+ 		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);
++		/*
++		 * When dropping to Detect via Hot Reset, Disable Link
++		 * or Loopback states, the Link Failure interrupt is not
++		 * asserted. So when setting Link Disable bit, call link
++		 * IRQ timer/handler manually.
++		 */
++		if ((new & PCI_EXP_LNKCTL_LD) && port->link_was_up) {
++			port->link_was_up = false;
++			/*
++			 * Link IRQ timer/handler is available only when
++			 * "error" interrupt was specified in DT.
++			 */
++			if (port->error_irq > 0) {
++				u16 slotsta = le16_to_cpu(port->bridge.pcie_conf.slotsta);
++				port->bridge.pcie_conf.slotsta =
++					cpu_to_le16(slotsta | PCI_EXP_SLTSTA_DLLSC);
++				mod_timer(&port->link_irq_timer, jiffies + 1);
++			}
++		}
+ 		break;
+ 
+ 	case PCI_EXP_SLTCTL:
+@@ -996,6 +1078,15 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	bridge->pcie_conf.cap = cpu_to_le16(pcie_cap_ver | PCI_EXP_FLAGS_SLOT);
+ 
+ 	/*
++	 * When "error" interrupt was specified in DT then driver is able to
++	 * deliver Data Link Layer State Change interrupt. So in this case mark
++	 * bridge as Hot Plug Capable as this is the way how to enable
++	 * delivering of Data Link Layer State Change interrupts.
++	 *
++	 * No Command Completed Support is set because bridge does not support
++	 * Command Completed Interrupt. Every command is executed immediately
++	 * without any delay.
++	 *
+ 	 * Set Presence Detect State bit permanently as there is no support for
+ 	 * unplugging PCIe card from the slot. Assume that PCIe card is always
+ 	 * connected in slot.
+@@ -1007,6 +1098,8 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	 * Also set correct slot power limit.
+ 	 */
+ 	bridge->pcie_conf.slotcap = cpu_to_le32(
++		PCI_EXP_SLTCAP_NCCS |
++		(port->error_irq > 0 ? PCI_EXP_SLTCAP_HPC : 0) |
+ 		FIELD_PREP(PCI_EXP_SLTCAP_SPLV, port->slot_power_limit_value) |
+ 		FIELD_PREP(PCI_EXP_SLTCAP_SPLS, port->slot_power_limit_scale) |
+ 		FIELD_PREP(PCI_EXP_SLTCAP_PSN, port->port+1));
+@@ -1198,11 +1291,29 @@ static int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)
+ 	return 0;
+ }
+ 
++static void mvebu_pcie_link_irq_handler(struct timer_list *timer)
++{
++	struct mvebu_pcie_port *port = from_timer(port, timer, link_irq_timer);
++	struct device *dev = &port->pcie->pdev->dev;
++	u16 slotctl;
++
++	dev_info(dev, "%s: link %s\n", port->name, port->link_was_up ? "up" : "down");
++
++	slotctl = le16_to_cpu(port->bridge.pcie_conf.slotctl);
++	if (!(slotctl & PCI_EXP_SLTCTL_DLLSCE) ||
++	    !(slotctl & PCI_EXP_SLTCTL_HPIE))
++		return;
++
++	if (generic_handle_domain_irq(port->rp_irq_domain, 0) == -EINVAL)
++		dev_err_ratelimited(dev, "unhandled HP IRQ\n");
++}
++
+ static irqreturn_t mvebu_pcie_error_irq_handler(int irq, void *arg)
+ {
+ 	struct mvebu_pcie_port *port = arg;
+ 	struct device *dev = &port->pcie->pdev->dev;
+ 	u32 cause, unmask, status;
++	u16 slotsta;
+ 
+ 	cause = mvebu_readl(port, PCIE_INT_CAUSE_OFF);
+ 	unmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);
+@@ -1240,6 +1351,25 @@ static irqreturn_t mvebu_pcie_error_irq_handler(int irq, void *arg)
+ 			dev_err_ratelimited(dev, "unhandled ERR IRQ\n");
+ 	}
+ 
++	/* Process No Link and Link Failure interrupts as HP IRQ */
++	if (status & (PCIE_INT_TXREQ_NOLINK | PCIE_INT_LINK_FAIL)) {
++		mvebu_writel(port,
++			     ~(PCIE_INT_TXREQ_NOLINK | PCIE_INT_LINK_FAIL),
++			     PCIE_INT_CAUSE_OFF);
++		if (port->link_was_up) {
++			port->link_was_up = false;
++			slotsta = le16_to_cpu(port->bridge.pcie_conf.slotsta);
++			port->bridge.pcie_conf.slotsta =
++				cpu_to_le16(slotsta | PCI_EXP_SLTSTA_DLLSC);
++			/*
++			 * Deactivate timer and call mvebu_pcie_link_irq_handler()
++			 * function directly as we are in the interrupt context.
++			 */
++			del_timer_sync(&port->link_irq_timer);
++			mvebu_pcie_link_irq_handler(&port->link_irq_timer);
++		}
++	}
++
+ 	return status ? IRQ_HANDLED : IRQ_NONE;
+ }
+ 
+@@ -1805,6 +1935,18 @@ static int mvebu_pcie_probe(struct platform_device *pdev)
+ 			}
+ 		}
+ 
++		/*
++		 * Function mvebu_pcie_link_irq_handler() calls function
++		 * generic_handle_irq() and it expects local IRQs to be disabled
++		 * as normally generic_handle_irq() is called from the interrupt
++		 * context. So use TIMER_IRQSAFE flag for this link_irq_timer.
++		 * Available only if "or "error" interrupt was specified.
++		 */
++		if (port->error_irq > 0)
++			timer_setup(&port->link_irq_timer,
++				    mvebu_pcie_link_irq_handler,
++				    TIMER_IRQSAFE);
++
+ 		/*
+ 		 * PCIe topology exported by mvebu hw is quite complicated. In
+ 		 * reality has something like N fully independent host bridges
+@@ -1941,6 +2083,9 @@ static int mvebu_pcie_remove(struct platform_device *pdev)
+ 			irq_domain_remove(port->rp_irq_domain);
+ 		}
+ 
++		if (port->error_irq > 0)
++			del_timer_sync(&port->link_irq_timer);
++
+ 		/* Free config space for emulated root bridge. */
+ 		pci_bridge_emul_cleanup(&port->bridge);
+ 
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0089-PCI-mvebu-use-BIT-and-GENMASK-macros-instead-of-hard.patch b/target/linux/generic/pending-5.15/0089-PCI-mvebu-use-BIT-and-GENMASK-macros-instead-of-hard.patch
new file mode 100644
index 0000000000..a7dbad5f9f
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0089-PCI-mvebu-use-BIT-and-GENMASK-macros-instead-of-hard.patch
@@ -0,0 +1,47 @@
+From fbe986f71d0b5c280cbf08a3ce11d121739f9c8f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:54:29 +0200
+Subject: [PATCH 89/90] PCI: mvebu: use BIT() and GENMASK() macros instead of
+ hardcoded hex values
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 2792b02278b9..87f1c2aa5010 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -44,7 +44,7 @@
+ #define PCIE_WIN5_BASE_OFF	0x1884
+ #define PCIE_WIN5_REMAP_OFF	0x188c
+ #define PCIE_CONF_ADDR_OFF	0x18f8
+-#define  PCIE_CONF_ADDR_EN		0x80000000
++#define  PCIE_CONF_ADDR_EN		BIT(31)
+ #define  PCIE_CONF_REG(r)		((((r) & 0xf00) << 16) | ((r) & 0xfc))
+ #define  PCIE_CONF_BUS(b)		(((b) & 0xff) << 16)
+ #define  PCIE_CONF_DEV(d)		(((d) & 0x1f) << 11)
+@@ -70,13 +70,13 @@
+ #define  PCIE_INT_ERR_MASK		(PCIE_INT_ERR_FATAL | PCIE_INT_ERR_NONFATAL | PCIE_INT_ERR_COR)
+ #define  PCIE_INT_ALL_MASK		GENMASK(31, 0)
+ #define PCIE_CTRL_OFF		0x1a00
+-#define  PCIE_CTRL_X1_MODE		0x0001
++#define  PCIE_CTRL_X1_MODE		BIT(0)
+ #define  PCIE_CTRL_RC_MODE		BIT(1)
+ #define  PCIE_CTRL_MASTER_HOT_RESET	BIT(24)
+ #define PCIE_STAT_OFF		0x1a04
+-#define  PCIE_STAT_BUS                  0xff00
+-#define  PCIE_STAT_DEV                  0x1f0000
+ #define  PCIE_STAT_LINK_DOWN		BIT(0)
++#define  PCIE_STAT_BUS			GENMASK(15, 8)
++#define  PCIE_STAT_DEV			GENMASK(20, 16)
+ #define PCIE_SSPL_OFF		0x1a0c
+ #define  PCIE_SSPL_VALUE_SHIFT		0
+ #define  PCIE_SSPL_VALUE_MASK		GENMASK(7, 0)
+-- 
+2.34.1
+
diff --git a/target/linux/generic/pending-5.15/0090-PCI-mvebu-For-consistency-add-_OFF-suffix-to-all-reg.patch b/target/linux/generic/pending-5.15/0090-PCI-mvebu-For-consistency-add-_OFF-suffix-to-all-reg.patch
new file mode 100644
index 0000000000..8679fdf0a6
--- /dev/null
+++ b/target/linux/generic/pending-5.15/0090-PCI-mvebu-For-consistency-add-_OFF-suffix-to-all-reg.patch
@@ -0,0 +1,167 @@
+From 905b0eda8ec724de75d825b1d3625c27beb0bc6d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 17 Sep 2021 14:55:03 +0200
+Subject: [PATCH 90/90] PCI: mvebu: For consistency add _OFF suffix to all
+ registers
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+---
+ drivers/pci/controller/pci-mvebu.c | 40 +++++++++++++++---------------
+ 1 file changed, 20 insertions(+), 20 deletions(-)
+
+diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
+index 87f1c2aa5010..b04b9bbe9217 100644
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -34,7 +34,7 @@
+ #define PCIE_BAR_LO_OFF(n)	(0x0010 + ((n) << 3))
+ #define PCIE_BAR_HI_OFF(n)	(0x0014 + ((n) << 3))
+ #define PCIE_SSDEV_ID_OFF	0x002c
+-#define PCIE_CAP_PCIEXP		0x0060
++#define PCIE_CAP_PCIEXP_OFF	0x0060
+ #define PCIE_CAP_PCIERR_OFF	0x0100
+ #define PCIE_BAR_CTRL_OFF(n)	(0x1804 + (((n) - 1) * 4))
+ #define PCIE_WIN04_CTRL_OFF(n)	(0x1820 + ((n) << 4))
+@@ -83,8 +83,8 @@
+ #define  PCIE_SSPL_SCALE_SHIFT		8
+ #define  PCIE_SSPL_SCALE_MASK		GENMASK(9, 8)
+ #define  PCIE_SSPL_ENABLE		BIT(16)
+-#define PCIE_RC_RTSTA		0x1a14
+-#define PCIE_DEBUG_CTRL         0x1a60
++#define PCIE_RC_RTSTA_OFF	0x1a14
++#define PCIE_DEBUG_CTRL_OFF	0x1a60
+ #define  PCIE_DEBUG_SOFT_RESET		BIT(20)
+ 
+ struct mvebu_pcie_port;
+@@ -296,10 +296,10 @@ static void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)
+ 	 * be set to number of SerDes PCIe lanes (1 or 4). If this register is
+ 	 * not set correctly then link with endpoint card is not established.
+ 	 */
+-	lnkcap = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);
++	lnkcap = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCAP);
+ 	lnkcap &= ~PCI_EXP_LNKCAP_MLW;
+ 	lnkcap |= (port->is_x4 ? 4 : 1) << 4;
+-	mvebu_writel(port, lnkcap, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);
++	mvebu_writel(port, lnkcap, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCAP);
+ 
+ 	/* Disable Root Bridge I/O space, memory space and bus mastering. */
+ 	cmd = mvebu_readl(port, PCIE_CMD_OFF);
+@@ -695,11 +695,11 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 
+ 	switch (reg) {
+ 	case PCI_EXP_DEVCAP:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCAP);
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCAP);
+ 		break;
+ 
+ 	case PCI_EXP_DEVCTL:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL);
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCTL);
+ 		break;
+ 
+ 	case PCI_EXP_LNKCAP:
+@@ -709,13 +709,13 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 		 * Additionally enable Data Link Layer Link Active Reporting
+ 		 * Capable bit as DL_Active indication is provided too.
+ 		 */
+-		*value = (mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &
++		*value = (mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCAP) &
+ 			  ~PCI_EXP_LNKCAP_CLKPM) | PCI_EXP_LNKCAP_DLLLARC;
+ 		break;
+ 
+ 	case PCI_EXP_LNKCTL:
+ 		/* DL_Active indication is provided via PCIE_STAT_OFF */
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL) |
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCTL) |
+ 			 (mvebu_pcie_link_up(port) ?
+ 			  (PCI_EXP_LNKSTA_DLLLA << 16) : 0);
+ 		break;
+@@ -753,19 +753,19 @@ mvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,
+ 		break;
+ 
+ 	case PCI_EXP_RTSTA:
+-		*value = mvebu_readl(port, PCIE_RC_RTSTA);
++		*value = mvebu_readl(port, PCIE_RC_RTSTA_OFF);
+ 		break;
+ 
+ 	case PCI_EXP_DEVCAP2:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCAP2);
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCAP2);
+ 		break;
+ 
+ 	case PCI_EXP_DEVCTL2:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL2);
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCTL2);
+ 		break;
+ 
+ 	case PCI_EXP_LNKCTL2:
+-		*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL2);
++		*value = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCTL2);
+ 		break;
+ 
+ 	default:
+@@ -907,7 +907,7 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 
+ 	switch (reg) {
+ 	case PCI_EXP_DEVCTL:
+-		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL);
++		mvebu_writel(port, new, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCTL);
+ 		break;
+ 
+ 	case PCI_EXP_LNKCTL:
+@@ -918,7 +918,7 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 		 */
+ 		new &= ~PCI_EXP_LNKCTL_CLKREQ_EN;
+ 
+-		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);
++		mvebu_writel(port, new, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCTL);
+ 		/*
+ 		 * When dropping to Detect via Hot Reset, Disable Link
+ 		 * or Loopback states, the Link Failure interrupt is not
+@@ -958,7 +958,7 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 
+ 	case PCI_EXP_RTSTA:
+ 		/*
+-		 * PME Status bit in Root Status Register (PCIE_RC_RTSTA)
++		 * PME Status bit in Root Status Register (PCIE_RC_RTSTA_OFF)
+ 		 * is read-only and can be cleared only by writing 0b to the
+ 		 * Interrupt Cause RW0C register (PCIE_INT_CAUSE_OFF). So
+ 		 * clear PME via Interrupt Cause and also set port->pme_pending
+@@ -983,11 +983,11 @@ mvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,
+ 		break;
+ 
+ 	case PCI_EXP_DEVCTL2:
+-		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL2);
++		mvebu_writel(port, new, PCIE_CAP_PCIEXP_OFF + PCI_EXP_DEVCTL2);
+ 		break;
+ 
+ 	case PCI_EXP_LNKCTL2:
+-		mvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL2);
++		mvebu_writel(port, new, PCIE_CAP_PCIEXP_OFF + PCI_EXP_LNKCTL2);
+ 		break;
+ 
+ 	default:
+@@ -1047,7 +1047,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	u32 dev_id = mvebu_readl(port, PCIE_DEV_ID_OFF);
+ 	u32 dev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);
+ 	u32 ssdev_id = mvebu_readl(port, PCIE_SSDEV_ID_OFF);
+-	u32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP);
++	u32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP_OFF);
+ 	u8 pcie_cap_ver = ((pcie_cap >> 16) & PCI_EXP_FLAGS_VERS);
+ 
+ 	bridge->conf.vendor = cpu_to_le16(dev_id & 0xffff);
+@@ -1108,7 +1108,7 @@ static int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)
+ 	bridge->subsystem_vendor_id = ssdev_id & 0xffff;
+ 	bridge->subsystem_id = ssdev_id >> 16;
+ 	bridge->has_pcie = true;
+-	bridge->pcie_start = PCIE_CAP_PCIEXP;
++	bridge->pcie_start = PCIE_CAP_PCIEXP_OFF;
+ 	bridge->data = port;
+ 	bridge->ops = &mvebu_pci_bridge_emul_ops;
+ 
+-- 
+2.34.1
+
-- 
2.34.1

