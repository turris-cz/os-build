From 8d8468a921f83716bfdebd21b44273723a8cf9d0 Mon Sep 17 00:00:00 2001
From: Michal Hrusecky <Michal@Hrusecky.net>
Date: Wed, 7 Mar 2018 17:10:32 +0100
Subject: [PATCH] mvebu: Basic MoX support

Adding basic support for CZ.NICs MoX board.

Signed-off-by: Michal Hrusecky <Michal@Hrusecky.net>
---
 target/linux/mvebu/config-4.14                |   1 +
 target/linux/mvebu/image/cortex-a53.mk        |  11 +
 ...ark-allow-to-specify-link-capability.patch |  43 -
 ...ecure-remove-null-check-before-kfree.patch |  34 +
 ...cure-do-not-use-areq-result-for-part.patch |  63 ++
 ...nside-secure-remove-extra-empty-line.patch |  28 +
 ...-inside-secure-fix-typo-in-a-comment.patch |  29 +
 ...-inside-secure-remove-useless-memset.patch |  30 +
 ...cure-refrain-from-unneeded-invalidat.patch |  91 ++
 ...cure-EBUSY-is-not-an-error-on-async-.patch |  35 +
 ...cure-move-cipher-crypto-mode-to-requ.patch |  76 ++
 ...cure-remove-unused-parameter-in-inva.patch |  74 ++
 ...cure-move-request-dequeueing-into-a-.patch | 204 ++++
 ...cure-use-threaded-IRQs-for-result-ha.patch | 136 +++
 ...-secure-dequeue-all-requests-at-once.patch | 179 ++++
 ...inside-secure-increase-the-ring-size.patch |  37 +
 ...cure-acknowledge-the-result-requests.patch |  62 ++
 ...cure-handle-more-result-requests-whe.patch |  70 ++
 ...cure-retry-to-proceed-the-request-la.patch | 103 ++
 ...7-crypto-inside-secure-EIP97-support.patch | 841 ++++++++++++++++
 ...cure-make-function-safexcel_try_push.patch |  38 +
 ...cure-do-not-overwrite-the-threshold-.patch |  40 +
 ...cure-keep-the-requests-push-pop-sync.patch | 136 +++
 ...cure-unmap-the-result-in-the-hash-se.patch |  42 +
 ...cure-move-hash-result-dma-mapping-to.patch | 115 +++
 ...cure-move-cache-result-dma-mapping-t.patch | 152 +++
 ...cure-fix-missing-unlock-on-error-in-.patch |  36 +
 ...-secure-improve-clock-initialization.patch |  48 +
 ...cure-fix-clock-resource-by-adding-a-.patch | 146 +++
 ...cure-move-the-digest-to-the-request-.patch | 161 +++
 ...cure-fix-typo-s-allways-always-in-a-.patch |  45 +
 ...secure-fix-a-typo-in-a-register-name.patch |  45 +
 ...e-secure-improve-the-send-error-path.patch |  50 +
 ...cure-do-not-access-buffers-mapped-to.patch |  46 +
 ...de-secure-improve-the-skcipher-token.patch |  36 +
 ...cure-the-context-ipad-opad-should-us.patch |  42 +
 ...to-inside-secure-hmac-sha256-support.patch | 174 ++++
 ...to-inside-secure-hmac-sha224-support.patch | 110 +++
 ...arvell-armada-37xx-add-a-crypto-node.patch |  42 +
 ...-sfp-display-SFP-module-information.patch} |   3 +
 ...0038-net-mvneta-tx-queue-workaround.patch} |  17 +-
 ...90039-net-mvneta-convert-to-phylink.patch} | 256 ++---
 ...0-net-mvneta-hack-fix-phy_interface.patch} |  11 +-
 ...e-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch} |  18 +-
 ...a-add-module-EEPROM-reading-support.patch} |  13 +-
 ...d-phy-remove-fixed_phy_update_state.patch} |  17 +-
 ...eprom-ethtool-access-into-netdev-co.patch} |  38 +-
 ...p-use-netdev-sfp_bus-for-start-stop.patch} |   9 +-
 ...-marvell-10G-phy-support-to-use-SFP.patch} |  11 +-
 ...tch => 90047-sfp-add-sfp-compatible.patch} |   7 +-
 ...armada-37xx-periph-cosmetic-changes.patch} |  21 +-
 ...37xx-periph-prepare-cpu-clk-to-be-u.patch} |  25 +-
 ...37xx-periph-add-DVFS-support-for-cp.patch} |  20 +-
 ...eq-Add-DVFS-support-for-Armada-37xx.patch} |  18 +-
 ...SPI-mode-before-asserting-chip-sele.patch} |  18 +-
 ...rvell-Fix-A37xx-
diff --git a/target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch b/target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
similarity index 74%
rename from target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
rename to target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
index 47e0751..45b0b0b 100644
--- a/target/linux/mvebu/patches-4.14/506-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
+++ b/target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
@@ -1,7 +1,7 @@
-From 2ff0d0b5bb397c3dc5c9b97bd0f20948f0b77740 Mon Sep 17 00:00:00 2001
+From 15ffd974e38f7442a368f6c1100bb7d596b0d242 Mon Sep 17 00:00:00 2001
 From: Miquel Raynal <miquel.raynal@free-electrons.com>
 Date: Fri, 13 Oct 2017 11:01:57 +0200
-Subject: arm64: dts: marvell: armada-37xx: add UART clock
+Subject: [PATCH 054/127] arm64: dts: marvell: armada-37xx: add UART clock
 
 Add the missing clock property to armada-3700 UART node.
 
@@ -15,6 +15,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
  1 file changed, 1 insertion(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index a4483ba82ecc..3260f27edc0c 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -135,6 +135,7 @@
@@ -25,3 +27,6 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
  				status = "disabled";
  			};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch b/target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
similarity index 73%
rename from target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
rename to target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
index dd3727c..834089f 100644
--- a/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
+++ b/target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
@@ -1,8 +1,8 @@
-From e8d66e7927b2a15310df0eb44a67d120ea147a59 Mon Sep 17 00:00:00 2001
+From f0583a43cf03e3a735d6f796a1c95a17fa07be75 Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 14 Dec 2017 16:00:06 +0100
-Subject: arm64: dts: marvell: armada-37xx: add nodes allowing cpufreq
- support
+Subject: [PATCH 055/127] arm64: dts: marvell: armada-37xx: add nodes allowing
+ cpufreq support
 
 In order to be able to use cpu freq, we need to associate a clock to each
 CPU and to expose the power management registers.
@@ -13,6 +13,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 7 +++++++
  2 files changed, 8 insertions(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-372x.dtsi b/arch/arm64/boot/dts/marvell/armada-372x.dtsi
+index 59d7557d3b1b..2554e0baea6b 100644
 --- a/arch/arm64/boot/dts/marvell/armada-372x.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-372x.dtsi
 @@ -56,6 +56,7 @@
@@ -23,6 +25,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  			enable-method = "psci";
  		};
  	};
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 3260f27edc0c..544fef59d051 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -64,6 +64,7 @@
@@ -46,3 +50,6 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  			pinctrl_sb: pinctrl@18800 {
  				compatible = "marvell,armada3710-sb-pinctrl",
  					     "syscon", "simple-mfd";
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch b/target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
similarity index 59%
rename from target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
rename to target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
index 206caf2..c27fad6 100644
--- a/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
+++ b/target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
@@ -1,13 +1,15 @@
-From be893f672e340b56ca60f2f6c32fdd713a5852f5 Mon Sep 17 00:00:00 2001
+From ac7263f1c09223aaf46c4c3798db71ef046772cb Mon Sep 17 00:00:00 2001
 From: Kevin Mihelich <kevin@archlinuxarm.org>
 Date: Tue, 4 Jul 2017 19:25:28 -0600
-Subject: arm64: dts: marvell: armada37xx: Add eth0 alias
+Subject: [PATCH 056/127] arm64: dts: marvell: armada37xx: Add eth0 alias
 
 Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
 ---
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
  1 file changed, 1 insertion(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 544fef59d051..8cd43ce38571 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -54,6 +54,7 @@
@@ -18,3 +20,6 @@ Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
  		serial0 = &uart0;
  	};
  
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch b/target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
similarity index 72%
rename from target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch
rename to target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
index 74e78d3..e5630c2 100644
--- a/target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch
+++ b/target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
@@ -1,27 +1,8 @@
-From patchwork Thu Sep 28 12:58:34 2017
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 7bit
-Subject: [v2,
- 3/7] PCI: aardvark: set host and device to the same MAX payload size
-X-Patchwork-Submitter: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-X-Patchwork-Id: 819587
-Message-Id: <20170928125838.11887-4-thomas.petazzoni@free-electrons.com>
-To: Bjorn Helgaas <bhelgaas@google.com>, linux-pci@vger.kernel.org
-Cc: Jason Cooper <jason@lakedaemon.net>, Andrew Lunn <andrew@lunn.ch>,
- Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>, Gregory Clement
- <gregory.clement@free-electrons.com>, 
- Nadav Haklai <nadavh@marvell.com>, Hanna Hawa <hannah@marvell.com>,
- Yehuda Yitschak <yehuday@marvell.com>,
- linux-arm-kernel@lists.infradead.org, Antoine Tenart
- <antoine.tenart@free-electrons.com>, =?utf-8?q?Miqu=C3=A8l_Raynal?=
- <miquel.raynal@free-electrons.com>, Victor Gu <xigu@marvell.com>,
- Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Thu, 28 Sep 2017 14:58:34 +0200
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-List-Id: <linux-pci.vger.kernel.org>
-
+From b706337af2471b1ad8c4b4beb0eeaac3867e01d8 Mon Sep 17 00:00:00 2001
 From: Victor Gu <xigu@marvell.com>
+Date: Thu, 28 Sep 2017 14:58:34 +0200
+Subject: [PATCH 057/127] PCI: aardvark: set host and device to the same MAX
+ payload size
 
 Since the Aardvark does not implement a PCIe root bus, the Linux PCIe
 subsystem will not align the MAX payload size between the host and the
@@ -40,24 +21,25 @@ Reviewed-by: Nadav Haklai <nadavh@marvell.com>
 [Thomas: tweak commit log.]
 Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
 ---
- drivers/pci/host/pci-aardvark.c | 60 ++++++++++++++++++++++++++++++++++++++++-
+ drivers/pci/host/pci-aardvark.c | 60 ++++++++++++++++++++++++++++++++-
  1 file changed, 59 insertions(+), 1 deletion(-)
 
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 5f3048e75bec..3b12157a3298 100644
 --- a/drivers/pci/host/pci-aardvark.c
 +++ b/drivers/pci/host/pci-aardvark.c
-@@ -30,9 +30,11 @@
+@@ -30,8 +30,10 @@
  #define PCIE_CORE_DEV_CTRL_STATS_REG				0xc8
  #define     PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE	(0 << 4)
  #define     PCIE_CORE_DEV_CTRL_STATS_MAX_PAYLOAD_SZ_SHIFT	5
 +#define     PCIE_CORE_DEV_CTRL_STATS_MAX_PAYLOAD_SZ		0x2
  #define     PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE		(0 << 11)
  #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SIZE_SHIFT	12
- #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ		0x2
 +#define     PCIE_CORE_MPS_UNIT_BYTE				128
+ #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ		0x2
  #define PCIE_CORE_LINK_CTRL_STAT_REG				0xd0
  #define     PCIE_CORE_LINK_L0S_ENTRY				BIT(0)
- #define     PCIE_CORE_LINK_TRAINING				BIT(5)
-@@ -297,7 +299,8 @@ static void advk_pcie_setup_hw(struct ad
+@@ -297,7 +299,8 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
  
  	/* Set PCIe Device Control and Status 1 PF0 register */
  	reg = PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE |
@@ -67,7 +49,7 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  		PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE |
  		(PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ <<
  		 PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SIZE_SHIFT);
-@@ -886,6 +889,58 @@ out_release_res:
+@@ -886,6 +889,58 @@ static int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)
  	return err;
  }
  
@@ -126,7 +108,7 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  static int advk_pcie_probe(struct platform_device *pdev)
  {
  	struct device *dev = &pdev->dev;
-@@ -960,6 +1015,9 @@ static int advk_pcie_probe(struct platfo
+@@ -960,6 +1015,9 @@ static int advk_pcie_probe(struct platform_device *pdev)
  	list_for_each_entry(child, &bus->children, node)
  		pcie_bus_configure_settings(child);
  
@@ -136,3 +118,6 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  	pci_bus_add_devices(bus);
  	return 0;
  }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch b/target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
similarity index 50%
rename from target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch
rename to target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
index 0ee4af4..e424910 100644
--- a/target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch
+++ b/target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
@@ -1,26 +1,7 @@
-From patchwork Thu Sep 28 12:58:36 2017
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 7bit
-Subject: [v2,5/7] PCI: aardvark: disable LOS state by default
-X-Patchwork-Submitter: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-X-Patchwork-Id: 819590
-Message-Id: <20170928125838.11887-6-thomas.petazzoni@free-electrons.com>
-To: Bjorn Helgaas <bhelgaas@google.com>, linux-pci@vger.kernel.org
-Cc: Jason Cooper <jason@lakedaemon.net>, Andrew Lunn <andrew@lunn.ch>,
- Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>, Gregory Clement
- <gregory.clement@free-electrons.com>, 
- Nadav Haklai <nadavh@marvell.com>, Hanna Hawa <hannah@marvell.com>,
- Yehuda Yitschak <yehuday@marvell.com>,
- linux-arm-kernel@lists.infradead.org, Antoine Tenart
- <antoine.tenart@free-electrons.com>, =?utf-8?q?Miqu=C3=A8l_Raynal?=
- <miquel.raynal@free-electrons.com>, Victor Gu <xigu@marvell.com>,
- Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Thu, 28 Sep 2017 14:58:36 +0200
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-List-Id: <linux-pci.vger.kernel.org>
-
+From 2c2aeb87f73d9bc0fd811b60d38dd120fc810424 Mon Sep 17 00:00:00 2001
 From: Victor Gu <xigu@marvell.com>
+Date: Thu, 28 Sep 2017 14:58:36 +0200
+Subject: [PATCH 058/127] PCI: aardvark: disable LOS state by default
 
 Some PCIe devices do not support LOS, and will cause timeouts if the
 root complex forces the LOS state. This patch disables the LOS state
@@ -41,9 +22,11 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  drivers/pci/host/pci-aardvark.c | 3 +--
  1 file changed, 1 insertion(+), 2 deletions(-)
 
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 3b12157a3298..50e8addc22f9 100644
 --- a/drivers/pci/host/pci-aardvark.c
 +++ b/drivers/pci/host/pci-aardvark.c
-@@ -368,8 +368,7 @@ static void advk_pcie_setup_hw(struct ad
+@@ -368,8 +368,7 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
  
  	advk_pcie_wait_for_link(pcie);
  
@@ -53,3 +36,6 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
  
  	reg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch b/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch
new file mode 100644
index 0000000..152496a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch
@@ -0,0 +1,106 @@
+From 76506913e4a2f777b7698136c5c37b16ffee2af5 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:49 +0000
+Subject: [PATCH 059/127] net: mvneta: move port configuration
+
+Move the port configuration and release of reset to mvneta_mac_config()
+along side the rest of the port mode configuration.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 51 +++++++++++----------------
+ 1 file changed, 20 insertions(+), 31 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 4cfffadfcac1..cbd81bdf745e 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3285,7 +3285,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	u32 new_an, gmac_an = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
+ 
+ 	new_ctrl0 = gmac_ctrl0 & ~MVNETA_GMAC0_PORT_1000BASE_X;
+-	new_ctrl2 = gmac_ctrl2 & ~MVNETA_GMAC2_INBAND_AN_ENABLE;
++	new_ctrl2 = gmac_ctrl2 & ~(MVNETA_GMAC2_INBAND_AN_ENABLE |
++				   MVNETA_GMAC2_PORT_RESET);
+ 	new_clk = gmac_clk & ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
+ 	new_an = gmac_an & ~(MVNETA_GMAC_INBAND_AN_ENABLE |
+ 			     MVNETA_GMAC_INBAND_RESTART_AN |
+@@ -3303,6 +3304,15 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	if (state->pause & MLO_PAUSE_TXRX_MASK)
+ 		new_an |= MVNETA_GMAC_CONFIG_FLOW_CTRL;
+ 
++	/* Even though it might look weird, when we're configured in
++	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
++	 */
++	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
++
++	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
++	    state->interface == PHY_INTERFACE_MODE_SGMII)
++		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
++
+ 	if (!phylink_autoneg_inband(mode)) {
+ 		/* Phy or fixed speed */
+ 		if (state->duplex)
+@@ -3355,6 +3365,12 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, new_clk);
+ 	if (new_an != gmac_an)
+ 		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, new_an);
++
++	if (gmac_ctrl2 & MVNETA_GMAC2_PORT_RESET) {
++		while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
++			MVNETA_GMAC2_PORT_RESET) != 0)
++			continue;
++	}
+ }
+ 
+ static void mvneta_set_eee(struct mvneta_port *pp, bool enable)
+@@ -4230,42 +4246,15 @@ static void mvneta_conf_mbus_windows(struct mvneta_port *pp,
+ /* Power up the port */
+ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ {
+-	u32 ctrl;
+-
+ 	/* MAC Cause register should be cleared */
+ 	mvreg_write(pp, MVNETA_UNIT_INTR_CAUSE, 0);
+ 
+-	ctrl = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
+-
+-	/* Even though it might look weird, when we're configured in
+-	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
+-	 */
+-	switch(phy_mode) {
+-	case PHY_INTERFACE_MODE_QSGMII:
++	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_SGMII:
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII:
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-		ctrl |= MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	default:
++	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-	}
+-
+-	/* Cancel Port Reset */
+-	ctrl &= ~MVNETA_GMAC2_PORT_RESET;
+-	mvreg_write(pp, MVNETA_GMAC_CTRL_2, ctrl);
+-
+-	while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
+-		MVNETA_GMAC2_PORT_RESET) != 0)
+-		continue;
+ 
+ 	return 0;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch b/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch
new file mode 100644
index 0000000..c1555e7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch
@@ -0,0 +1,65 @@
+From 71316864d24bcb8f64201af42bc7b577b9f624df Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@arm.linux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:54 +0000
+Subject: [PATCH 060/127] net: mvneta: add 1000BaseX support
+
+Add support for 1000BaseX link modes.
+
+Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 18 +++++++++++++++---
+ 1 file changed, 15 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index cbd81bdf745e..003fb1fd92f3 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3212,6 +3212,16 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
++	/* We only support QSGMII, SGMII, 802.3z and RGMII modes */
++	if (state->interface != PHY_INTERFACE_MODE_NA &&
++	    state->interface != PHY_INTERFACE_MODE_QSGMII &&
++	    state->interface != PHY_INTERFACE_MODE_SGMII &&
++	    !phy_interface_mode_is_8023z(state->interface) &&
++	    !phy_interface_mode_is_rgmii(state->interface)) {
++		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		return;
++	}
++
+ 	/* Allow all the expected bits */
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+@@ -3222,7 +3232,7 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ 	phylink_set(mask, 1000baseT_Full);
+ 	phylink_set(mask, 1000baseX_Full);
+ 
+-	if (state->interface != PHY_INTERFACE_MODE_1000BASEX) {
++	if (!phy_interface_mode_is_8023z(state->interface)) {
+ 		/* 10M and 100M are only supported in non-802.3z mode */
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+@@ -3310,7 +3320,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
+-	    state->interface == PHY_INTERFACE_MODE_SGMII)
++	    state->interface == PHY_INTERFACE_MODE_SGMII ||
++	    phy_interface_mode_is_8023z(state->interface))
+ 		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
+ 
+ 	if (!phylink_autoneg_inband(mode)) {
+@@ -4251,7 +4262,8 @@ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ 
+ 	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII ||
++		 phy_mode == PHY_INTERFACE_MODE_1000BASEX)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+ 	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch b/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
new file mode 100644
index 0000000..9af099b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
@@ -0,0 +1,40 @@
+From 9eb155c9b61e893dd8eece840f52362032529777 Mon Sep 17 00:00:00 2001
+From: Julia Lawall <Julia.Lawall@lip6.fr>
+Date: Tue, 2 Jan 2018 14:28:01 +0100
+Subject: [PATCH 061/127] pinctrl: armada-37xx: account for const type of
+ of_device_id.data
+
+The data field of an of_device_id structure has type const void *, so
+there is no need for a const-discarding cast when putting const values
+into such a structure.
+
+Done using Coccinelle.
+
+Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index c5fe7d4a9065..69bddeaad322 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -944,11 +944,11 @@ static int armada_37xx_pinctrl_register(struct platform_device *pdev,
+ static const struct of_device_id armada_37xx_pinctrl_of_match[] = {
+ 	{
+ 		.compatible = "marvell,armada3710-sb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_sb,
++		.data = &armada_37xx_pin_sb,
+ 	},
+ 	{
+ 		.compatible = "marvell,armada3710-nb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_nb,
++		.data = &armada_37xx_pin_nb,
+ 	},
+ 	{ },
+ };
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch b/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch
new file mode 100644
index 0000000..3e9a0eb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch
@@ -0,0 +1,46 @@
+From ef6b6b8555c181df8e40994ae0cac82bd7ca08f6 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:26 +0100
+Subject: [PATCH 062/127] spi: a3700: Set frequency limits at startup
+
+Armada 3700 SPI controller has an internal clock divider which can
+divide the parent clock frequency by up to 30.
+
+This patch sets the limits in the spi_controller fields so that we can
+detect when a non-supported frequency is requested by a device for a
+transfer.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index c11ea6c169a4..8048468277f3 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -27,6 +27,8 @@
+ 
+ #define DRIVER_NAME			"armada_3700_spi"
+ 
++#define A3700_SPI_MAX_SPEED_HZ		100000000
++#define A3700_SPI_MAX_PRESCALE		30
+ #define A3700_SPI_TIMEOUT		10
+ 
+ /* SPI Register Offest */
+@@ -823,6 +825,11 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 		goto error;
+ 	}
+ 
++	master->max_speed_hz = min_t(unsigned long, A3700_SPI_MAX_SPEED_HZ,
++					clk_get_rate(spi->clk));
++	master->min_speed_hz = DIV_ROUND_UP(clk_get_rate(spi->clk),
++						A3700_SPI_MAX_PRESCALE);
++
+ 	ret = a3700_spi_init(spi);
+ 	if (ret)
+ 		goto error_clk;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch b/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
new file mode 100644
index 0000000..b13cc7e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
@@ -0,0 +1,51 @@
+From 13efe77a5072c17be1a2948f1900c86a8fc7ef37 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:27 +0100
+Subject: [PATCH 063/127] spi: a3700: Allow to enable or disable FIFO mode
+
+The armada 3700 SPI controller allows to make transfers without using
+the 32 bytes RFIFO and WFIFO.
+
+This commit enable switching between FIFO and non-FIFO mode, which is
+necessary to implement full-duplex transfers.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 8048468277f3..b38730928186 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -186,12 +186,15 @@ static int a3700_spi_pin_mode_set(struct a3700_spi *a3700_spi,
+ 	return 0;
+ }
+ 
+-static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi)
++static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi, bool enable)
+ {
+ 	u32 val;
+ 
+ 	val = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);
+-	val |= A3700_SPI_FIFO_MODE;
++	if (enable)
++		val |= A3700_SPI_FIFO_MODE;
++	else
++		val &= ~A3700_SPI_FIFO_MODE;
+ 	spireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);
+ }
+ 
+@@ -299,7 +302,7 @@ static int a3700_spi_init(struct a3700_spi *a3700_spi)
+ 		a3700_spi_deactivate_cs(a3700_spi, i);
+ 
+ 	/* Enable FIFO mode */
+-	a3700_spi_fifo_mode_set(a3700_spi);
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+ 	/* Set SPI mode */
+ 	a3700_spi_mode_set(a3700_spi, master->mode_bits);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch b/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch
new file mode 100644
index 0000000..c27d44a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch
@@ -0,0 +1,169 @@
+From 56576a05882c9e117316a4c736b4094e0785c7ff Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:28 +0100
+Subject: [PATCH 064/127] spi: a3700: Add full-duplex support
+
+The armada 3700 SPI controller has support for full-duplex transfers,
+but it can only be done without using the hardware FIFOs.
+
+A full duplex transfer is done by shifting 4 bytes at a time, or even
+one byte at a time for transfers less than 4 bytes long.
+
+While this method is perfectly suitable for small transfers, it is still
+slower than using the FIFOs.
+
+This commit implement full-duplex support, making sure that half-duplex
+transfers are still done using the FIFOs with the existing method.
+
+Some setup functions were moved around to make sure the controller is
+properly configured before beginning each transfer.
+
+This was tested on EspressoBin with a logical analyser, and a simple
+setup where MISO is connected on MOSI. Transfers were made from
+userspace using spidev and spi-pipe from the spi-tools project
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 85 ++++++++++++++++++++++++++++++-----
+ 1 file changed, 73 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index b38730928186..a8576c89f713 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -421,15 +421,20 @@ static void a3700_spi_transfer_setup(struct spi_device *spi,
+ 				     struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi;
+-	unsigned int byte_len;
+ 
+ 	a3700_spi = spi_master_get_devdata(spi->master);
+ 
+ 	a3700_spi_clock_set(a3700_spi, xfer->speed_hz);
+ 
+-	byte_len = xfer->bits_per_word >> 3;
++	/* Use 4 bytes long transfers. Each transfer method has its way to deal
++	 * with the remaining bytes for non 4-bytes aligned transfers.
++	 */
++	a3700_spi_bytelen_set(a3700_spi, 4);
+ 
+-	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
++	/* Initialize the working buffers */
++	a3700_spi->tx_buf  = xfer->tx_buf;
++	a3700_spi->rx_buf  = xfer->rx_buf;
++	a3700_spi->buf_len = xfer->len;
+ }
+ 
+ static void a3700_spi_set_cs(struct spi_device *spi, bool enable)
+@@ -584,27 +589,26 @@ static int a3700_spi_prepare_message(struct spi_master *master,
+ 	if (ret)
+ 		return ret;
+ 
+-	a3700_spi_bytelen_set(a3700_spi, 4);
+-
+ 	a3700_spi_mode_set(a3700_spi, spi->mode);
+ 
+ 	return 0;
+ }
+ 
+-static int a3700_spi_transfer_one(struct spi_master *master,
++static int a3700_spi_transfer_one_fifo(struct spi_master *master,
+ 				  struct spi_device *spi,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+ 	int ret = 0, timeout = A3700_SPI_TIMEOUT;
+-	unsigned int nbits = 0;
++	unsigned int nbits = 0, byte_len;
+ 	u32 val;
+ 
+-	a3700_spi_transfer_setup(spi, xfer);
++	/* Make sure we use FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+-	a3700_spi->tx_buf  = xfer->tx_buf;
+-	a3700_spi->rx_buf  = xfer->rx_buf;
+-	a3700_spi->buf_len = xfer->len;
++	/* Configure FIFO thresholds */
++	byte_len = xfer->bits_per_word >> 3;
++	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
+ 
+ 	if (xfer->tx_buf)
+ 		nbits = xfer->tx_nbits;
+@@ -739,6 +743,64 @@ static int a3700_spi_transfer_one(struct spi_master *master,
+ 	return ret;
+ }
+ 
++static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
++	u32 val_in, val_out;
++
++	/* Disable FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, false);
++
++	while (a3700_spi->buf_len) {
++
++		/* When we have less than 4 bytes to transfer, switch to 1 byte
++		 * mode. This is reset after each transfer
++		 */
++		if (a3700_spi->buf_len < 4)
++			a3700_spi_bytelen_set(a3700_spi, 1);
++
++		if (a3700_spi->byte_len == 1)
++			val_out = *a3700_spi->tx_buf;
++		else
++			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++
++		/* Wait for all the data to be shifted in / out */
++		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
++				A3700_SPI_XFER_DONE))
++			cpu_relax();
++
++		val_in = le32_to_cpu(spireg_read(a3700_spi,
++						 A3700_SPI_DATA_IN_REG));
++
++		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++
++		a3700_spi->buf_len -= a3700_spi->byte_len;
++		a3700_spi->tx_buf += a3700_spi->byte_len;
++		a3700_spi->rx_buf += a3700_spi->byte_len;
++
++	}
++
++	spi_finalize_current_transfer(master);
++
++	return 0;
++}
++
++static int a3700_spi_transfer_one(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	a3700_spi_transfer_setup(spi, xfer);
++
++	if (xfer->tx_buf && xfer->rx_buf)
++		return a3700_spi_transfer_one_full_duplex(master, spi, xfer);
++
++	return a3700_spi_transfer_one_fifo(master, spi, xfer);
++}
++
+ static int a3700_spi_unprepare_message(struct spi_master *master,
+ 				       struct spi_message *message)
+ {
+@@ -788,7 +850,6 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 	master->transfer_one = a3700_spi_transfer_one;
+ 	master->unprepare_message = a3700_spi_unprepare_message;
+ 	master->set_cs = a3700_spi_set_cs;
+-	master->flags = SPI_MASTER_HALF_DUPLEX;
+ 	master->mode_bits |= (SPI_RX_DUAL | SPI_TX_DUAL |
+ 			      SPI_RX_QUAD | SPI_TX_QUAD);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch b/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch
new file mode 100644
index 0000000..2b37668
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch
@@ -0,0 +1,51 @@
+From 47f4b866c6775c9ef31d19cb780140aebb4f64af Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:47 +0100
+Subject: [PATCH 065/127] spi: a3700: Remove endianness swapping functions when
+ accessing FIFOs
+
+Fixes the following sparse warnings :
+line 504: warning: incorrect type in assignment (different base types)
+line 504:    expected unsigned int [unsigned] [usertype] val
+line 504:    got restricted __le32 [usertype] <noident>
+line 527: warning: cast to restricted __le32
+
+This is solved by removing endian-converson functions, since the
+converted values are going through readl/writel anyway, which take care
+of the conversion.
+
+Fixes: 6fd6fd68c9e2 ("spi: armada-3700: Fix padding when sending not 4-byte aligned data")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index a8576c89f713..43ee0b56fe1c 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -501,7 +501,7 @@ static int a3700_spi_fifo_write(struct a3700_spi *a3700_spi)
+ 	u32 val;
+ 
+ 	while (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {
+-		val = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++		val = *(u32 *)a3700_spi->tx_buf;
+ 		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 		a3700_spi->buf_len -= 4;
+ 		a3700_spi->tx_buf += 4;
+@@ -524,9 +524,8 @@ static int a3700_spi_fifo_read(struct a3700_spi *a3700_spi)
+ 	while (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {
+ 		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 		if (a3700_spi->buf_len >= 4) {
+-			u32 data = le32_to_cpu(val);
+ 
+-			memcpy(a3700_spi->rx_buf, &data, 4);
++			memcpy(a3700_spi->rx_buf, &val, 4);
+ 
+ 			a3700_spi->buf_len -= 4;
+ 			a3700_spi->rx_buf += 4;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch b/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
new file mode 100644
index 0000000..0e54d3e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
@@ -0,0 +1,66 @@
+From adfd337e7ad806e73ef86263ae2d30ff09c939e3 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:48 +0100
+Subject: [PATCH 066/127] spi: a3700: Remove endianness swapping for
+ full-duplex transfers
+
+Fixes the following sparse warnings :
+line 767: warning: incorrect type in assignment (different base types)
+line 767:    expected unsigned int [unsigned] [assigned] [usertype] val_out
+line 767:    got restricted __le32 [usertype] <noident>
+line 776: warning: cast to restricted __le32
+
+This takes advantage of readl/writel to do the endianness reordering,
+and removes an extra variable in the function.
+
+Fixes: f68a7dcb91b7 ("spi: a3700: Add full-duplex support")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 13 ++++++-------
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 43ee0b56fe1c..7dcb14d303eb 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -747,7 +747,7 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+-	u32 val_in, val_out;
++	u32 val;
+ 
+ 	/* Disable FIFO mode */
+ 	a3700_spi_fifo_mode_set(a3700_spi, false);
+@@ -761,21 +761,20 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 			a3700_spi_bytelen_set(a3700_spi, 1);
+ 
+ 		if (a3700_spi->byte_len == 1)
+-			val_out = *a3700_spi->tx_buf;
++			val = *a3700_spi->tx_buf;
+ 		else
+-			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++			val = *(u32 *)a3700_spi->tx_buf;
+ 
+-		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 
+ 		/* Wait for all the data to be shifted in / out */
+ 		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
+ 				A3700_SPI_XFER_DONE))
+ 			cpu_relax();
+ 
+-		val_in = le32_to_cpu(spireg_read(a3700_spi,
+-						 A3700_SPI_DATA_IN_REG));
++		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 
+-		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++		memcpy(a3700_spi->rx_buf, &val, a3700_spi->byte_len);
+ 
+ 		a3700_spi->buf_len -= a3700_spi->byte_len;
+ 		a3700_spi->tx_buf += a3700_spi->byte_len;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch b/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
new file mode 100644
index 0000000..7c218b7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
@@ -0,0 +1,109 @@
+From 790277cb0c42ade3b262cbbd21b60cc0436f7771 Mon Sep 17 00:00:00 2001
+From: Ken Ma <make@marvell.com>
+Date: Thu, 19 Oct 2017 15:10:03 +0200
+Subject: [PATCH 067/127] pinctrl: armada-37xx: Add edge both type gpio irq
+ support
+
+Current edge both type gpio irqs which need to swap polarity in each
+interrupt are not supported, this patch adds edge both type gpio irq
+support.
+
+Signed-off-by: Ken Ma <make@marvell.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 64 +++++++++++++++++++++
+ 1 file changed, 64 insertions(+)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 69bddeaad322..2b4261b3c0f7 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -585,6 +585,19 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 		val |= (BIT(d->hwirq % GPIO_PER_REG));
+ 		break;
++	case IRQ_TYPE_EDGE_BOTH: {
++		u32 in_val, in_reg = INPUT_VAL;
++
++		armada_37xx_irq_update_reg(&in_reg, d);
++		regmap_read(info->regmap, in_reg, &in_val);
++
++		/* Set initial polarity based on current input level. */
++		if (in_val & d->mask)
++			val |= d->mask;		/* falling */
++		else
++			val &= ~d->mask;	/* rising */
++		break;
++	}
+ 	default:
+ 		spin_unlock_irqrestore(&info->irq_lock, flags);
+ 		return -EINVAL;
+@@ -595,6 +608,40 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	return 0;
+ }
+ 
++static int armada_37xx_edge_both_irq_swap_pol(struct armada_37xx_pinctrl *info,
++					     u32 pin_idx)
++{
++	u32 reg_idx = pin_idx / GPIO_PER_REG;
++	u32 bit_num = pin_idx % GPIO_PER_REG;
++	u32 p, l, ret;
++	unsigned long flags;
++
++	regmap_read(info->regmap, INPUT_VAL + 4*reg_idx, &l);
++
++	spin_lock_irqsave(&info->irq_lock, flags);
++	p = readl(info->base + IRQ_POL + 4 * reg_idx);
++	if ((p ^ l) & (1 << bit_num)) {
++		/*
++		 * For the gpios which are used for both-edge irqs, when their
++		 * interrupts happen, their input levels are changed,
++		 * yet their interrupt polarities are kept in old values, we
++		 * should synchronize their interrupt polarities; for example,
++		 * at first a gpio's input level is low and its interrupt
++		 * polarity control is "Detect rising edge", then the gpio has
++		 * a interrupt , its level turns to high, we should change its
++		 * polarity control to "Detect falling edge" correspondingly.
++		 */
++		p ^= 1 << bit_num;
++		writel(p, info->base + IRQ_POL + 4 * reg_idx);
++		ret = 0;
++	} else {
++		/* Spurious irq */
++		ret = -1;
++	}
++
++	spin_unlock_irqrestore(&info->irq_lock, flags);
++	return ret;
++}
+ 
+ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ {
+@@ -618,6 +665,23 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 			u32 hwirq = ffs(status) - 1;
+ 			u32 virq = irq_find_mapping(d, hwirq +
+ 						     i * GPIO_PER_REG);
++			u32 t = irq_get_trigger_type(virq);
++
++			if ((t & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
++				/* Swap polarity (race with GPIO line) */
++				if (armada_37xx_edge_both_irq_swap_pol(info,
++					hwirq + i * GPIO_PER_REG)) {
++					/*
++					 * For spurious irq, which gpio level
++					 * is not as expected after incoming
++					 * edge, just ack the gpio irq.
++					 */
++					writel(1 << hwirq,
++					       info->base +
++					       IRQ_STATUS + 4 * i);
++					continue;
++				}
++			}
+ 
+ 			generic_handle_irq(virq);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch b/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
new file mode 100644
index 0000000..ce2b486
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
@@ -0,0 +1,49 @@
+From 6ac2248c03ba775796d4a4b6f5b5cf91aafc3daa Mon Sep 17 00:00:00 2001
+From: Thierry Reding <treding@nvidia.com>
+Date: Mon, 16 Oct 2017 14:40:23 +0200
+Subject: [PATCH 068/127] pinctrl: armada-37xx: Stop using struct
+ gpio_chip.irq_base
+
+The Armada 37xx driver always initializes the IRQ base to 0, hence the
+subtraction is a no-op. Remove the subtraction and thereby the last user
+of struct gpio_chip's .irq_base field.
+
+Note that this was also actually a bug and only worked because of the
+above assumption. If the IRQ base had been dynamically allocated, the
+subtraction would've caused the wrong mask to be generated since the
+struct irq_data.hwirq field is an index local to the IRQ domain. As a
+result, it should now be safe to also allocate this chip's IRQ base
+dynamically, unless there are consumers left that refer to the IRQs by
+their global number.
+
+Signed-off-by: Thierry Reding <treding@nvidia.com>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 2b4261b3c0f7..639c3836259f 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -700,14 +700,14 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+ 	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-	int irq = d->hwirq - chip->irq_base;
++
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+ 	 * irqchip framework. As we don't use this framework, we can
+ 	 * reuse this field for our own usage.
+ 	 */
+-	d->mask = BIT(irq % GPIO_PER_REG);
++	d->mask = BIT(d->hwirq % GPIO_PER_REG);
+ 
+ 	armada_37xx_irq_unmask(d);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch b/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch
new file mode 100644
index 0000000..fcbc70b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch
@@ -0,0 +1,35 @@
+From f6b3e75c2a2d604952c5350b126b818bc4333cde Mon Sep 17 00:00:00 2001
+From: Arnd Bergmann <arnd@arndb.de>
+Date: Thu, 2 Nov 2017 15:29:13 +0100
+Subject: [PATCH 069/127] pinctrl: armada-37xx: remove unused variable
+
+A cleanup left behind a temporary variable that is now unused:
+
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c: In function 'armada_37xx_irq_startup':
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c:693:20: error: unused variable 'chip' [-Werror=unused-variable]
+
+This removes the declarations as well.
+
+Fixes: 3ee9e605caea ("pinctrl: armada-37xx: Stop using struct gpio_chip.irq_base")
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 639c3836259f..44897d4b9d88 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -699,8 +699,6 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+-	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch b/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
new file mode 100644
index 0000000..c58c364
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
@@ -0,0 +1,35 @@
+From 5a429594bac6ebffede0251d497a441d20025d8d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Tue, 20 Mar 2018 10:44:40 +0100
+Subject: [PATCH 070/127] net: dsa: mv88e6xxx: Fix name of switch 88E6141
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The switch name is emitted in the kernel log, so having the right name
+there is nice.
+
+Fixes: 1558727a1c1b ("net: dsa: mv88e6xxx: Add support for ethernet switch 88E6141")
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 4fbc75b73433..14ae3a68d3c6 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3333,7 +3333,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 	[MV88E6141] = {
+ 		.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6141,
+ 		.family = MV88E6XXX_FAMILY_6341,
+-		.name = "Marvell 88E6341",
++		.name = "Marvell 88E6141",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
+ 		.max_vid = 4095,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch b/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch
new file mode 100644
index 0000000..aa7ae60
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch
@@ -0,0 +1,59 @@
+From 4e0b5317eb3da73e74b232782c31962f432fa178 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:16 +0000
+Subject: [PATCH 071/127] phy: add phy_interface_mode_is_8023z() helper
+
+Add and use phy_interface_mode_is_8023z() helper to identify the
+interface modes that use 802.3z negotiation.  Use it in phylink's
+phylink_mac_an_restart().
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c |  3 +--
+ include/linux/phy.h       | 14 ++++++++++++++
+ 2 files changed, 15 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index eb9d9ee24e40..8c125208b919 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -320,8 +320,7 @@ static void phylink_mac_config(struct phylink *pl,
+ static void phylink_mac_an_restart(struct phylink *pl)
+ {
+ 	if (pl->link_config.an_enabled &&
+-	    (pl->link_config.interface == PHY_INTERFACE_MODE_1000BASEX ||
+-	     pl->link_config.interface == PHY_INTERFACE_MODE_2500BASEX))
++	    phy_interface_mode_is_8023z(pl->link_config.interface))
+ 		pl->ops->mac_an_restart(pl->netdev);
+ }
+ 
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index efc04c2d92c9..7359e2bd14c1 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -760,6 +760,20 @@ static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
+ 		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
+ };
+ 
++/**
++ * phy_interface_mode_is_8023z() - does the phy interface mode use 802.3z
++ *   negotiation
++ * @mode: one of &enum phy_interface_t
++ *
++ * Returns true if the phy interface mode uses the 16-bit negotiation
++ * word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)
++ */
++static inline bool phy_interface_mode_is_8023z(phy_interface_t mode)
++{
++	return mode == PHY_INTERFACE_MODE_1000BASEX ||
++	       mode == PHY_INTERFACE_MODE_2500BASEX;
++}
++
+ /**
+  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
+  * is RGMII (all variants)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
new file mode 100644
index 0000000..ce86850
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
@@ -0,0 +1,246 @@
+From 1fc64772bfb2179a44b622b03c597ed6303d621a Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Mon, 30 Oct 2017 21:42:57 -0700
+Subject: [PATCH 072/127] net: phy: Cosmetic fixes to phylink/sfp/sfp-bus.c
+
+Perform a number of stylistic changes to phylink.c, sfp.c and sfp-bus.c:
+
+- align with netdev-style comments
+- align function arguments to the opening parenthesis
+- remove blank lines
+- fixup a few lines over 80 columns
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 13 ++++++-------
+ drivers/net/phy/sfp-bus.c | 11 +++--------
+ drivers/net/phy/sfp.c     | 27 +++++++++++++--------------
+ 3 files changed, 22 insertions(+), 29 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 8c125208b919..65dfdd76d7eb 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -360,7 +360,7 @@ static void phylink_get_fixed_state(struct phylink *pl, struct phylink_link_stat
+  *    1     1       0     1     TX
+  */
+ static void phylink_resolve_flow(struct phylink *pl,
+-	struct phylink_link_state *state)
++				 struct phylink_link_state *state)
+ {
+ 	int new_pause = 0;
+ 
+@@ -520,7 +520,8 @@ static int phylink_register_sfp(struct phylink *pl, struct device_node *np)
+ }
+ 
+ struct phylink *phylink_create(struct net_device *ndev, struct device_node *np,
+-	phy_interface_t iface, const struct phylink_mac_ops *ops)
++			       phy_interface_t iface,
++			       const struct phylink_mac_ops *ops)
+ {
+ 	struct phylink *pl;
+ 	int ret;
+@@ -602,7 +603,7 @@ void phylink_phy_change(struct phy_device *phydev, bool up, bool do_carrier)
+ 	phylink_run_resolve(pl);
+ 
+ 	netdev_dbg(pl->netdev, "phy link %s %s/%s/%s\n", up ? "up" : "down",
+-	           phy_modes(phydev->interface),
++		   phy_modes(phydev->interface),
+ 		   phy_speed_to_str(phydev->speed),
+ 		   phy_duplex_to_str(phydev->duplex));
+ }
+@@ -842,7 +843,7 @@ static void phylink_get_ksettings(const struct phylink_link_state *state,
+ }
+ 
+ int phylink_ethtool_ksettings_get(struct phylink *pl,
+-	struct ethtool_link_ksettings *kset)
++				  struct ethtool_link_ksettings *kset)
+ {
+ 	struct phylink_link_state link_state;
+ 
+@@ -889,7 +890,7 @@ int phylink_ethtool_ksettings_get(struct phylink *pl,
+ EXPORT_SYMBOL_GPL(phylink_ethtool_ksettings_get);
+ 
+ int phylink_ethtool_ksettings_set(struct phylink *pl,
+-	const struct ethtool_link_ksettings *kset)
++				  const struct ethtool_link_ksettings *kset)
+ {
+ 	struct ethtool_link_ksettings our_kset;
+ 	struct phylink_link_state config;
+@@ -1329,8 +1330,6 @@ int phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)
+ }
+ EXPORT_SYMBOL_GPL(phylink_mii_ioctl);
+ 
+-
+-
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 3a0a05bbd45d..ffeeeae8e36a 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -26,7 +26,6 @@ struct sfp_bus {
+ 	bool started;
+ };
+ 
+-
+ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support)
+ {
+@@ -208,7 +207,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-
+ static LIST_HEAD(sfp_buses);
+ static DEFINE_MUTEX(sfp_mutex);
+ 
+@@ -299,7 +297,6 @@ static void sfp_unregister_bus(struct sfp_bus *bus)
+ 	bus->registered = false;
+ }
+ 
+-
+ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ {
+ 	return bus->socket_ops->module_info(bus->sfp, modinfo);
+@@ -307,7 +304,7 @@ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ EXPORT_SYMBOL_GPL(sfp_get_module_info);
+ 
+ int sfp_get_module_eeprom(struct sfp_bus *bus, struct ethtool_eeprom *ee,
+-	u8 *data)
++			  u8 *data)
+ {
+ 	return bus->socket_ops->module_eeprom(bus->sfp, ee, data);
+ }
+@@ -330,8 +327,8 @@ void sfp_upstream_stop(struct sfp_bus *bus)
+ EXPORT_SYMBOL_GPL(sfp_upstream_stop);
+ 
+ struct sfp_bus *sfp_register_upstream(struct device_node *np,
+-	struct net_device *ndev, void *upstream,
+-	const struct sfp_upstream_ops *ops)
++				      struct net_device *ndev, void *upstream,
++				      const struct sfp_upstream_ops *ops)
+ {
+ 	struct sfp_bus *bus = sfp_bus_get(np);
+ 	int ret = 0;
+@@ -369,7 +366,6 @@ void sfp_unregister_upstream(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_unregister_upstream);
+ 
+-
+ /* Socket driver entry points */
+ int sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)
+ {
+@@ -396,7 +392,6 @@ void sfp_remove_phy(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_remove_phy);
+ 
+-
+ void sfp_link_up(struct sfp_bus *bus)
+ {
+ 	const struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 30f5de87f5b5..ebb4cbd46bd9 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -88,15 +88,12 @@ static const enum gpiod_flags gpio_flags[] = {
+ #define T_PROBE_INIT	msecs_to_jiffies(300)
+ #define T_PROBE_RETRY	msecs_to_jiffies(100)
+ 
+-/*
+- * SFP modules appear to always have their PHY configured for bus address
++/* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
+  */
+ #define SFP_PHY_ADDR	22
+ 
+-/*
+- * Give this long for the PHY to reset.
+- */
++/* Give this long for the PHY to reset. */
+ #define T_PHY_RESET_MS	50
+ 
+ static DEFINE_MUTEX(sfp_mutex);
+@@ -151,10 +148,10 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ 		/* If the module is present, drive the signals */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+ 			gpiod_direction_output(sfp->gpio[GPIO_TX_DISABLE],
+-						state & SFP_F_TX_DISABLE);
++					       state & SFP_F_TX_DISABLE);
+ 		if (state & SFP_F_RATE_SELECT)
+ 			gpiod_direction_output(sfp->gpio[GPIO_RATE_SELECT],
+-						state & SFP_F_RATE_SELECT);
++					       state & SFP_F_RATE_SELECT);
+ 	} else {
+ 		/* Otherwise, let them float to the pull-ups */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+@@ -165,7 +162,7 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ }
+ 
+ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+-	void *buf, size_t len)
++			 void *buf, size_t len)
+ {
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+@@ -187,7 +184,7 @@ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+ }
+ 
+ static int sfp_i2c_read(struct sfp *sfp, bool a2, u8 addr, void *buf,
+-	size_t len)
++			size_t len)
+ {
+ 	return sfp__i2c_read(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len);
+ }
+@@ -221,7 +218,6 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ 	return 0;
+ }
+ 
+-
+ /* Interface */
+ static unsigned int sfp_get_state(struct sfp *sfp)
+ {
+@@ -474,7 +470,8 @@ static void sfp_sm_next(struct sfp *sfp, unsigned int state,
+ 	sfp_sm_set_timer(sfp, timeout);
+ }
+ 
+-static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state, unsigned int timeout)
++static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state,
++			    unsigned int timeout)
+ {
+ 	sfp->sm_mod_state = state;
+ 	sfp_sm_set_timer(sfp, timeout);
+@@ -549,7 +546,8 @@ static void sfp_sm_link_check_los(struct sfp *sfp)
+ static void sfp_sm_fault(struct sfp *sfp, bool warn)
+ {
+ 	if (sfp->sm_retries && !--sfp->sm_retries) {
+-		dev_err(sfp->dev, "module persistently indicates fault, disabling\n");
++		dev_err(sfp->dev,
++			"module persistently indicates fault, disabling\n");
+ 		sfp_sm_next(sfp, SFP_S_TX_DISABLE, 0);
+ 	} else {
+ 		if (warn)
+@@ -648,7 +646,8 @@ static int sfp_sm_mod_probe(struct sfp *sfp)
+ 	date[7] = sfp->id.ext.datecode[1];
+ 	date[8] = '\0';
+ 
+-	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n", vendor, part, rev, sn, date);
++	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n",
++		 vendor, part, rev, sn, date);
+ 	dev_info(sfp->dev, "  %s connector, encoding %s, nominal bitrate %u.%uGbps +%u%% -%u%%\n",
+ 		 sfp_connector(sfp->id.base.connector),
+ 		 sfp_encoding(sfp->id.base.encoding),
+@@ -919,7 +918,7 @@ static int sfp_module_info(struct sfp *sfp, struct ethtool_modinfo *modinfo)
+ }
+ 
+ static int sfp_module_eeprom(struct sfp *sfp, struct ethtool_eeprom *ee,
+-	u8 *data)
++			     u8 *data)
+ {
+ 	unsigned int first, last, len;
+ 	int ret;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
new file mode 100644
index 0000000..da5f28b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
@@ -0,0 +1,30 @@
+From 2de4d6fa6b53359ff3305523c86f74e097ff6c2b Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:58 +0000
+Subject: [PATCH 073/127] sfp: fix sparse warning
+
+drivers/net/phy/sfp-bus.c:298:13: warning: context imbalance in 'sfp_bus_release' - wrong count at exit
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index ffeeeae8e36a..961ef6f5f93d 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -246,7 +246,7 @@ static struct sfp_bus *sfp_bus_get(struct device_node *np)
+ 	return found;
+ }
+ 
+-static void sfp_bus_release(struct kref *kref) __releases(sfp_mutex)
++static void sfp_bus_release(struct kref *kref)
+ {
+ 	struct sfp_bus *bus = container_of(kref, struct sfp_bus, kref);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch b/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch
new file mode 100644
index 0000000..64f210f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch
@@ -0,0 +1,57 @@
+From ec218ef9e62783bb83fb10c8afbb5ecff555c5c4 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:17 +0000
+Subject: [PATCH 074/127] sfp: don't guess support from connector type
+
+Don't try to guess the support mask from the connector type - this is
+mostly irrelevant to the speeds that the transceiver supports.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 29 -----------------------------
+ 1 file changed, 29 deletions(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 961ef6f5f93d..b6f198183b89 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -175,35 +175,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		if (id->base.br_nominal >= 12)
+ 			phylink_set(support, 1000baseX_Full);
+ 	}
+-
+-	switch (id->base.connector) {
+-	case SFP_CONNECTOR_SC:
+-	case SFP_CONNECTOR_FIBERJACK:
+-	case SFP_CONNECTOR_LC:
+-	case SFP_CONNECTOR_MT_RJ:
+-	case SFP_CONNECTOR_MU:
+-	case SFP_CONNECTOR_OPTICAL_PIGTAIL:
+-		break;
+-
+-	case SFP_CONNECTOR_UNSPEC:
+-		if (id->base.e1000_base_t)
+-			break;
+-
+-	case SFP_CONNECTOR_SG: /* guess */
+-	case SFP_CONNECTOR_MPO_1X12:
+-	case SFP_CONNECTOR_MPO_2X16:
+-	case SFP_CONNECTOR_HSSDC_II:
+-	case SFP_CONNECTOR_COPPER_PIGTAIL:
+-	case SFP_CONNECTOR_NOSEPARATE:
+-	case SFP_CONNECTOR_MXC_2X16:
+-	default:
+-		/* a guess at the supported link modes */
+-		dev_warn(bus->sfp_dev,
+-			 "Guessing link modes, please report...\n");
+-		phylink_set(support, 1000baseT_Half);
+-		phylink_set(support, 1000baseT_Full);
+-		break;
+-	}
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
new file mode 100644
index 0000000..48669f3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
@@ -0,0 +1,60 @@
+From 37f774883d4bf543413cd80c42e2d79942415eda Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:23 +0000
+Subject: [PATCH 075/127] sfp: add support for 1000Base-PX and 1000Base-BX10
+
+Add support for decoding the transceiver information for 1000Base-PX and
+1000Base-BX10.  These use 1000BASE-X protocol.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index b6f198183b89..902d64f86f63 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -120,10 +120,26 @@ EXPORT_SYMBOL_GPL(sfp_parse_interface);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		       unsigned long *support)
+ {
++	unsigned int br_min, br_nom, br_max;
++
+ 	phylink_set(support, Autoneg);
+ 	phylink_set(support, Pause);
+ 	phylink_set(support, Asym_Pause);
+ 
++	/* Decode the bitrate information to MBd */
++	br_min = br_nom = br_max = 0;
++	if (id->base.br_nominal) {
++		if (id->base.br_nominal != 255) {
++			br_nom = id->base.br_nominal * 100;
++			br_min = br_nom + id->base.br_nominal * id->ext.br_min;
++			br_max = br_nom + id->base.br_nominal * id->ext.br_max;
++		} else if (id->ext.br_max) {
++			br_nom = 250 * id->ext.br_max;
++			br_max = br_nom + br_nom * id->ext.br_min / 100;
++			br_min = br_nom - br_nom * id->ext.br_min / 100;
++		}
++	}
++
+ 	/* Set ethtool support from the compliance fields. */
+ 	if (id->base.e10g_base_sr)
+ 		phylink_set(support, 10000baseSR_Full);
+@@ -142,6 +158,11 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		phylink_set(support, 1000baseT_Full);
+ 	}
+ 
++	/* 1000Base-PX or 1000Base-BX10 */
++	if ((id->base.e_base_px || id->base.e_base_bx10) &&
++	    br_min <= 1300 && br_max >= 1200)
++		phylink_set(support, 1000baseX_Full);
++
+ 	switch (id->base.extended_cc) {
+ 	case 0x00: /* Unspecified */
+ 		break;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch b/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch
new file mode 100644
index 0000000..46ba114
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch
@@ -0,0 +1,102 @@
+From c4d80b5c828eadf96827ed2b10fb769745898b1a Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:32 -0700
+Subject: [PATCH 076/127] net: dsa: Add PHYLINK switch operations
+
+In preparation for adding support for PHYLINK within DSA, define a number of
+operations that we will need and that switch drivers can start implementing.
+Proper integration with PHYLINK will follow in subsequent patches.
+
+We start selecting PHYLINK (which implies PHYLIB) in net/dsa/Kconfig
+such that drivers can be guaranteed that this dependency is properly
+taken care of and can start referencing PHYLINK helper functions without
+requiring stubs or anything.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/dsa.h | 24 ++++++++++++++++++++++++
+ net/dsa/Kconfig   |  2 +-
+ net/dsa/slave.c   |  5 +++++
+ 3 files changed, 30 insertions(+), 1 deletion(-)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index dd44d6ce1097..bc8a2b4872dc 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -19,12 +19,14 @@
+ #include <linux/workqueue.h>
+ #include <linux/of.h>
+ #include <linux/ethtool.h>
++#include <linux/phy.h>
+ #include <net/devlink.h>
+ #include <net/switchdev.h>
+ 
+ struct tc_action;
+ struct phy_device;
+ struct fixed_phy_status;
++struct phylink_link_state;
+ 
+ enum dsa_tag_protocol {
+ 	DSA_TAG_PROTO_NONE = 0,
+@@ -313,6 +315,28 @@ struct dsa_switch_ops {
+ 	void	(*fixed_link_update)(struct dsa_switch *ds, int port,
+ 				struct fixed_phy_status *st);
+ 
++	/*
++	 * PHYLINK integration
++	 */
++	void	(*phylink_validate)(struct dsa_switch *ds, int port,
++				    unsigned long *supported,
++				    struct phylink_link_state *state);
++	int	(*phylink_mac_link_state)(struct dsa_switch *ds, int port,
++					  struct phylink_link_state *state);
++	void	(*phylink_mac_config)(struct dsa_switch *ds, int port,
++				      unsigned int mode,
++				      const struct phylink_link_state *state);
++	void	(*phylink_mac_an_restart)(struct dsa_switch *ds, int port);
++	void	(*phylink_mac_link_down)(struct dsa_switch *ds, int port,
++					 unsigned int mode,
++					 phy_interface_t interface);
++	void	(*phylink_mac_link_up)(struct dsa_switch *ds, int port,
++				       unsigned int mode,
++				       phy_interface_t interface,
++				       struct phy_device *phydev);
++	void	(*phylink_fixed_state)(struct dsa_switch *ds, int port,
++				       struct phylink_link_state *state);
++
+ 	/*
+ 	 * ethtool hardware statistics.
+ 	 */
+diff --git a/net/dsa/Kconfig b/net/dsa/Kconfig
+index cc5f8f971689..250254230ebb 100644
+--- a/net/dsa/Kconfig
++++ b/net/dsa/Kconfig
+@@ -8,7 +8,7 @@ config NET_DSA
+ 	tristate "Distributed Switch Architecture"
+ 	depends on HAVE_NET_DSA && MAY_USE_DEVLINK
+ 	select NET_SWITCHDEV
+-	select PHYLIB
++	select PHYLINK
+ 	---help---
+ 	  Say Y if you want to enable support for the hardware switches supported
+ 	  by the Distributed Switch Architecture.
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index b14d530a32b1..cd4925f83ba4 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -1130,6 +1130,11 @@ static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
+ 				  p->phy_interface);
+ }
+ 
++void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up)
++{
++}
++EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_change);
++
+ static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
+ 				struct net_device *slave_dev)
+ {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch b/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch
new file mode 100644
index 0000000..9a294ac
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch
@@ -0,0 +1,50 @@
+From 2bbe15ce77bfe8913750a4ecfda3f68edb14ef40 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:34 -0700
+Subject: [PATCH 077/127] net: dsa: Eliminate dsa_slave_get_link()
+
+Since we use PHYLIB to manage the per-port link indication, this will
+also be reflected correctly in the network device's carrier state, so we
+can use ethtool_op_get_link() instead.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/dsa/slave.c | 14 +-------------
+ 1 file changed, 1 insertion(+), 13 deletions(-)
+
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index cd4925f83ba4..3460cba3d315 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -503,18 +503,6 @@ static int dsa_slave_nway_reset(struct net_device *dev)
+ 	return -EOPNOTSUPP;
+ }
+ 
+-static u32 dsa_slave_get_link(struct net_device *dev)
+-{
+-	struct dsa_slave_priv *p = netdev_priv(dev);
+-
+-	if (p->phy != NULL) {
+-		genphy_update_link(p->phy);
+-		return p->phy->link;
+-	}
+-
+-	return -EOPNOTSUPP;
+-}
+-
+ static int dsa_slave_get_eeprom_len(struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+@@ -1016,7 +1004,7 @@ static const struct ethtool_ops dsa_slave_ethtool_ops = {
+ 	.get_regs_len		= dsa_slave_get_regs_len,
+ 	.get_regs		= dsa_slave_get_regs,
+ 	.nway_reset		= dsa_slave_nway_reset,
+-	.get_link		= dsa_slave_get_link,
++	.get_link		= ethtool_op_get_link,
+ 	.get_eeprom_len		= dsa_slave_get_eeprom_len,
+ 	.get_eeprom		= dsa_slave_get_eeprom,
+ 	.set_eeprom		= dsa_slave_set_eeprom,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch b/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch
new file mode 100644
index 0000000..9df8e9a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch
@@ -0,0 +1,84 @@
+From 6fb63181946b5fae8b757cd2f2c363c2b7a47388 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Wed, 28 Mar 2018 15:44:15 -0700
+Subject: [PATCH 078/127] net: phy: phylink: Provide PHY interface to
+ mac_link_{up, down}
+
+In preparation for having DSA transition entirely to PHYLINK, we need to pass a
+PHY interface type to the mac_link_{up,down} callbacks because we may have to
+make decisions on that (e.g: turn on/off RGMII interfaces etc.). We do not pass
+an entire phylink_link_state because not all parameters (pause, duplex etc.) are
+defined when the link is down, only link and interface are.
+
+Update mvneta accordingly since it currently implements phylink_mac_ops.
+
+Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 4 +++-
+ drivers/net/phy/phylink.c             | 4 +++-
+ include/linux/phylink.h               | 4 +++-
+ 3 files changed, 9 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 003fb1fd92f3..a837a053bdad 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3396,7 +3396,8 @@ static void mvneta_set_eee(struct mvneta_port *pp, bool enable)
+ 	mvreg_write(pp, MVNETA_LPI_CTRL_1, lpi_ctl1);
+ }
+ 
+-static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode)
++static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode,
++				 phy_interface_t interface)
+ {
+ 	struct mvneta_port *pp = netdev_priv(ndev);
+ 	u32 val;
+@@ -3415,6 +3416,7 @@ static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode)
+ }
+ 
+ static void mvneta_mac_link_up(struct net_device *ndev, unsigned int mode,
++			       phy_interface_t interface,
+ 			       struct phy_device *phy)
+ {
+ 	struct mvneta_port *pp = netdev_priv(ndev);
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 65dfdd76d7eb..0a5abf1be642 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -462,10 +462,12 @@ static void phylink_resolve(struct work_struct *w)
+ 	if (link_state.link != netif_carrier_ok(ndev)) {
+ 		if (!link_state.link) {
+ 			netif_carrier_off(ndev);
+-			pl->ops->mac_link_down(ndev, pl->link_an_mode);
++			pl->ops->mac_link_down(ndev, pl->link_an_mode,
++					       pl->phy_state.interface);
+ 			netdev_info(ndev, "Link is Down\n");
+ 		} else {
+ 			pl->ops->mac_link_up(ndev, pl->link_an_mode,
++					     pl->phy_state.interface,
+ 					     pl->phydev);
+ 
+ 			netif_carrier_on(ndev);
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index 76f054f39684..c241a0b6c29c 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -95,8 +95,10 @@ struct phylink_mac_ops {
+ 	 */
+ 	void (*mac_an_restart)(struct net_device *ndev);
+ 
+-	void (*mac_link_down)(struct net_device *, unsigned int mode);
++	void (*mac_link_down)(struct net_device *, unsigned int mode,
++			      phy_interface_t interface);
+ 	void (*mac_link_up)(struct net_device *, unsigned int mode,
++			    phy_interface_t interface,
+ 			    struct phy_device *);
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch b/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch
new file mode 100644
index 0000000..9130db0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch
@@ -0,0 +1,71 @@
+From 3e301ce5884a77dae23207dcbda9a24e85f42de7 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:25 -0800
+Subject: [PATCH 079/127] net: phy: phylink: Allow specifying PHY device flags
+
+In order to let subsystems like DSA fully utilize PHYLINK, we need to be able
+to communicate phy_device::flags from of_phy_{connect,attach} even when using
+PHYLINK APIs.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 2 +-
+ drivers/net/phy/phylink.c             | 6 ++++--
+ include/linux/phylink.h               | 2 +-
+ 3 files changed, 6 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index a837a053bdad..2986f8f1ae4a 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3449,7 +3449,7 @@ static const struct phylink_mac_ops mvneta_phylink_ops = {
+ static int mvneta_mdio_probe(struct mvneta_port *pp)
+ {
+ 	struct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };
+-	int err = phylink_of_phy_connect(pp->phylink, pp->dn);
++	int err = phylink_of_phy_connect(pp->phylink, pp->dn, 0);
+ 	if (err)
+ 		netdev_err(pp->dev, "could not attach PHY\n");
+ 
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 0a5abf1be642..1480979da9de 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -687,7 +687,8 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ }
+ EXPORT_SYMBOL_GPL(phylink_connect_phy);
+ 
+-int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn)
++int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
++			   u32 flags)
+ {
+ 	struct device_node *phy_node;
+ 	struct phy_device *phy_dev;
+@@ -711,7 +712,8 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn)
+ 		return 0;
+ 	}
+ 
+-	phy_dev = of_phy_attach(pl->netdev, phy_node, 0, pl->link_interface);
++	phy_dev = of_phy_attach(pl->netdev, phy_node, flags,
++				pl->link_interface);
+ 	/* We're done with the phy_node handle */
+ 	of_node_put(phy_node);
+ 
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index c241a0b6c29c..afb74404e8bf 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -107,7 +107,7 @@ struct phylink *phylink_create(struct net_device *, struct device_node *,
+ void phylink_destroy(struct phylink *);
+ 
+ int phylink_connect_phy(struct phylink *, struct phy_device *);
+-int phylink_of_phy_connect(struct phylink *, struct device_node *);
++int phylink_of_phy_connect(struct phylink *, struct device_node *, u32 flags);
+ void phylink_disconnect_phy(struct phylink *);
+ 
+ void phylink_mac_change(struct phylink *, bool up);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch b/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch
new file mode 100644
index 0000000..5b55b70
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch
@@ -0,0 +1,35 @@
+From 174428567d991f4123c536b6dde0e97c21d6b98f Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:26 -0800
+Subject: [PATCH 080/127] net: phy: phylink: Use PHY device interface if N/A
+
+We may not always be able to resolve a correct phy_interface_t value before
+actually connecting to the PHY device, when that happens, just have
+phylink_connect_phy() utilize what the PHY device/driver provided.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 1480979da9de..ddba452c2534 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -675,6 +675,12 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ {
+ 	int ret;
+ 
++	/* Use PHY device/driver interface */
++	if (pl->link_interface == PHY_INTERFACE_MODE_NA) {
++		pl->link_interface = phy->interface;
++		pl->link_config.interface = pl->link_interface;
++	}
++
+ 	ret = phy_attach_direct(pl->netdev, phy, 0, pl->link_interface);
+ 	if (ret)
+ 		return ret;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch b/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch
new file mode 100644
index 0000000..7003be1
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch
@@ -0,0 +1,35 @@
+From ee69787b4f2cbe2fc60e08b5288e0879cc328503 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:27 -0800
+Subject: [PATCH 081/127] net: phy: phylink: Remove error message
+
+Some subsystems like DSA may be trying to connect to a PHY through OF first,
+and then attempt a connect using a local MDIO bus, remove the error message:
+"unable to find PHY node" so we can let MAC drivers whether to print it or not.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index ddba452c2534..4b63bf9abb32 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -711,10 +711,8 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
+ 		phy_node = of_parse_phandle(dn, "phy-device", 0);
+ 
+ 	if (!phy_node) {
+-		if (pl->link_an_mode == MLO_AN_PHY) {
+-			netdev_err(pl->netdev, "unable to find PHY node\n");
++		if (pl->link_an_mode == MLO_AN_PHY)
+ 			return -ENODEV;
+-		}
+ 		return 0;
+ 	}
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch b/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch
new file mode 100644
index 0000000..e038fa3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch
@@ -0,0 +1,577 @@
+From 1895108370e472e0102a8c90b3ab0d973649e0d3 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:36 -0700
+Subject: [PATCH 082/127] net: dsa: Plug in PHYLINK support
+
+Add support for PHYLINK within the DSA subsystem in order to support more
+complex devices such as pluggable (SFP) and non-pluggable (SFF) modules, 10G
+PHYs, and traditional PHYs. Using PHYLINK allows us to drop some amount of
+complexity we had while probing fixed and non-fixed PHYs using Device Tree.
+
+Because PHYLINK separates the Ethernet MAC/port configuration into different
+stages, we let switch drivers implement those, and for now, we maintain
+functionality by calling dsa_slave_adjust_link() during
+phylink_mac_link_{up,down} which provides semantically equivalent steps.
+
+Drivers willing to take advantage of PHYLINK should implement the phylink_mac_*
+operations that DSA wraps.
+
+We cannot quite remove the adjust_link() callback just yet, because a number of
+drivers rely on that for configuring their "CPU" and "DSA" ports, this is done
+dsa_port_setup_phy_of() and dsa_port_fixed_link_register_of() still.
+
+Drivers that utilize fixed links for user-facing ports (e.g: bcm_sf2) will need
+to implement phylink_mac_ops from now on to preserve functionality, since PHYLINK
+*does not* create a phy_device instance for fixed links.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/dsa.h  |   4 +
+ net/dsa/dsa_priv.h |  10 --
+ net/dsa/slave.c    | 293 +++++++++++++++++++++------------------------
+ 3 files changed, 138 insertions(+), 169 deletions(-)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index bc8a2b4872dc..464397c41088 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -187,6 +187,7 @@ struct dsa_port {
+ 	u8			stp_state;
+ 	struct net_device	*bridge_dev;
+ 	struct devlink_port	devlink_port;
++	struct phylink		*pl;
+ 	/*
+ 	 * Original copy of the master netdev ethtool_ops
+ 	 */
+@@ -499,4 +500,7 @@ static inline int dsa_switch_resume(struct dsa_switch *ds)
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
++
++void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up);
++
+ #endif
+diff --git a/net/dsa/dsa_priv.h b/net/dsa/dsa_priv.h
+index 9c3eeb72462d..ae8eb8ce7d97 100644
+--- a/net/dsa/dsa_priv.h
++++ b/net/dsa/dsa_priv.h
+@@ -75,16 +75,6 @@ struct dsa_slave_priv {
+ 	/* DSA port data, such as switch, port index, etc. */
+ 	struct dsa_port		*dp;
+ 
+-	/*
+-	 * The phylib phy_device pointer for the PHY connected
+-	 * to this port.
+-	 */
+-	struct phy_device	*phy;
+-	phy_interface_t		phy_interface;
+-	int			old_link;
+-	int			old_pause;
+-	int			old_duplex;
+-
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	struct netpoll		*netpoll;
+ #endif
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index 3460cba3d315..0c0e6ddef2e6 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -13,6 +13,7 @@
+ #include <linux/netdevice.h>
+ #include <linux/phy.h>
+ #include <linux/phy_fixed.h>
++#include <linux/phylink.h>
+ #include <linux/of_net.h>
+ #include <linux/of_mdio.h>
+ #include <linux/mdio.h>
+@@ -99,15 +100,14 @@ static int dsa_slave_open(struct net_device *dev)
+ 	}
+ 
+ 	if (ds->ops->port_enable) {
+-		err = ds->ops->port_enable(ds, p->dp->index, p->phy);
++		err = ds->ops->port_enable(ds, dp->index, dev->phydev);
+ 		if (err)
+ 			goto clear_promisc;
+ 	}
+ 
+ 	dsa_port_set_state_now(p->dp, stp_state);
+ 
+-	if (p->phy)
+-		phy_start(p->phy);
++	phylink_start(dp->pl);
+ 
+ 	return 0;
+ 
+@@ -130,8 +130,7 @@ static int dsa_slave_close(struct net_device *dev)
+ 	struct net_device *master = dsa_master_netdev(p);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (p->phy)
+-		phy_stop(p->phy);
++	phylink_stop(p->dp->pl);
+ 
+ 	dev_mc_unsync(master, dev);
+ 	dev_uc_unsync(master, dev);
+@@ -144,7 +143,7 @@ static int dsa_slave_close(struct net_device *dev)
+ 		dev_uc_del(master, dev->dev_addr);
+ 
+ 	if (ds->ops->port_disable)
+-		ds->ops->port_disable(ds, p->dp->index, p->phy);
++		ds->ops->port_disable(ds, p->dp->index, dev->phydev);
+ 
+ 	dsa_port_set_state_now(p->dp, BR_STATE_DISABLED);
+ 
+@@ -284,10 +283,7 @@ static int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return phy_mii_ioctl(p->phy, ifr, cmd);
+-
+-	return -EOPNOTSUPP;
++	return phylink_mii_ioctl(p->dp->pl, ifr, cmd);
+ }
+ 
+ static int dsa_slave_port_attr_set(struct net_device *dev,
+@@ -444,12 +440,7 @@ dsa_slave_get_link_ksettings(struct net_device *dev,
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (!p->phy)
+-		return -EOPNOTSUPP;
+-
+-	phy_ethtool_ksettings_get(p->phy, cmd);
+-
+-	return 0;
++	return phylink_ethtool_ksettings_get(p->dp->pl, cmd);
+ }
+ 
+ static int
+@@ -458,10 +449,7 @@ dsa_slave_set_link_ksettings(struct net_device *dev,
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return phy_ethtool_ksettings_set(p->phy, cmd);
+-
+-	return -EOPNOTSUPP;
++	return phylink_ethtool_ksettings_set(p->dp->pl, cmd);
+ }
+ 
+ static void dsa_slave_get_drvinfo(struct net_device *dev,
+@@ -497,10 +485,7 @@ static int dsa_slave_nway_reset(struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return genphy_restart_aneg(p->phy);
+-
+-	return -EOPNOTSUPP;
++	return phylink_ethtool_nway_reset(p->dp->pl);
+ }
+ 
+ static int dsa_slave_get_eeprom_len(struct net_device *dev)
+@@ -685,6 +670,8 @@ static void dsa_slave_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
++	phylink_ethtool_get_wol(p->dp->pl, w);
++
+ 	if (ds->ops->get_wol)
+ 		ds->ops->get_wol(ds, p->dp->index, w);
+ }
+@@ -695,6 +682,8 @@ static int dsa_slave_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)
+ 	struct dsa_switch *ds = p->dp->ds;
+ 	int ret = -EOPNOTSUPP;
+ 
++	phylink_ethtool_set_wol(p->dp->pl, w);
++
+ 	if (ds->ops->set_wol)
+ 		ret = ds->ops->set_wol(ds, p->dp->index, w);
+ 
+@@ -708,7 +697,7 @@ static int dsa_slave_set_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	int ret;
+ 
+ 	/* Port's PHY and MAC both need to be EEE capable */
+-	if (!p->phy)
++	if (!dev->phydev)
+ 		return -ENODEV;
+ 
+ 	if (!ds->ops->set_mac_eee)
+@@ -718,13 +707,7 @@ static int dsa_slave_set_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	if (ret)
+ 		return ret;
+ 
+-	if (e->eee_enabled) {
+-		ret = phy_init_eee(p->phy, 0);
+-		if (ret)
+-			return ret;
+-	}
+-
+-	return phy_ethtool_set_eee(p->phy, e);
++	return phylink_ethtool_set_eee(p->dp->pl, e);
+ }
+ 
+ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+@@ -734,7 +717,7 @@ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	int ret;
+ 
+ 	/* Port's PHY and MAC both need to be EEE capable */
+-	if (!p->phy)
++	if (!dev->phydev)
+ 		return -ENODEV;
+ 
+ 	if (!ds->ops->get_mac_eee)
+@@ -744,7 +727,7 @@ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	if (ret)
+ 		return ret;
+ 
+-	return phy_ethtool_get_eee(p->phy, e);
++	return phylink_ethtool_get_eee(p->dp->pl, e);
+ }
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+@@ -1054,152 +1037,156 @@ static struct device_type dsa_type = {
+ 	.name	= "dsa",
+ };
+ 
+-static void dsa_slave_adjust_link(struct net_device *dev)
++static void dsa_slave_phylink_validate(struct net_device *dev,
++				       unsigned long *supported,
++				       struct phylink_link_state *state)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+-	unsigned int status_changed = 0;
+ 
+-	if (p->old_link != p->phy->link) {
+-		status_changed = 1;
+-		p->old_link = p->phy->link;
+-	}
++	if (!ds->ops->phylink_validate)
++		return;
+ 
+-	if (p->old_duplex != p->phy->duplex) {
+-		status_changed = 1;
+-		p->old_duplex = p->phy->duplex;
+-	}
++	ds->ops->phylink_validate(ds, p->dp->index, supported, state);
++}
+ 
+-	if (p->old_pause != p->phy->pause) {
+-		status_changed = 1;
+-		p->old_pause = p->phy->pause;
+-	}
++static int dsa_slave_phylink_mac_link_state(struct net_device *dev,
++					    struct phylink_link_state *state)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (ds->ops->adjust_link && status_changed)
+-		ds->ops->adjust_link(ds, p->dp->index, p->phy);
++	/* Only called for SGMII and 802.3z */
++	if (!ds->ops->phylink_mac_link_state)
++		return -EOPNOTSUPP;
+ 
+-	if (status_changed)
+-		phy_print_status(p->phy);
++	return ds->ops->phylink_mac_link_state(ds, p->dp->index, state);
+ }
+ 
+-static int dsa_slave_fixed_link_update(struct net_device *dev,
+-				       struct fixed_phy_status *status)
++static void dsa_slave_phylink_mac_config(struct net_device *dev,
++					 unsigned int mode,
++					 const struct phylink_link_state *state)
+ {
+-	struct dsa_slave_priv *p;
+-	struct dsa_switch *ds;
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	if (!ds->ops->phylink_mac_config)
++		return;
++
++	ds->ops->phylink_mac_config(ds, p->dp->index, mode, state);
++}
++
++static void dsa_slave_phylink_mac_an_restart(struct net_device *dev)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (dev) {
+-		p = netdev_priv(dev);
+-		ds = p->dp->ds;
+-		if (ds->ops->fixed_link_update)
+-			ds->ops->fixed_link_update(ds, p->dp->index, status);
++	if (!ds->ops->phylink_mac_an_restart)
++		return;
++
++	ds->ops->phylink_mac_an_restart(ds, p->dp->index);
++}
++
++static void dsa_slave_phylink_mac_link_down(struct net_device *dev,
++					    unsigned int mode,
++					    phy_interface_t interface)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	if (!ds->ops->phylink_mac_link_down) {
++		if (ds->ops->adjust_link && dev->phydev)
++			ds->ops->adjust_link(ds, p->dp->index, dev->phydev);
++		return;
+ 	}
+ 
+-	return 0;
++	ds->ops->phylink_mac_link_down(ds, p->dp->index, mode, interface);
+ }
+ 
+-/* slave device setup *******************************************************/
+-static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
+-				 struct net_device *slave_dev,
+-				 int addr)
++static void dsa_slave_phylink_mac_link_up(struct net_device *dev,
++					  unsigned int mode,
++					  phy_interface_t interface,
++					  struct phy_device *phydev)
+ {
++	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
+-	p->phy = mdiobus_get_phy(ds->slave_mii_bus, addr);
+-	if (!p->phy) {
+-		netdev_err(slave_dev, "no phy at %d\n", addr);
+-		return -ENODEV;
++	if (!ds->ops->phylink_mac_link_up) {
++		if (ds->ops->adjust_link && dev->phydev)
++			ds->ops->adjust_link(ds, p->dp->index, dev->phydev);
++		return;
+ 	}
+ 
+-	/* Use already configured phy mode */
+-	if (p->phy_interface == PHY_INTERFACE_MODE_NA)
+-		p->phy_interface = p->phy->interface;
+-	return phy_connect_direct(slave_dev, p->phy, dsa_slave_adjust_link,
+-				  p->phy_interface);
++	ds->ops->phylink_mac_link_up(ds, p->dp->index, mode, interface, phydev);
+ }
+ 
++static const struct phylink_mac_ops dsa_slave_phylink_mac_ops = {
++	.validate = dsa_slave_phylink_validate,
++	.mac_link_state = dsa_slave_phylink_mac_link_state,
++	.mac_config = dsa_slave_phylink_mac_config,
++	.mac_an_restart = dsa_slave_phylink_mac_an_restart,
++	.mac_link_down = dsa_slave_phylink_mac_link_down,
++	.mac_link_up = dsa_slave_phylink_mac_link_up,
++};
++
+ void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up)
+ {
++	phylink_mac_change(ds->ports[port].pl, up);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_change);
+ 
+-static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
+-				struct net_device *slave_dev)
++/* slave device setup *******************************************************/
++static int dsa_slave_phy_connect(struct net_device *slave_dev, int addr)
+ {
++	struct dsa_slave_priv *p = netdev_priv(slave_dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	slave_dev->phydev = mdiobus_get_phy(ds->slave_mii_bus, addr);
++	if (!slave_dev->phydev) {
++		netdev_err(slave_dev, "no phy at %d\n", addr);
++		return -ENODEV;
++	}
++
++	return phylink_connect_phy(p->dp->pl, slave_dev->phydev);
++}
++
++static int dsa_slave_phy_setup(struct net_device *slave_dev)
++{
++	struct dsa_slave_priv *p = netdev_priv(slave_dev);
++	struct device_node *port_dn = p->dp->dn;
+ 	struct dsa_switch *ds = p->dp->ds;
+-	struct device_node *phy_dn, *port_dn;
+-	bool phy_is_fixed = false;
+ 	u32 phy_flags = 0;
+ 	int mode, ret;
+ 
+-	port_dn = p->dp->dn;
+ 	mode = of_get_phy_mode(port_dn);
+ 	if (mode < 0)
+ 		mode = PHY_INTERFACE_MODE_NA;
+-	p->phy_interface = mode;
+-
+-	phy_dn = of_parse_phandle(port_dn, "phy-handle", 0);
+-	if (!phy_dn && of_phy_is_fixed_link(port_dn)) {
+-		/* In the case of a fixed PHY, the DT node associated
+-		 * to the fixed PHY is the Port DT node
+-		 */
+-		ret = of_phy_register_fixed_link(port_dn);
+-		if (ret) {
+-			netdev_err(slave_dev, "failed to register fixed PHY: %d\n", ret);
+-			return ret;
+-		}
+-		phy_is_fixed = true;
+-		phy_dn = of_node_get(port_dn);
++	p->dp->pl = phylink_create(slave_dev, port_dn, mode,
++				   &dsa_slave_phylink_mac_ops);
++	if (IS_ERR(p->dp->pl)) {
++		netdev_err(slave_dev,
++			   "error creating PHYLINK: %ld\n", PTR_ERR(p->dp->pl));
++		return PTR_ERR(p->dp->pl);
+ 	}
+ 
+ 	if (ds->ops->get_phy_flags)
+ 		phy_flags = ds->ops->get_phy_flags(ds, p->dp->index);
+ 
+-	if (phy_dn) {
+-		int phy_id = of_mdio_parse_addr(&slave_dev->dev, phy_dn);
+-
+-		/* If this PHY address is part of phys_mii_mask, which means
+-		 * that we need to divert reads and writes to/from it, then we
+-		 * want to bind this device using the slave MII bus created by
+-		 * DSA to make that happen.
++	ret = phylink_of_phy_connect(p->dp->pl, port_dn, phy_flags);
++	if (ret == -ENODEV) {
++		/* We could not connect to a designated PHY or SFP, so use the
++		 * switch internal MDIO bus instead
+ 		 */
+-		if (!phy_is_fixed && phy_id >= 0 &&
+-		    (ds->phys_mii_mask & (1 << phy_id))) {
+-			ret = dsa_slave_phy_connect(p, slave_dev, phy_id);
+-			if (ret) {
+-				netdev_err(slave_dev, "failed to connect to phy%d: %d\n", phy_id, ret);
+-				of_node_put(phy_dn);
+-				return ret;
+-			}
+-		} else {
+-			p->phy = of_phy_connect(slave_dev, phy_dn,
+-						dsa_slave_adjust_link,
+-						phy_flags,
+-						p->phy_interface);
+-		}
+-
+-		of_node_put(phy_dn);
+-	}
+-
+-	if (p->phy && phy_is_fixed)
+-		fixed_phy_set_link_update(p->phy, dsa_slave_fixed_link_update);
+-
+-	/* We could not connect to a designated PHY, so use the switch internal
+-	 * MDIO bus instead
+-	 */
+-	if (!p->phy) {
+-		ret = dsa_slave_phy_connect(p, slave_dev, p->dp->index);
++		ret = dsa_slave_phy_connect(slave_dev, p->dp->index);
+ 		if (ret) {
+-			netdev_err(slave_dev, "failed to connect to port %d: %d\n",
++			netdev_err(slave_dev,
++				   "failed to connect to port %d: %d\n",
+ 				   p->dp->index, ret);
+-			if (phy_is_fixed)
+-				of_phy_deregister_fixed_link(port_dn);
++			phylink_destroy(p->dp->pl);
+ 			return ret;
+ 		}
+ 	}
+ 
+-	phy_attached_info(p->phy);
+-
+ 	return 0;
+ }
+ 
+@@ -1221,13 +1208,9 @@ int dsa_slave_suspend(struct net_device *slave_dev)
+ 
+ 	netif_device_detach(slave_dev);
+ 
+-	if (p->phy) {
+-		phy_stop(p->phy);
+-		p->old_pause = -1;
+-		p->old_link = -1;
+-		p->old_duplex = -1;
+-		phy_suspend(p->phy);
+-	}
++	rtnl_lock();
++	phylink_stop(p->dp->pl);
++	rtnl_unlock();
+ 
+ 	return 0;
+ }
+@@ -1241,10 +1224,9 @@ int dsa_slave_resume(struct net_device *slave_dev)
+ 
+ 	netif_device_attach(slave_dev);
+ 
+-	if (p->phy) {
+-		phy_resume(p->phy);
+-		phy_start(p->phy);
+-	}
++	rtnl_lock();
++	phylink_start(p->dp->pl);
++	rtnl_unlock();
+ 
+ 	return 0;
+ }
+@@ -1299,15 +1281,11 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ 	INIT_LIST_HEAD(&p->mall_tc_list);
+ 	p->xmit = dst->tag_ops->xmit;
+ 
+-	p->old_pause = -1;
+-	p->old_link = -1;
+-	p->old_duplex = -1;
+-
+ 	port->netdev = slave_dev;
+ 
+ 	netif_carrier_off(slave_dev);
+ 
+-	ret = dsa_slave_phy_setup(p, slave_dev);
++	ret = dsa_slave_phy_setup(slave_dev);
+ 	if (ret) {
+ 		netdev_err(master, "error %d setting up slave phy\n", ret);
+ 		goto out_free;
+@@ -1323,9 +1301,10 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ 	return 0;
+ 
+ out_phy:
+-	phy_disconnect(p->phy);
+-	if (of_phy_is_fixed_link(p->dp->dn))
+-		of_phy_deregister_fixed_link(p->dp->dn);
++	rtnl_lock();
++	phylink_disconnect_phy(p->dp->pl);
++	rtnl_unlock();
++	phylink_destroy(p->dp->pl);
+ out_free:
+ 	free_percpu(p->stats64);
+ 	free_netdev(slave_dev);
+@@ -1336,18 +1315,14 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ void dsa_slave_destroy(struct net_device *slave_dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(slave_dev);
+-	struct device_node *port_dn;
+-
+-	port_dn = p->dp->dn;
+ 
+ 	netif_carrier_off(slave_dev);
+-	if (p->phy) {
+-		phy_disconnect(p->phy);
++	rtnl_lock();
++	phylink_disconnect_phy(p->dp->pl);
++	rtnl_unlock();
+ 
+-		if (of_phy_is_fixed_link(port_dn))
+-			of_phy_deregister_fixed_link(port_dn);
+-	}
+ 	unregister_netdev(slave_dev);
++	phylink_destroy(p->dp->pl);
+ 	free_percpu(p->stats64);
+ 	free_netdev(slave_dev);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch b/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch
new file mode 100644
index 0000000..6de710f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch
@@ -0,0 +1,74 @@
+From 67902d64ac8b609286b084ae0d32219b95590464 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 15 Dec 2017 17:24:45 +0000
+Subject: [PATCH 083/127] phylink: add helper for configuring 2500BaseX modes
+
+Add a helper for MAC drivers to use in their validate callback to deal
+with 2500BaseX vs 1000BaseX modes, where the hardware supports both
+but it is not possible to automatically select between them.
+
+This helper defaults to 1000BaseX, as that is the 802.3 standard, and
+will allow users to select 2500BaseX either by forcing the speed if
+AN is disabled, or by changing the advertising mask if AN is enabled.
+Disabling AN is not recommended as it is only the speed that we're
+interested in controlling, not the duplex or pause mode parameters.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/phylink.c | 30 ++++++++++++++++++++++++++++++
+ include/linux/phylink.h   |  1 +
+ 2 files changed, 31 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 4b63bf9abb32..ab04fc084cb3 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1455,4 +1455,34 @@ static const struct sfp_upstream_ops sfp_phylink_ops = {
+ 	.disconnect_phy = phylink_sfp_disconnect_phy,
+ };
+ 
++/* Helpers for MAC drivers */
++
++/**
++ * phylink_helper_basex_speed() - 1000BaseX/2500BaseX helper
++ * @state: a pointer to a &struct phylink_link_state
++ *
++ * Inspect the interface mode, advertising mask or forced speed and
++ * decide whether to run at 2.5Gbit or 1Gbit appropriately, switching
++ * the interface mode to suit.  @state->interface is appropriately
++ * updated, and the advertising mask has the "other" baseX_Full flag
++ * cleared.
++ */
++void phylink_helper_basex_speed(struct phylink_link_state *state)
++{
++	if (phy_interface_mode_is_8023z(state->interface)) {
++		bool want_2500 = state->an_enabled ?
++			phylink_test(state->advertising, 2500baseX_Full) :
++			state->speed == SPEED_2500;
++
++		if (want_2500) {
++			phylink_clear(state->advertising, 1000baseX_Full);
++			state->interface = PHY_INTERFACE_MODE_2500BASEX;
++		} else {
++			phylink_clear(state->advertising, 2500baseX_Full);
++			state->interface = PHY_INTERFACE_MODE_1000BASEX;
++		}
++	}
++}
++EXPORT_SYMBOL_GPL(phylink_helper_basex_speed);
++
+ MODULE_LICENSE("GPL");
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index afb74404e8bf..cff779414883 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -143,5 +143,6 @@ int phylink_mii_ioctl(struct phylink *, struct ifreq *, int);
+ #define phylink_test(bm, mode)	__phylink_do_bit(test_bit, bm, mode)
+ 
+ void phylink_set_port_modes(unsigned long *bits);
++void phylink_helper_basex_speed(struct phylink_link_state *state);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch b/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch
new file mode 100644
index 0000000..7163c85
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch
@@ -0,0 +1,213 @@
+From 4527d32443e37c28e2055983f61d79311d4f49fd Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Thu, 10 May 2018 13:17:35 -0700
+Subject: [PATCH 084/127] net: dsa: mv88e6xxx: add PHYLINK support
+
+Add rudimentary phylink support to mv88e6xxx. This allows the driver
+using user ports with fixed links to keep operating normally. User ports
+with normal PHYs are not affected since the switch automatically manages
+their link parameters. User facing ports which use a SFP/SFF with a
+non-fixed link mode might require a call to phylink_mac_change() to
+operate properly.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[Andrew: fixed link setting after adding link polling]
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[florian: expand commit message]
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 83 ++++++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.c | 39 +++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.h |  3 ++
+ 3 files changed, 125 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 14ae3a68d3c6..53374a6f79cb 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -31,6 +31,7 @@
+ #include <linux/netdevice.h>
+ #include <linux/gpio/consumer.h>
+ #include <linux/phy.h>
++#include <linux/phylink.h>
+ #include <net/dsa.h>
+ 
+ #include "chip.h"
+@@ -532,6 +533,83 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
+ }
+ 
++static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
++			       unsigned long *supported,
++			       struct phylink_link_state *state)
++{
++}
++
++static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
++				struct phylink_link_state *state)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int err;
++
++	mutex_lock(&chip->reg_lock);
++	err = mv88e6xxx_port_link_state(chip, port, state);
++	mutex_unlock(&chip->reg_lock);
++
++	return err;
++}
++
++static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
++				 unsigned int mode,
++				 const struct phylink_link_state *state)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int speed, duplex, link, err;
++
++	if (mode == MLO_AN_PHY)
++		return;
++
++	if (mode == MLO_AN_FIXED) {
++		link = LINK_FORCED_UP;
++		speed = state->speed;
++		duplex = state->duplex;
++	} else {
++		speed = SPEED_UNFORCED;
++		duplex = DUPLEX_UNFORCED;
++		link = LINK_UNFORCED;
++	}
++
++	mutex_lock(&chip->reg_lock);
++	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex,
++				       state->interface);
++	mutex_unlock(&chip->reg_lock);
++
++	if (err && err != -EOPNOTSUPP)
++		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
++}
++
++static void mv88e6xxx_mac_link_force(struct dsa_switch *ds, int port, int link)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int err;
++
++	mutex_lock(&chip->reg_lock);
++	err = chip->info->ops->port_set_link(chip, port, link);
++	mutex_unlock(&chip->reg_lock);
++
++	if (err)
++		dev_err(chip->dev, "p%d: failed to force MAC link\n", port);
++}
++
++static void mv88e6xxx_mac_link_down(struct dsa_switch *ds, int port,
++				    unsigned int mode,
++				    phy_interface_t interface)
++{
++	if (mode == MLO_AN_FIXED)
++		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_DOWN);
++}
++
++static void mv88e6xxx_mac_link_up(struct dsa_switch *ds, int port,
++				  unsigned int mode, phy_interface_t interface,
++				  struct phy_device *phydev)
++{
++	if (mode == MLO_AN_FIXED)
++		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_UP);
++}
++
+ static int mv88e6xxx_stats_snapshot(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	if (!chip->info->ops->stats_snapshot)
+@@ -3918,6 +3996,11 @@ static const struct dsa_switch_ops mv88e6xxx_switch_ops = {
+ 	.setup			= mv88e6xxx_setup,
+ 	.set_addr		= mv88e6xxx_set_addr,
+ 	.adjust_link		= mv88e6xxx_adjust_link,
++	.phylink_validate	= mv88e6xxx_validate,
++	.phylink_mac_link_state	= mv88e6xxx_link_state,
++	.phylink_mac_config	= mv88e6xxx_mac_config,
++	.phylink_mac_link_down	= mv88e6xxx_mac_link_down,
++	.phylink_mac_link_up	= mv88e6xxx_mac_link_up,
+ 	.get_strings		= mv88e6xxx_get_strings,
+ 	.get_ethtool_stats	= mv88e6xxx_get_ethtool_stats,
+ 	.get_sset_count		= mv88e6xxx_get_sset_count,
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 2cffecfe86e3..c5248b30186b 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -15,6 +15,7 @@
+ #include <linux/bitfield.h>
+ #include <linux/if_bridge.h>
+ #include <linux/phy.h>
++#include <linux/phylink.h>
+ 
+ #include "chip.h"
+ #include "port.h"
+@@ -377,6 +378,44 @@ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ 	return 0;
+ }
+ 
++int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state)
++{
++	int err;
++	u16 reg;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	switch (reg & MV88E6XXX_PORT_STS_SPEED_MASK) {
++	case MV88E6XXX_PORT_STS_SPEED_10:
++		state->speed = SPEED_10;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_100:
++		state->speed = SPEED_100;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_1000:
++		state->speed = SPEED_1000;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_10000:
++		if ((reg &MV88E6XXX_PORT_STS_CMODE_MASK) ==
++		    MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			state->speed = SPEED_2500;
++		else
++			state->speed = SPEED_10000;
++		break;
++	}
++
++	state->duplex = reg & MV88E6XXX_PORT_STS_DUPLEX ?
++			DUPLEX_FULL : DUPLEX_HALF;
++	state->link = !!(reg & MV88E6XXX_PORT_STS_LINK);
++	state->an_enabled = 1;
++	state->an_complete = state->link;
++
++	return 0;
++}
++
+ /* Offset 0x02: Jamming Control
+  *
+  * Do not limit the period of time that this port can be paused for by
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index ccdc67fe9079..7dbfa44814a7 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -29,6 +29,7 @@
+ #define MV88E6XXX_PORT_STS_SPEED_10		0x0000
+ #define MV88E6XXX_PORT_STS_SPEED_100		0x0100
+ #define MV88E6XXX_PORT_STS_SPEED_1000		0x0200
++#define MV88E6XXX_PORT_STS_SPEED_10000		0x0300
+ #define MV88E6352_PORT_STS_EEE			0x0040
+ #define MV88E6165_PORT_STS_AM_DIS		0x0040
+ #define MV88E6185_PORT_STS_MGMII		0x0040
+@@ -305,6 +306,8 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state);
+ int mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6095_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,
+ 				     int upstream_port);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch b/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch
new file mode 100644
index 0000000..abd71d1
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch
@@ -0,0 +1,171 @@
+From b6bd83fc50c6c7587d76c748a1e5728663a1307f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:37 +0200
+Subject: [PATCH 085/127] net: dsa: mv88e6xxx: Add support to enabling pause
+
+The 6185 can enable/disable 802.3z pause be setting the MyPause bit in
+the port status register. Add an op to support this.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 20 ++++++++++++++++----
+ drivers/net/dsa/mv88e6xxx/chip.h |  7 +++++++
+ drivers/net/dsa/mv88e6xxx/port.c | 23 +++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.h |  2 ++
+ 4 files changed, 48 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 53374a6f79cb..323942f5257d 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -466,7 +466,7 @@ int mv88e6xxx_update(struct mv88e6xxx_chip *chip, int addr, int reg, u16 update)
+ }
+ 
+ static int mv88e6xxx_port_setup_mac(struct mv88e6xxx_chip *chip, int port,
+-				    int link, int speed, int duplex,
++				    int link, int speed, int duplex, int pause,
+ 				    phy_interface_t mode)
+ {
+ 	int err;
+@@ -485,6 +485,12 @@ static int mv88e6xxx_port_setup_mac(struct mv88e6xxx_chip *chip, int port,
+ 			goto restore_link;
+ 	}
+ 
++	if (chip->info->ops->port_set_pause) {
++		err = chip->info->ops->port_set_pause(chip, port, pause);
++		if (err)
++			goto restore_link;
++	}
++
+ 	if (chip->info->ops->port_set_duplex) {
+ 		err = chip->info->ops->port_set_duplex(chip, port, duplex);
+ 		if (err && err != -EOPNOTSUPP)
+@@ -526,7 +532,8 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 
+ 	mutex_lock(&chip->reg_lock);
+ 	err = mv88e6xxx_port_setup_mac(chip, port, phydev->link, phydev->speed,
+-				       phydev->duplex, phydev->interface);
++				       phydev->duplex, phydev->pause,
++				       phydev->interface);
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	if (err && err != -EOPNOTSUPP)
+@@ -557,7 +564,7 @@ static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
+ 				 const struct phylink_link_state *state)
+ {
+ 	struct mv88e6xxx_chip *chip = ds->priv;
+-	int speed, duplex, link, err;
++	int speed, duplex, link, pause, err;
+ 
+ 	if (mode == MLO_AN_PHY)
+ 		return;
+@@ -571,9 +578,10 @@ static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
+ 		duplex = DUPLEX_UNFORCED;
+ 		link = LINK_UNFORCED;
+ 	}
++	pause = !!phylink_test(state->advertising, Pause);
+ 
+ 	mutex_lock(&chip->reg_lock);
+-	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex,
++	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex, pause,
+ 				       state->interface);
+ 	mutex_unlock(&chip->reg_lock);
+ 
+@@ -1811,10 +1819,12 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ 	if (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))
+ 		err = mv88e6xxx_port_setup_mac(chip, port, LINK_FORCED_UP,
+ 					       SPEED_MAX, DUPLEX_FULL,
++					       PAUSE_OFF,
+ 					       PHY_INTERFACE_MODE_NA);
+ 	else
+ 		err = mv88e6xxx_port_setup_mac(chip, port, LINK_UNFORCED,
+ 					       SPEED_UNFORCED, DUPLEX_UNFORCED,
++					       PAUSE_ON,
+ 					       PHY_INTERFACE_MODE_NA);
+ 	if (err)
+ 		return err;
+@@ -2579,6 +2589,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,
+ 	.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
++	.port_set_pause = mv88e6185_port_set_pause,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2836,6 +2847,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
++	.port_set_pause = mv88e6185_port_set_pause,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 0913eeca53b3..439cae17095b 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -279,6 +279,13 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_duplex)(struct mv88e6xxx_chip *chip, int port, int dup);
+ 
++#define PAUSE_ON		1
++#define PAUSE_OFF		0
++
++	/* Enable/disable sending Pause */
++	int (*port_set_pause)(struct mv88e6xxx_chip *chip, int port,
++			      int pause);
++
+ #define SPEED_MAX		INT_MAX
+ #define SPEED_UNFORCED		-2
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index c5248b30186b..c72eec63e8f6 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -36,6 +36,29 @@ int mv88e6xxx_port_write(struct mv88e6xxx_chip *chip, int port, int reg,
+ 	return mv88e6xxx_write(chip, addr, reg, val);
+ }
+ 
++/* Offset 0x00: MAC (or PCS or Physical) Status Register
++ *
++ * For most devices, this is read only. However the 6185 has the MyPause
++ * bit read/write.
++ */
++int mv88e6185_port_set_pause(struct mv88e6xxx_chip *chip, int port,
++			     int pause)
++{
++	u16 reg;
++	int err;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	if (pause)
++		reg |= MV88E6XXX_PORT_STS_MY_PAUSE;
++	else
++		reg &= ~MV88E6XXX_PORT_STS_MY_PAUSE;
++
++	return mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);
++}
++
+ /* Offset 0x01: MAC (or PCS or Physical) Control Register
+  *
+  * Link, Duplex and Flow Control have one force bit, one value bit.
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index 7dbfa44814a7..c2fce7c1cb37 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -252,6 +252,8 @@ int mv88e6xxx_port_read(struct mv88e6xxx_chip *chip, int port, int reg,
+ int mv88e6xxx_port_write(struct mv88e6xxx_chip *chip, int port, int reg,
+ 			 u16 val);
+ 
++int mv88e6185_port_set_pause(struct mv88e6xxx_chip *chip, int port,
++			     int pause);
+ int mv88e6352_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,
+ 				   phy_interface_t mode);
+ int mv88e6390_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch b/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch
new file mode 100644
index 0000000..c0cfd91
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch
@@ -0,0 +1,705 @@
+From 9861270c061bd1893bcdb0aa92c85a9871f2c758 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Thu, 9 Aug 2018 15:38:39 +0200
+Subject: [PATCH 086/127] net: dsa: mv88e6xxx: add phylink support
+
+Add rudimentary phylink support to mv88e6xxx.
+
+TODO:
+- needs to call phylink_mac_change() when the port link comes up/goes down.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 139 ++++++++++++++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/chip.h |   8 ++
+ drivers/net/dsa/mv88e6xxx/port.c |  56 ++++++++++++-
+ drivers/net/dsa/mv88e6xxx/port.h |  18 +++-
+ 4 files changed, 217 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 323942f5257d..f83c1cb44a80 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -540,10 +540,92 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
+ }
+ 
++static void mv88e6065_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	if (!phy_interface_mode_is_8023z(state->interface)) {
++		/* 10M and 100M are only supported in non-802.3z mode */
++		phylink_set(mask, 10baseT_Half);
++		phylink_set(mask, 10baseT_Full);
++		phylink_set(mask, 100baseT_Half);
++		phylink_set(mask, 100baseT_Full);
++	}
++}
++
++static void mv88e6185_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	/* FIXME: if the port is in 1000Base-X mode, then it only supports
++	 * 1000M FD speeds.  In this case, CMODE will indicate 5.
++	 */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6352_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	/* No ethtool bits for 200Mbps */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6390_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	if (port >= 9)
++		phylink_set(mask, 2500baseX_Full);
++
++	/* No ethtool bits for 200Mbps */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6390x_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++					unsigned long *mask,
++					struct phylink_link_state *state)
++{
++	if (port >= 9) {
++		phylink_set(mask, 10000baseT_Full);
++		phylink_set(mask, 10000baseKR_Full);
++	}
++
++	mv88e6390_phylink_validate(chip, port, mask, state);
++}
++
+ static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
+ 			       unsigned long *supported,
+ 			       struct phylink_link_state *state)
+ {
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
++	struct mv88e6xxx_chip *chip = ds->priv;
++
++	/* Allow all the expected bits */
++	phylink_set(mask, Autoneg);
++	phylink_set(mask, Pause);
++	phylink_set_port_modes(mask);
++
++	if (chip->info->ops->phylink_validate)
++		chip->info->ops->phylink_validate(chip, port, mask, state);
++
++	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	bitmap_and(state->advertising, state->advertising, mask,
++		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++
++	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
++	 * to advertise both, only report advertising at 2500BaseX.
++	 */
++	phylink_helper_basex_speed(state);
+ }
+ 
+ static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
+@@ -553,7 +635,10 @@ static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
+ 	int err;
+ 
+ 	mutex_lock(&chip->reg_lock);
+-	err = mv88e6xxx_port_link_state(chip, port, state);
++	if (chip->info->ops->port_link_state)
++		err = chip->info->ops->port_link_state(chip, port, state);
++	else
++		err = -EOPNOTSUPP;
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	return err;
+@@ -2475,6 +2560,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2489,6 +2575,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6095_ops = {
+@@ -2502,6 +2589,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.port_set_frame_mode = mv88e6085_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
++	.port_link_state = mv88e6185_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2512,6 +2600,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6097_ops = {
+@@ -2532,6 +2621,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2544,6 +2634,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6123_ops = {
+@@ -2559,6 +2650,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2571,6 +2663,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6131_ops = {
+@@ -2590,6 +2683,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_set_pause = mv88e6185_port_set_pause,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2603,6 +2697,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6141_ops = {
+@@ -2626,6 +2721,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -2638,6 +2734,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6161_ops = {
+@@ -2658,6 +2755,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2670,6 +2768,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6165_ops = {
+@@ -2683,6 +2782,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.port_set_speed = mv88e6185_port_set_speed,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2695,6 +2795,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6171_ops = {
+@@ -2716,6 +2817,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2728,6 +2830,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6172_ops = {
+@@ -2751,6 +2854,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2764,6 +2868,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6175_ops = {
+@@ -2785,6 +2890,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2797,6 +2903,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6176_ops = {
+@@ -2820,6 +2927,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2833,6 +2941,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6185_ops = {
+@@ -2848,6 +2957,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_set_pause = mv88e6185_port_set_pause,
++	.port_link_state = mv88e6185_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2861,6 +2971,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6190_ops = {
+@@ -2883,6 +2994,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2897,6 +3009,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+@@ -2919,6 +3032,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2933,6 +3047,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6191_ops = {
+@@ -2955,6 +3070,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2969,6 +3085,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6240_ops = {
+@@ -2992,6 +3109,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3005,6 +3123,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6290_ops = {
+@@ -3028,6 +3147,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3042,6 +3162,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6320_ops = {
+@@ -3064,6 +3185,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3075,6 +3197,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6321_ops = {
+@@ -3097,6 +3220,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3106,6 +3230,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6341_ops = {
+@@ -3129,6 +3254,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3141,6 +3267,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6350_ops = {
+@@ -3162,6 +3289,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3174,6 +3302,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6351_ops = {
+@@ -3195,6 +3324,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3207,6 +3337,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6352_ops = {
+@@ -3230,6 +3361,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3243,6 +3375,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6390_ops = {
+@@ -3268,6 +3401,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3282,6 +3416,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+@@ -3307,6 +3442,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3321,6 +3457,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 439cae17095b..f6053799aa5a 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -324,6 +324,9 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_upstream_port)(struct mv88e6xxx_chip *chip, int port,
+ 				      int upstream_port);
++	/* Return the port link state, as required by phylink */
++	int (*port_link_state)(struct mv88e6xxx_chip *chip, int port,
++			       struct phylink_link_state *state);
+ 
+ 	/* Snapshot the statistics for a port. The statistics can then
+ 	 * be read back a leisure but still with a consistent view.
+@@ -354,6 +357,11 @@ struct mv88e6xxx_ops {
+ 			   struct mv88e6xxx_vtu_entry *entry);
+ 	int (*vtu_loadpurge)(struct mv88e6xxx_chip *chip,
+ 			     struct mv88e6xxx_vtu_entry *entry);
++
++	/* Phylink */
++	void (*phylink_validate)(struct mv88e6xxx_chip *chip, int port,
++				 unsigned long *mask,
++				 struct phylink_link_state *state);
+ };
+ 
+ struct mv88e6xxx_irq_ops {
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index c72eec63e8f6..62f39603920f 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -387,6 +387,19 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 	return 0;
+ }
+ 
++/* mv88e6185 only has 3 bits for CMODE */
++static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
++{
++	int err;
++	u16 reg;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	return reg & MV88E6185_PORT_STS_CMODE_MASK;
++}
++
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+@@ -401,7 +414,7 @@ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ 	return 0;
+ }
+ 
+-int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state)
+ {
+ 	int err;
+@@ -422,7 +435,7 @@ int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 		state->speed = SPEED_1000;
+ 		break;
+ 	case MV88E6XXX_PORT_STS_SPEED_10000:
+-		if ((reg &MV88E6XXX_PORT_STS_CMODE_MASK) ==
++		if ((reg & MV88E6XXX_PORT_STS_CMODE_MASK) ==
+ 		    MV88E6XXX_PORT_STS_CMODE_2500BASEX)
+ 			state->speed = SPEED_2500;
+ 		else
+@@ -439,6 +452,45 @@ int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 	return 0;
+ }
+ 
++int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state)
++{
++	if (state->interface == PHY_INTERFACE_MODE_1000BASEX) {
++		int cmode = mv88e6185_port_get_cmode(chip, port);
++
++		if (cmode < 0)
++			return cmode;
++
++		/* When a port is in "Cross-chip serdes" mode, it uses
++		 * 1000Base-X full duplex mode, but there is no automatic
++		 * link detection. Use the sync OK status for link (as it
++		 * would do for 1000Base-X mode.)
++		 */
++		if (cmode == MV88E6185_PORT_STS_CMODE_SERDES) {
++			u16 mac;
++			int err;
++
++			err = mv88e6xxx_port_read(chip, port,
++						  MV88E6XXX_PORT_MAC_CTL, &mac);
++			if (err)
++				return err;
++
++			state->link = !!(mac & MV88E6185_PORT_MAC_CTL_SYNC_OK);
++			state->an_enabled = 1;
++			state->an_complete =
++				!!(mac & MV88E6185_PORT_MAC_CTL_AN_DONE);
++			state->duplex =
++				state->link ? DUPLEX_FULL : DUPLEX_UNKNOWN;
++			state->speed =
++				state->link ? SPEED_1000 : SPEED_UNKNOWN;
++
++			return 0;
++		}
++	}
++
++	return mv88e6352_port_link_state(chip, port, state);
++}
++
+ /* Offset 0x02: Jamming Control
+  *
+  * Do not limit the period of time that this port can be paused for by
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index c2fce7c1cb37..7dd0c6e1991b 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -42,14 +42,28 @@
+ #define MV88E6XXX_PORT_STS_CMODE_2500BASEX	0x000b
+ #define MV88E6XXX_PORT_STS_CMODE_XAUI		0x000c
+ #define MV88E6XXX_PORT_STS_CMODE_RXAUI		0x000d
++#define MV88E6185_PORT_STS_CDUPLEX		0x0008
++#define MV88E6185_PORT_STS_CMODE_MASK		0x0007
++#define MV88E6185_PORT_STS_CMODE_GMII_FD	0x0000
++#define MV88E6185_PORT_STS_CMODE_MII_100_FD_PS	0x0001
++#define MV88E6185_PORT_STS_CMODE_MII_100	0x0002
++#define MV88E6185_PORT_STS_CMODE_MII_10		0x0003
++#define MV88E6185_PORT_STS_CMODE_SERDES		0x0004
++#define MV88E6185_PORT_STS_CMODE_1000BASE_X	0x0005
++#define MV88E6185_PORT_STS_CMODE_PHY		0x0006
++#define MV88E6185_PORT_STS_CMODE_DISABLED	0x0007
+ 
+ /* Offset 0x01: MAC (or PCS or Physical) Control Register */
+ #define MV88E6XXX_PORT_MAC_CTL				0x01
+ #define MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK	0x8000
+ #define MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK	0x4000
++#define MV88E6185_PORT_MAC_CTL_SYNC_OK			0x4000
+ #define MV88E6390_PORT_MAC_CTL_FORCE_SPEED		0x2000
+ #define MV88E6390_PORT_MAC_CTL_ALTSPEED			0x1000
+ #define MV88E6352_PORT_MAC_CTL_200BASE			0x1000
++#define MV88E6185_PORT_MAC_CTL_AN_EN			0x0400
++#define MV88E6185_PORT_MAC_CTL_AN_RESTART		0x0200
++#define MV88E6185_PORT_MAC_CTL_AN_DONE			0x0100
+ #define MV88E6XXX_PORT_MAC_CTL_FC			0x0080
+ #define MV88E6XXX_PORT_MAC_CTL_FORCE_FC			0x0040
+ #define MV88E6XXX_PORT_MAC_CTL_LINK_UP			0x0020
+@@ -308,7 +322,9 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+-int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state);
++int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state);
+ int mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6095_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch b/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch
new file mode 100644
index 0000000..1d44eb3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch
@@ -0,0 +1,284 @@
+From d3a4ff01fb15fc08c3edbf9d3baf457af47d4403 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:40 +0200
+Subject: [PATCH 087/127] net: dsa: mv88e6xxx: Refactor SERDES lane code
+
+The 6390 family has 8 SERDES lanes. What ports use these lanes depends
+on how ports 9 and 10 are configured. If 9 and 10 does not make use of
+a line, one of the lower ports can use it.
+
+Add a function to return the lane a port is using, if any, and simplify
+the code to power up/down the lane.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 195 +++++++++++++++++------------
+ 1 file changed, 114 insertions(+), 81 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index f3c01119b3d1..c467adb874a6 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -75,8 +75,97 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++/* Return the SERDES lane address a port is using. Ports 9 and 10 can
++ * use multiple lanes. If so, return the first lane the port uses.
++ * Returns -ENODEV if a port does not have a lane.
++ */
++static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++{
++	u8 cmode_port9, cmode_port10, cmode_port;
++	int err;
++
++	err = mv88e6xxx_port_get_cmode(chip, 9, &cmode_port9);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_get_cmode(chip, 10, &cmode_port10);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode_port);
++	if (err)
++		return err;
++
++	switch (port) {
++	case 2:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE1;
++		return -ENODEV;
++	case 3:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE2;
++		return -ENODEV;
++	case 4:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE3;
++		return -ENODEV;
++	case 5:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE1;
++		return -ENODEV;
++	case 6:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE2;
++		return -ENODEV;
++	case 7:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE3;
++		return -ENODEV;
++	case 9:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_XAUI ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			return MV88E6390_PORT9_LANE0;
++		return -ENODEV;
++	case 10:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_XAUI ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			return MV88E6390_PORT10_LANE0;
++		return -ENODEV;
++	default:
++		return -ENODEV;
++	}
++}
++
+ /* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
++static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -84,7 +173,7 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
+ 
+ 	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+ 		MV88E6390_PCS_CONTROL_1;
+-	err = mv88e6xxx_phy_read(chip, addr, reg_c45, &val);
++	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -96,13 +185,13 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
+ 		new_val = val | MV88E6390_PCS_CONTROL_1_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, addr, reg_c45, new_val);
++		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
+ 
+ 	return err;
+ }
+ 
+-/* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
++/* Set the power on/off for SGMII and 1000Base-X */
++static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 				  bool on)
+ {
+ 	u16 val, new_val;
+@@ -111,7 +200,7 @@ static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
+ 
+ 	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+ 		MV88E6390_SGMII_CONTROL;
+-	err = mv88e6xxx_phy_read(chip, addr, reg_c45, &val);
++	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -123,63 +212,29 @@ static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
+ 		new_val = val | MV88E6390_SGMII_CONTROL_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, addr, reg_c45, new_val);
++		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
+ 
+ 	return err;
+ }
+ 
+-static int mv88e6390_serdes_lower(struct mv88e6xxx_chip *chip, u8 cmode,
+-				  int port_donor, int lane, bool rxaui, bool on)
++static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
++				       int lane, bool on)
+ {
++	u8 cmode;
+ 	int err;
+-	u8 cmode_donor;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port_donor, &cmode_donor);
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+ 	if (err)
+ 		return err;
+ 
+-	switch (cmode_donor) {
+-	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-		if (!rxaui)
+-			break;
+-		/* Fall through */
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
+-		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII)
+-			return	mv88e6390_serdes_sgmii(chip, lane, on);
+-	}
+-	return 0;
+-}
+-
+-static int mv88e6390_serdes_port9(struct mv88e6xxx_chip *chip, u8 cmode,
+-				  bool on)
+-{
+-	switch (cmode) {
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-		return mv88e6390_serdes_sgmii(chip, MV88E6390_PORT9_LANE0, on);
+-	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, MV88E6390_PORT9_LANE0, on);
+-	}
+-
+-	return 0;
+-}
+-
+-static int mv88e6390_serdes_port10(struct mv88e6xxx_chip *chip, u8 cmode,
+-				   bool on)
+-{
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-		return mv88e6390_serdes_sgmii(chip, MV88E6390_PORT10_LANE0, on);
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++		return mv88e6390_serdes_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+ 	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, MV88E6390_PORT10_LANE0, on);
++		return mv88e6390_serdes_10g(chip, lane, on);
+ 	}
+ 
+ 	return 0;
+@@ -187,42 +242,20 @@ static int mv88e6390_serdes_port10(struct mv88e6xxx_chip *chip, u8 cmode,
+ 
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+-	u8 cmode;
+-	int err;
++	int lane;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	lane = mv88e6390_serdes_get_lane(chip, port);
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
+ 
+ 	switch (port) {
+-	case 2:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE1,
+-					      false, on);
+-	case 3:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE2,
+-					      true, on);
+-	case 4:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE3,
+-					      true, on);
+-	case 5:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE1,
+-					      false, on);
+-	case 6:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE2,
+-					      true, on);
+-	case 7:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE3,
+-					      true, on);
+-	case 9:
+-		return mv88e6390_serdes_port9(chip, cmode, on);
+-	case 10:
+-		return mv88e6390_serdes_port10(chip, cmode, on);
++	case 2 ... 4:
++	case 5 ... 7:
++	case 9 ... 10:
++		return mv88e6390_serdes_power_lane(chip, port, lane, on);
+ 	}
+ 
+ 	return 0;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch b/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch
new file mode 100644
index 0000000..fd3d664
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch
@@ -0,0 +1,126 @@
+From d2e12da262c207b5abe8278248aff3d3fc5e1bb3 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:41 +0200
+Subject: [PATCH 088/127] net: dsa: mv88e6xxx: 6390 vs 6390X SERDES support
+
+The 6390 has two SERDES interfaces, used by ports 9 and 10.  The 6390X
+has eight SERDES interfaces. These allow ports 9 and 10 to do 10G. Or
+if lower speeds are used, some of the SERDES interfaces can be used by
+ports 2-8 for 1000Base-X.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  4 +--
+ drivers/net/dsa/mv88e6xxx/serdes.c | 51 +++++++++++++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/serdes.h |  1 +
+ 3 files changed, 53 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index f83c1cb44a80..4ca6728123ff 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3046,7 +3046,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+-	.serdes_power = mv88e6390_serdes_power,
++	.serdes_power = mv88e6390x_serdes_power,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+@@ -3456,7 +3456,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+-	.serdes_power = mv88e6390_serdes_power,
++	.serdes_power = mv88e6390x_serdes_power,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index c467adb874a6..8728c14b9ab5 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -75,11 +75,41 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++/* Return the SERDES lane address a port is using. Only Ports 9 and 10
++ * have SERDES lanes. Returns -ENODEV if a port does not have a lane.
++ */
++static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++{
++	u8 cmode;
++	int err;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	switch (port) {
++	case 9:
++		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			return MV88E6390_PORT9_LANE0;
++		return -ENODEV;
++	case 10:
++		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			return MV88E6390_PORT10_LANE0;
++		return -ENODEV;
++	default:
++		return -ENODEV;
++	}
++}
++
+ /* Return the SERDES lane address a port is using. Ports 9 and 10 can
+  * use multiple lanes. If so, return the first lane the port uses.
+  * Returns -ENODEV if a port does not have a lane.
+  */
+-static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+ 	int err;
+@@ -251,6 +281,25 @@ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	if (lane < 0)
+ 		return lane;
+ 
++	switch (port) {
++	case 9 ... 10:
++		return mv88e6390_serdes_power_lane(chip, port, lane, on);
++	}
++
++	return 0;
++}
++
++int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int lane;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
++
+ 	switch (port) {
+ 	case 2 ... 4:
+ 	case 5 ... 7:
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 5c1cd6d8e9a5..24bbe848a434 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -44,5 +44,6 @@
+ 
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
++int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch b/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
new file mode 100644
index 0000000..82e2ae6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
@@ -0,0 +1,87 @@
+From 40d97086cccb0cbc9e83deaadcfd4124eb39b11a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 16:23:53 +0200
+Subject: [PATCH 089/127] net: dsa: mv88e6xxx: 88E6141/6341 SERDES support
+
+The 88E6141/6341 switches (also known as Topaz) have 1 SGMII lane,
+which can be configured the same way as the SERDES lane on 88E6390.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  2 ++
+ drivers/net/dsa/mv88e6xxx/serdes.c | 20 ++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  3 +++
+ 3 files changed, 25 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 4ca6728123ff..f95495a8dc66 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2734,6 +2734,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3267,6 +3268,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 8728c14b9ab5..591703f182dd 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -309,3 +309,23 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ 	return 0;
+ }
++
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int err;
++	u8 cmode;
++
++	if (port != 5)
++		return 0;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
++		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++
++	return 0;
++}
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 24bbe848a434..73781b627564 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -19,6 +19,8 @@
+ #define MV88E6352_ADDR_SERDES		0x0f
+ #define MV88E6352_SERDES_PAGE_FIBER	0x01
+ 
++#define MV88E6341_ADDR_SERDES		0x15
++
+ #define MV88E6390_PORT9_LANE0		0x09
+ #define MV88E6390_PORT9_LANE1		0x12
+ #define MV88E6390_PORT9_LANE2		0x13
+@@ -42,6 +44,7 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch b/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch
new file mode 100644
index 0000000..06e34f5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch
@@ -0,0 +1,65 @@
+From 76afb16c9d4b48d057ff68984fac766a95f874b0 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:42 +0200
+Subject: [PATCH 090/127] net: dsa: mv88e6xxx: Rename sgmii/10g power functions
+
+There is a need to add more functions manipulating the SERDES
+interfaces. Cleanup the namespace.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 591703f182dd..8886ee41c7f4 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -195,7 +195,8 @@ static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ }
+ 
+ /* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
++static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
++				      bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -221,8 +222,8 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
+ }
+ 
+ /* Set the power on/off for SGMII and 1000Base-X */
+-static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int lane,
+-				  bool on)
++static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
++					bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -260,11 +261,11 @@ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+ 	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-		return mv88e6390_serdes_sgmii(chip, lane, on);
++		return mv88e6390_serdes_power_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, lane, on);
++		return mv88e6390_serdes_power_10g(chip, lane, on);
+ 	}
+ 
+ 	return 0;
+@@ -325,7 +326,8 @@ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
+-		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++		return mv88e6390_serdes_power_sgmii(chip, MV88E6341_ADDR_SERDES,
++						    on);
+ 
+ 	return 0;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch b/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch
new file mode 100644
index 0000000..515b5c6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch
@@ -0,0 +1,107 @@
+From 48e064e620263fabba4ed31509386b60073d5a7d Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:43 +0200
+Subject: [PATCH 091/127] net: dsa: mv88e6xxx: Add serdes register read/write
+ helper
+
+Add a helper for accessing SERDES registers of the 6390 family.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 35 +++++++++++++++++++++---------
+ drivers/net/dsa/mv88e6xxx/serdes.h |  1 -
+ 2 files changed, 25 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 8886ee41c7f4..e8ce757c6ae0 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -35,6 +35,22 @@ static int mv88e6352_serdes_write(struct mv88e6xxx_chip *chip, int reg,
+ 					reg, val);
+ }
+ 
++static int mv88e6390_serdes_read(struct mv88e6xxx_chip *chip,
++				 int lane, int device, int reg, u16 *val)
++{
++	int reg_c45 = MII_ADDR_C45 | device << 16 | reg;
++
++	return mv88e6xxx_phy_read(chip, lane, reg_c45, val);
++}
++
++static int mv88e6390_serdes_write(struct mv88e6xxx_chip *chip,
++				  int lane, int device, int reg, u16 val)
++{
++	int reg_c45 = MII_ADDR_C45 | device << 16 | reg;
++
++	return mv88e6xxx_phy_write(chip, lane, reg_c45, val);
++}
++
+ static int mv88e6352_serdes_power_set(struct mv88e6xxx_chip *chip, bool on)
+ {
+ 	u16 val, new_val;
+@@ -199,12 +215,11 @@ static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
+ 				      bool on)
+ {
+ 	u16 val, new_val;
+-	int reg_c45;
+ 	int err;
+ 
+-	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+-		MV88E6390_PCS_CONTROL_1;
+-	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_PCS_CONTROL_1, &val);
++
+ 	if (err)
+ 		return err;
+ 
+@@ -216,7 +231,8 @@ static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
+ 		new_val = val | MV88E6390_PCS_CONTROL_1_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
++		err = mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++					     MV88E6390_PCS_CONTROL_1, new_val);
+ 
+ 	return err;
+ }
+@@ -226,12 +242,10 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 					bool on)
+ {
+ 	u16 val, new_val;
+-	int reg_c45;
+ 	int err;
+ 
+-	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+-		MV88E6390_SGMII_CONTROL;
+-	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_SGMII_CONTROL, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -243,7 +257,8 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 		new_val = val | MV88E6390_SGMII_CONTROL_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
++		err = mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++					     MV88E6390_SGMII_CONTROL, new_val);
+ 
+ 	return err;
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 73781b627564..aa156d2a4004 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -29,7 +29,6 @@
+ #define MV88E6390_PORT10_LANE1		0x15
+ #define MV88E6390_PORT10_LANE2		0x16
+ #define MV88E6390_PORT10_LANE3		0x17
+-#define MV88E6390_SERDES_DEVICE		(4 << 16)
+ 
+ /* 10GBASE-R and 10GBASE-X4/X2 */
+ #define MV88E6390_PCS_CONTROL_1		0x1000
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch b/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch
new file mode 100644
index 0000000..cbdb15e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch
@@ -0,0 +1,34 @@
+From 6ee5c154b5b9a6fd7f07ec087f03e14a5b6ab667 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:44 +0200
+Subject: [PATCH 092/127] net: dsa: mv88e6xxx: 2500Base-X uses the 1000Base-X
+ SERDES
+
+The 6390 has three different SERDES interface types. 2500Base-X is
+implemented by the SGMII/1000Base-X SERDES. So power on/off the
+correct SERDES.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index e8ce757c6ae0..be72f0e02951 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -276,10 +276,10 @@ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+ 	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+ 		return mv88e6390_serdes_power_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+ 		return mv88e6390_serdes_power_10g(chip, lane, on);
+ 	}
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch b/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch
new file mode 100644
index 0000000..56711dc
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch
@@ -0,0 +1,439 @@
+From 12344a79a9537a38b30eecddccb88596a1bcad03 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:45 +0200
+Subject: [PATCH 093/127] net: dsa: mv88e6xxx: Cache the port cmode
+
+The ports CMODE indicates the type of link between the MAC and the
+PHY. It is used often in the SERDES code. Rather than read it each
+time, cache its value.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   | 38 +++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h   |  8 ++++++
+ drivers/net/dsa/mv88e6xxx/port.c   | 16 ++++++------
+ drivers/net/dsa/mv88e6xxx/port.h   |  3 ++-
+ drivers/net/dsa/mv88e6xxx/serdes.c | 42 +++++-------------------------
+ 5 files changed, 63 insertions(+), 44 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index f95495a8dc66..9a4bec1627f1 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2272,6 +2272,7 @@ static int mv88e6390_setup_errata(struct mv88e6xxx_chip *chip)
+ static int mv88e6xxx_setup(struct dsa_switch *ds)
+ {
+ 	struct mv88e6xxx_chip *chip = ds->priv;
++	u8 cmode;
+ 	int err;
+ 	int i;
+ 
+@@ -2286,6 +2287,17 @@ static int mv88e6xxx_setup(struct dsa_switch *ds)
+ 			goto unlock;
+ 	}
+ 
++	/* Cache the cmode of each port. */
++	for (i = 0; i < mv88e6xxx_num_ports(chip); i++) {
++		if (chip->info->ops->port_get_cmode) {
++			err = chip->info->ops->port_get_cmode(chip, i, &cmode);
++			if (err)
++				return err;
++
++			chip->ports[i].cmode = cmode;
++		}
++	}
++
+ 	/* Setup Switch Port Registers */
+ 	for (i = 0; i < mv88e6xxx_num_ports(chip); i++) {
+ 		err = mv88e6xxx_setup_port(chip, i);
+@@ -2561,6 +2573,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2590,6 +2603,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_link_state = mv88e6185_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2622,6 +2636,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2651,6 +2666,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2684,6 +2700,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_set_pause = mv88e6185_port_set_pause,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2722,6 +2739,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -2757,6 +2775,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2784,6 +2803,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2819,6 +2839,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2856,6 +2877,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2892,6 +2914,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2929,6 +2952,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2959,6 +2983,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_set_pause = mv88e6185_port_set_pause,
+ 	.port_link_state = mv88e6185_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2996,6 +3021,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3034,6 +3060,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3072,6 +3099,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3111,6 +3139,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3149,6 +3178,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3187,6 +3217,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3222,6 +3253,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3256,6 +3288,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3292,6 +3325,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3327,6 +3361,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3364,6 +3399,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3404,6 +3440,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3445,6 +3482,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index f6053799aa5a..d1f706c27cec 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -154,6 +154,10 @@ struct mv88e6xxx_irq {
+ 	unsigned int nirqs;
+ };
+ 
++struct mv88e6xxx_port {
++	u8 cmode;
++};
++
+ struct mv88e6xxx_chip {
+ 	const struct mv88e6xxx_info *info;
+ 
+@@ -207,6 +211,9 @@ struct mv88e6xxx_chip {
+ 	int irq;
+ 	int device_irq;
+ 	int watchdog_irq;
++
++	/* Array of port structures. */
++	struct mv88e6xxx_port ports[DSA_MAX_PORTS];
+ };
+ 
+ struct mv88e6xxx_bus_ops {
+@@ -318,6 +325,7 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_cmode)(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
++	int (*port_get_cmode)(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ 
+ 	/* Some devices have a per port register indicating what is
+ 	 * the upstream port this port should forward to.
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 62f39603920f..8260310bf393 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -384,11 +384,12 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			return err;
+ 	}
+ 
++	chip->ports[port].cmode = cmode;
++
+ 	return 0;
+ }
+ 
+-/* mv88e6185 only has 3 bits for CMODE */
+-static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
++int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+ 	u16 reg;
+@@ -397,10 +398,12 @@ static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
+ 	if (err)
+ 		return err;
+ 
+-	return reg & MV88E6185_PORT_STS_CMODE_MASK;
++	*cmode = reg & MV88E6185_PORT_STS_CMODE_MASK;
++
++	return 0;
+ }
+ 
+-int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
++int mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+ 	u16 reg;
+@@ -456,10 +459,7 @@ int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state)
+ {
+ 	if (state->interface == PHY_INTERFACE_MODE_1000BASEX) {
+-		int cmode = mv88e6185_port_get_cmode(chip, port);
+-
+-		if (cmode < 0)
+-			return cmode;
++		u8 cmode = chip->ports[port].cmode;
+ 
+ 		/* When a port is in "Cross-chip serdes" mode, it uses
+ 		 * 1000Base-X full duplex mode, but there is no automatic
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index 7dd0c6e1991b..b31910023bb6 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -321,7 +321,8 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ 			       u8 out);
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+-int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state);
+ int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index be72f0e02951..9469bb819a34 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -73,12 +73,8 @@ static int mv88e6352_serdes_power_set(struct mv88e6xxx_chip *chip, bool on)
+ 
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
++	u8 cmode = chip->ports[port].cmode;
+ 	int err;
+-	u8 cmode;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
+ 
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_100BASE_X) ||
+ 	    (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+@@ -96,12 +92,7 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+  */
+ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+-	u8 cmode;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	switch (port) {
+ 	case 9:
+@@ -128,19 +119,10 @@ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, 9, &cmode_port9);
+-	if (err)
+-		return err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, 10, &cmode_port10);
+-	if (err)
+-		return err;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode_port);
+-	if (err)
+-		return err;
++	cmode_port9 = chip->ports[9].cmode;
++	cmode_port10 = chip->ports[10].cmode;
++	cmode_port = chip->ports[port].cmode;
+ 
+ 	switch (port) {
+ 	case 2:
+@@ -266,12 +248,7 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 				       int lane, bool on)
+ {
+-	u8 cmode;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+@@ -328,16 +305,11 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+-	int err;
+-	u8 cmode;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	if (port != 5)
+ 		return 0;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
+-
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch b/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch
new file mode 100644
index 0000000..1d69ded
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch
@@ -0,0 +1,53 @@
+From 1f684c1eeed93c8acc38fbfa5a64b0bfb0260a02 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:46 +0200
+Subject: [PATCH 094/127] net: dsa: mv88e6xxx: Power on/off SERDES on cmode
+ change
+
+The 6390 family has a number of SERDES interfaces per port. When the
+cmode changes, eg 1000Base-X to XAUI, the SERDES interface in use will
+also change. Power down the old SERDES interface and power up the new
+SERDES interface.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/port.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 8260310bf393..20162add36be 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -19,6 +19,7 @@
+ 
+ #include "chip.h"
+ #include "port.h"
++#include "serdes.h"
+ 
+ int mv88e6xxx_port_read(struct mv88e6xxx_chip *chip, int port, int reg,
+ 			u16 *val)
+@@ -371,6 +372,10 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		cmode = 0;
+ 	}
+ 
++	err = mv88e6390_serdes_power(chip, port, false);
++	if (err)
++		return err;
++
+ 	if (cmode) {
+ 		err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
+ 		if (err)
+@@ -382,6 +387,10 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		err = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);
+ 		if (err)
+ 			return err;
++
++		err = mv88e6390_serdes_power(chip, port, true);
++		if (err)
++			return err;
+ 	}
+ 
+ 	chip->ports[port].cmode = cmode;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch b/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch
new file mode 100644
index 0000000..3dd83a8
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch
@@ -0,0 +1,48 @@
+From cf237556ee1e91fe575767c6fa2342b323aa2af5 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:47 +0200
+Subject: [PATCH 095/127] net: dsa: mv88e6xxx: link mv88e6xxx_port to
+ mv88e6xxx_chip
+
+An up coming change will register interrupts for individual switch
+ports, using the mv88e6xxx_port as the interrupt context information.
+Add members to the mv88e6xxx_port structure so we can link it back to
+the mv88e6xxx_chip member the port belongs to and the port number of
+the port.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 3 +++
+ drivers/net/dsa/mv88e6xxx/chip.h | 2 ++
+ 2 files changed, 5 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 9a4bec1627f1..80b22ecbf6f0 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -1897,6 +1897,9 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ 	int err;
+ 	u16 reg;
+ 
++	chip->ports[port].chip = chip;
++	chip->ports[port].port = port;
++
+ 	/* MAC Forcing register: don't force link, speed, duplex or flow control
+ 	 * state to any particular values on physical ports, but force the CPU
+ 	 * port and all DSA ports to their maximum bandwidth and full duplex.
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index d1f706c27cec..0d93b21157d4 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -155,6 +155,8 @@ struct mv88e6xxx_irq {
+ };
+ 
+ struct mv88e6xxx_port {
++	struct mv88e6xxx_chip *chip;
++	int port;
+ 	u8 cmode;
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch b/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch
new file mode 100644
index 0000000..92cc16a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch
@@ -0,0 +1,361 @@
+From bc17145f0452d8cdc9d234e5df932bc3fdc9cc8f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:48 +0200
+Subject: [PATCH 096/127] net: dsa: mv88e6xxx: Add SERDES phydev_mac_change up
+ for 6390
+
+phylink wants to know when the MAC layers notices a change in the
+link. For the 6390 family, this is a change in the SERDES state.
+
+Add interrupt support for the SERDES interface used to implement
+SGMII/1000Base-X/2500Base-X. This is currently limited to ports 9 and
+10. Support for the 10G SERDES and other ports will be added later,
+building on this basic framework.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  22 ++++
+ drivers/net/dsa/mv88e6xxx/chip.h   |   5 +
+ drivers/net/dsa/mv88e6xxx/serdes.c | 179 +++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  17 +++
+ 4 files changed, 223 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 80b22ecbf6f0..78a436f0cb54 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2065,7 +2065,12 @@ static int mv88e6xxx_port_enable(struct dsa_switch *ds, int port,
+ 	int err;
+ 
+ 	mutex_lock(&chip->reg_lock);
++
+ 	err = mv88e6xxx_serdes_power(chip, port, true);
++
++	if (!err && chip->info->ops->serdes_irq_setup)
++		err = chip->info->ops->serdes_irq_setup(chip, port);
++
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	return err;
+@@ -2077,8 +2082,13 @@ static void mv88e6xxx_port_disable(struct dsa_switch *ds, int port,
+ 	struct mv88e6xxx_chip *chip = ds->priv;
+ 
+ 	mutex_lock(&chip->reg_lock);
++
++	if (chip->info->ops->serdes_irq_free)
++		chip->info->ops->serdes_irq_free(chip, port);
++
+ 	if (mv88e6xxx_serdes_power(chip, port, false))
+ 		dev_err(chip->dev, "failed to power off SERDES\n");
++
+ 	mutex_unlock(&chip->reg_lock);
+ }
+ 
+@@ -3039,6 +3049,8 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3078,6 +3090,8 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390x_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+@@ -3117,6 +3131,8 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3196,6 +3212,8 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3458,6 +3476,8 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3500,6 +3520,8 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390x_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 0d93b21157d4..cf22ff447028 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -158,6 +158,7 @@ struct mv88e6xxx_port {
+ 	struct mv88e6xxx_chip *chip;
+ 	int port;
+ 	u8 cmode;
++	int serdes_irq;
+ };
+ 
+ struct mv88e6xxx_chip {
+@@ -362,6 +363,10 @@ struct mv88e6xxx_ops {
+ 	/* Power on/off a SERDES interface */
+ 	int (*serdes_power)(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
++	/* SERDES interrupt handling */
++	int (*serdes_irq_setup)(struct mv88e6xxx_chip *chip, int port);
++	void (*serdes_irq_free)(struct mv88e6xxx_chip *chip, int port);
++
+ 	/* VLAN Translation Unit operations */
+ 	int (*vtu_getnext)(struct mv88e6xxx_chip *chip,
+ 			   struct mv88e6xxx_vtu_entry *entry);
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 9469bb819a34..591557590dab 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -11,6 +11,8 @@
+  * (at your option) any later version.
+  */
+ 
++#include <linux/interrupt.h>
++#include <linux/irqdomain.h>
+ #include <linux/mii.h>
+ 
+ #include "chip.h"
+@@ -303,6 +305,183 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++static void mv88e6390_serdes_irq_link_sgmii(struct mv88e6xxx_chip *chip,
++					    int port, int lane)
++{
++	struct dsa_switch *ds = chip->ds;
++	u16 status;
++	bool up;
++
++	mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++			      MV88E6390_SGMII_STATUS, &status);
++
++	/* Status must be read twice in order to give the current link
++	 * status. Otherwise the change in link status since the last
++	 * read of the register is returned.
++	 */
++	mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++			      MV88E6390_SGMII_STATUS, &status);
++	up = status & MV88E6390_SGMII_STATUS_LINK;
++
++	dsa_port_phylink_mac_change(ds, port, up);
++}
++
++static int mv88e6390_serdes_irq_enable_sgmii(struct mv88e6xxx_chip *chip,
++					     int lane)
++{
++	return mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++				      MV88E6390_SGMII_INT_ENABLE,
++				      MV88E6390_SGMII_INT_LINK_DOWN |
++				      MV88E6390_SGMII_INT_LINK_UP);
++}
++
++static int mv88e6390_serdes_irq_disable_sgmii(struct mv88e6xxx_chip *chip,
++					      int lane)
++{
++	return mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++				      MV88E6390_SGMII_INT_ENABLE, 0);
++}
++
++int mv88e6390_serdes_irq_enable(struct mv88e6xxx_chip *chip, int port,
++				int lane)
++{
++	u8 cmode = chip->ports[port].cmode;
++	int err = 0;
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_enable_sgmii(chip, lane);
++	}
++
++	return err;
++}
++
++int mv88e6390_serdes_irq_disable(struct mv88e6xxx_chip *chip, int port,
++				 int lane)
++{
++	u8 cmode = chip->ports[port].cmode;
++	int err = 0;
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_disable_sgmii(chip, lane);
++	}
++
++	return err;
++}
++
++static int mv88e6390_serdes_irq_status_sgmii(struct mv88e6xxx_chip *chip,
++					     int lane, u16 *status)
++{
++	int err;
++
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_SGMII_INT_STATUS, status);
++
++	return err;
++}
++
++static irqreturn_t mv88e6390_serdes_thread_fn(int irq, void *dev_id)
++{
++	struct mv88e6xxx_port *port = dev_id;
++	struct mv88e6xxx_chip *chip = port->chip;
++	irqreturn_t ret = IRQ_NONE;
++	u8 cmode = port->cmode;
++	u16 status;
++	int lane;
++	int err;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port->port);
++
++	mutex_lock(&chip->reg_lock);
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_status_sgmii(chip, lane, &status);
++		if (err)
++			goto out;
++		if (status && (MV88E6390_SGMII_INT_LINK_DOWN ||
++			       MV88E6390_SGMII_INT_LINK_UP)) {
++			ret = IRQ_HANDLED;
++			mv88e6390_serdes_irq_link_sgmii(chip, port->port, lane);
++		}
++	}
++out:
++	mutex_unlock(&chip->reg_lock);
++
++	return ret;
++}
++
++int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port)
++{
++	int lane;
++	int err;
++
++	/* Only support ports 9 and 10 at the moment */
++	if (port < 9)
++		return 0;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
++
++	chip->ports[port].serdes_irq = irq_find_mapping(chip->g2_irq.domain,
++							port);
++	if (chip->ports[port].serdes_irq < 0) {
++		dev_err(chip->dev, "Unable to map SERDES irq: %d\n",
++			chip->ports[port].serdes_irq);
++		return chip->ports[port].serdes_irq;
++	}
++
++	/* Requesting the IRQ will trigger irq callbacks. So we cannot
++	 * hold the reg_lock.
++	 */
++	mutex_unlock(&chip->reg_lock);
++	err = request_threaded_irq(chip->ports[port].serdes_irq, NULL,
++				   mv88e6390_serdes_thread_fn,
++				   IRQF_ONESHOT, "mv88e6xxx-serdes",
++				   &chip->ports[port]);
++	mutex_lock(&chip->reg_lock);
++
++	if (err) {
++		dev_err(chip->dev, "Unable to request SERDES interrupt: %d\n",
++			err);
++		return err;
++	}
++
++	return mv88e6390_serdes_irq_enable(chip, port, lane);
++}
++
++void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port)
++{
++	int lane = mv88e6390x_serdes_get_lane(chip, port);
++
++	if (port < 9)
++		return;
++
++	if (lane < 0)
++		return;
++
++	mv88e6390_serdes_irq_disable(chip, port, lane);
++
++	/* Freeing the IRQ will trigger irq callbacks. So we cannot
++	 * hold the reg_lock.
++	 */
++	mutex_unlock(&chip->reg_lock);
++	free_irq(chip->ports[port].serdes_irq, &chip->ports[port]);
++	mutex_lock(&chip->reg_lock);
++}
++
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+ 	u8 cmode = chip->ports[port].cmode;
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index aa156d2a4004..10441f019945 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -43,9 +43,26 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++#define MV88E6390_SGMII_STATUS		0x2001
++#define MV88E6390_SGMII_STATUS_AN_DONE		BIT(5)
++#define MV88E6390_SGMII_STATUS_REMOTE_FAULT	BIT(4)
++#define MV88E6390_SGMII_STATUS_LINK		BIT(2)
++#define MV88E6390_SGMII_INT_ENABLE	0xa001
++#define MV88E6390_SGMII_INT_SPEED_CHANGE	BIT(14)
++#define MV88E6390_SGMII_INT_DUPLEX_CHANGE	BIT(13)
++#define MV88E6390_SGMII_INT_PAGE_RX		BIT(12)
++#define MV88E6390_SGMII_INT_AN_COMPLETE		BIT(11)
++#define MV88E6390_SGMII_INT_LINK_DOWN		BIT(10)
++#define MV88E6390_SGMII_INT_LINK_UP		BIT(9)
++#define MV88E6390_SGMII_INT_SYMBOL_ERROR	BIT(8)
++#define MV88E6390_SGMII_INT_FALSE_CARRIER	BIT(7)
++#define MV88E6390_SGMII_INT_STATUS	0xa002
++
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
++int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port);
++void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch b/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch
new file mode 100644
index 0000000..de3ab34
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch
@@ -0,0 +1,108 @@
+From 1a33f37354b514c5a3642492474ad37ac2e0af52 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:49 +0200
+Subject: [PATCH 097/127] net: dsa: mv88e6xxx: Re-setup interrupts on CMODE
+ change.
+
+When a port changes CMODE, the SERDES interface being used can change.
+Disable interrupts for the old SERDES interface, and enable interrupts
+on the new.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/port.c   | 19 ++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/serdes.c |  4 +++-
+ drivers/net/dsa/mv88e6xxx/serdes.h |  5 +++++
+ 3 files changed, 26 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 20162add36be..78c9e6c50ab0 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -342,8 +342,9 @@ int mv88e6390x_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode)
+ {
+-	u16 reg;
++	int lane;
+ 	u16 cmode;
++	u16 reg;
+ 	int err;
+ 
+ 	if (mode == PHY_INTERFACE_MODE_NA)
+@@ -372,6 +373,16 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		cmode = 0;
+ 	}
+ 
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++	if (lane < 0)
++		return lane;
++
++	if (chip->ports[port].serdes_irq) {
++		err = mv88e6390_serdes_irq_disable(chip, port, lane);
++		if (err)
++			return err;
++	}
++
+ 	err = mv88e6390_serdes_power(chip, port, false);
+ 	if (err)
+ 		return err;
+@@ -391,6 +402,12 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		err = mv88e6390_serdes_power(chip, port, true);
+ 		if (err)
+ 			return err;
++
++		if (chip->ports[port].serdes_irq) {
++			err = mv88e6390_serdes_irq_enable(chip, port, lane);
++			if (err)
++				return err;
++		}
+ 	}
+ 
+ 	chip->ports[port].cmode = cmode;
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 591557590dab..ec788cce3e25 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -118,7 +118,7 @@ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+  * use multiple lanes. If so, return the first lane the port uses.
+  * Returns -ENODEV if a port does not have a lane.
+  */
+-static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+ 
+@@ -480,6 +480,8 @@ void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port)
+ 	mutex_unlock(&chip->reg_lock);
+ 	free_irq(chip->ports[port].serdes_irq, &chip->ports[port]);
+ 	mutex_lock(&chip->reg_lock);
++
++	chip->ports[port].serdes_irq = 0;
+ }
+ 
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 10441f019945..6b41f914d156 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -58,11 +58,16 @@
+ #define MV88E6390_SGMII_INT_FALSE_CARRIER	BIT(7)
+ #define MV88E6390_SGMII_INT_STATUS	0xa002
+ 
++int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port);
+ void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port);
++int mv88e6390_serdes_irq_enable(struct mv88e6xxx_chip *chip, int port,
++				int lane);
++int mv88e6390_serdes_irq_disable(struct mv88e6xxx_chip *chip, int port,
++				 int lane);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch b/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch
new file mode 100644
index 0000000..80aa5c0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch
@@ -0,0 +1,253 @@
+From a588f1ac00ef32d64f24b142b47d1b410fb879fb Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 22 Feb 2018 22:58:32 +0100
+Subject: [PATCH 098/127] net: dsa: mv88e6xxx: Poll when no interrupt defined
+
+Not all boards have the interrupt output from the switch connected to
+a GPIO line. In such cases, phylib has to poll the internal PHYs,
+rather than receive an interrupt when there is a change in the link
+state. phylib polls once per second, and per PHY reads around 4
+words. With a switch typically having 4 internal PHYs, this means 16
+MDIO transactions per second.
+
+Rather than performing this phylib level polling, have the driver poll
+the interrupt status register. If the status register indicates an
+interrupt condition processing of interrupts in the same way as if a
+GPIO was used.
+
+Polling 10 times a second places less load on the MDIO bus. But rather
+than taking on average 0.5s to detect a link change, it takes less
+than 0.05s. Additionally, other interrupts, such as the watchdog, ATU
+and VTU violations will be reported.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 126 +++++++++++++++++++++++--------
+ drivers/net/dsa/mv88e6xxx/chip.h |   3 +
+ 2 files changed, 97 insertions(+), 32 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 78a436f0cb54..2c1d77785c1e 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -252,9 +252,8 @@ static void mv88e6xxx_g1_irq_unmask(struct irq_data *d)
+ 	chip->g1_irq.masked &= ~(1 << n);
+ }
+ 
+-static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
++static irqreturn_t mv88e6xxx_g1_irq_thread_work(struct mv88e6xxx_chip *chip)
+ {
+-	struct mv88e6xxx_chip *chip = dev_id;
+ 	unsigned int nhandled = 0;
+ 	unsigned int sub_irq;
+ 	unsigned int n;
+@@ -295,6 +294,13 @@ static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
+ 	return (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);
+ }
+ 
++static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
++{
++	struct mv88e6xxx_chip *chip = dev_id;
++
++	return mv88e6xxx_g1_irq_thread_work(chip);
++}
++
+ static void mv88e6xxx_g1_irq_bus_lock(struct irq_data *d)
+ {
+ 	struct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);
+@@ -350,7 +356,7 @@ static const struct irq_domain_ops mv88e6xxx_g1_irq_domain_ops = {
+ 	.xlate	= irq_domain_xlate_twocell,
+ };
+ 
+-static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
++static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int irq, virq;
+ 	u16 mask;
+@@ -359,8 +365,6 @@ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ 	mask &= ~GENMASK(chip->g1_irq.nirqs, 0);
+ 	mv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);
+ 
+-	free_irq(chip->irq, chip);
+-
+ 	for (irq = 0; irq < chip->g1_irq.nirqs; irq++) {
+ 		virq = irq_find_mapping(chip->g1_irq.domain, irq);
+ 		irq_dispose_mapping(virq);
+@@ -369,7 +373,14 @@ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ 	irq_domain_remove(chip->g1_irq.domain);
+ }
+ 
+-static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
++static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
++{
++	mv88e6xxx_g1_irq_free(chip);
++
++	free_irq(chip->irq, chip);
++}
++
++static int mv88e6xxx_g1_irq_setup_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int err, irq, virq;
+ 	u16 reg, mask;
+@@ -402,13 +413,6 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 	if (err)
+ 		goto out_disable;
+ 
+-	err = request_threaded_irq(chip->irq, NULL,
+-				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+-				   dev_name(chip->dev), chip);
+-	if (err)
+-		goto out_disable;
+-
+ 	return 0;
+ 
+ out_disable:
+@@ -426,6 +430,62 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 	return err;
+ }
+ 
++static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
++{
++	int err;
++
++	err = mv88e6xxx_g1_irq_setup_common(chip);
++	if (err)
++		return err;
++
++	err = request_threaded_irq(chip->irq, NULL,
++				   mv88e6xxx_g1_irq_thread_fn,
++				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
++				   dev_name(chip->dev), chip);
++	if (err)
++		mv88e6xxx_g1_irq_free_common(chip);
++
++	return err;
++}
++
++static void mv88e6xxx_irq_poll(struct kthread_work *work)
++{
++	struct mv88e6xxx_chip *chip = container_of(work,
++						   struct mv88e6xxx_chip,
++						   irq_poll_work.work);
++	mv88e6xxx_g1_irq_thread_work(chip);
++
++	kthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,
++				   msecs_to_jiffies(100));
++}
++
++static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
++{
++	int err;
++
++	err = mv88e6xxx_g1_irq_setup_common(chip);
++	if (err)
++		return err;
++
++	kthread_init_delayed_work(&chip->irq_poll_work,
++				  mv88e6xxx_irq_poll);
++
++	chip->kworker = kthread_create_worker(0, dev_name(chip->dev));
++	if (IS_ERR(chip->kworker))
++		return PTR_ERR(chip->kworker);
++
++	kthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,
++				   msecs_to_jiffies(100));
++
++	return 0;
++}
++
++static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
++{
++	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
++	kthread_destroy_worker(chip->kworker);
++}
++
+ int mv88e6xxx_wait(struct mv88e6xxx_chip *chip, int addr, int reg, u16 mask)
+ {
+ 	int i;
+@@ -4323,23 +4383,24 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ 		goto out;
+ 	}
+ 
+-	if (chip->irq > 0) {
+-		/* Has to be performed before the MDIO bus is created,
+-		 * because the PHYs will link there interrupts to these
+-		 * interrupt controllers
+-		 */
+-		mutex_lock(&chip->reg_lock);
++	/* Has to be performed before the MDIO bus is created,
++	 * because the PHYs will link there interrupts to these
++	 * interrupt controllers
++	 */
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		err = mv88e6xxx_g1_irq_setup(chip);
+-		mutex_unlock(&chip->reg_lock);
++	else
++		err = mv88e6xxx_irq_poll_setup(chip);
++	mutex_unlock(&chip->reg_lock);
+ 
+-		if (err)
+-			goto out;
++	if (err)
++		goto out;
+ 
+-		if (chip->info->g2_irqs > 0) {
+-			err = mv88e6xxx_g2_irq_setup(chip);
+-			if (err)
+-				goto out_g1_irq;
+-		}
++	if (chip->info->g2_irqs > 0) {
++		err = mv88e6xxx_g2_irq_setup(chip);
++		if (err)
++			goto out_g1_irq;
+ 	}
+ 
+ 	err = mv88e6xxx_mdios_register(chip, np);
+@@ -4355,14 +4416,15 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ out_mdio:
+ 	mv88e6xxx_mdios_unregister(chip);
+ out_g2_irq:
+-	if (chip->info->g2_irqs > 0 && chip->irq > 0)
++	if (chip->info->g2_irqs > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ out_g1_irq:
+-	if (chip->irq > 0) {
+-		mutex_lock(&chip->reg_lock);
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+-		mutex_unlock(&chip->reg_lock);
+-	}
++	else
++		mv88e6xxx_irq_poll_free(chip);
++	mutex_unlock(&chip->reg_lock);
+ out:
+ 	return err;
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index cf22ff447028..c666089af5db 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -15,6 +15,7 @@
+ #include <linux/if_vlan.h>
+ #include <linux/irq.h>
+ #include <linux/gpio/consumer.h>
++#include <linux/kthread.h>
+ #include <linux/phy.h>
+ #include <net/dsa.h>
+ 
+@@ -214,6 +215,8 @@ struct mv88e6xxx_chip {
+ 	int irq;
+ 	int device_irq;
+ 	int watchdog_irq;
++	struct kthread_worker *kworker;
++	struct kthread_delayed_work irq_poll_work;
+ 
+ 	/* Array of port structures. */
+ 	struct mv88e6xxx_port ports[DSA_MAX_PORTS];
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch b/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch
new file mode 100644
index 0000000..390b529
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch
@@ -0,0 +1,41 @@
+From d0bda55c7cc657e8f556bd3eacd304a1ebc54873 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:03 +0100
+Subject: [PATCH 099/127] net: dsa: mv88e6xxx: Add missing g1 IRQ numbers
+
+With the recent change to polling for interrupts, it is important that
+the number of global 1 interrupts is listed. Without it, the driver
+requests an interrupt domain for zero interrupts, which returns
+EINVAL, and the probe fails.
+
+Add two missing entries.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 0bf5de536880..6136be3bb58c 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3694,6 +3694,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+ 		.atu_move_port_mask = 0x1f,
++		.g1_irqs = 9,
+ 		.g2_irqs = 10,
+ 		.pvt = true,
+ 		.multi_chip = true,
+@@ -3988,6 +3989,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+ 		.atu_move_port_mask = 0x1f,
++		.g1_irqs = 9,
+ 		.g2_irqs = 10,
+ 		.pvt = true,
+ 		.multi_chip = true,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch b/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch
new file mode 100644
index 0000000..a49c5b1
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch
@@ -0,0 +1,257 @@
+From fad30d16054828f200bcacc71ef10f7c907e8c2f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:04 +0100
+Subject: [PATCH 100/127] net: dsa: mv88e6xxx: Add number of internal PHYs
+
+Add to the info structure the number of internal PHYs, if they generate
+interrupts. Some of the older generations of switches have internal
+PHYs, but no interrupt registers. In this case, set the count to zero.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 28 ++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h |  1 +
+ 2 files changed, 29 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 6136be3bb58c..40d33a24875f 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3592,6 +3592,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6085",
+ 		.num_databases = 4096,
+ 		.num_ports = 10,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3612,6 +3613,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6095/88E6095F",
+ 		.num_databases = 256,
+ 		.num_ports = 11,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3630,6 +3632,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6097/88E6097F",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,
++		.num_internal_phys = 8,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3650,6 +3653,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6123",
+ 		.num_databases = 4096,
+ 		.num_ports = 3,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3670,6 +3674,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6131",
+ 		.num_databases = 256,
+ 		.num_ports = 8,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3688,6 +3693,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6141",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3708,6 +3714,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6161",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3728,6 +3735,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6165",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3748,6 +3756,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6171",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3768,6 +3777,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6172",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3788,6 +3798,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6175",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3808,6 +3819,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6176",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3828,6 +3840,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6185",
+ 		.num_databases = 256,
+ 		.num_ports = 10,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3846,6 +3859,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6190",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3866,6 +3880,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6190X",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3886,6 +3901,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6191",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3906,6 +3922,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6240",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3926,6 +3943,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6290",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3946,12 +3964,14 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6320",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+ 		.g1_irqs = 8,
++		.g2_irqs = 10,
+ 		.atu_move_port_mask = 0xf,
+ 		.pvt = true,
+ 		.multi_chip = true,
+@@ -3965,12 +3985,14 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6321",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+ 		.g1_irqs = 8,
++		.g2_irqs = 10,
+ 		.atu_move_port_mask = 0xf,
+ 		.multi_chip = true,
+ 		.tag_protocol = DSA_TAG_PROTO_EDSA,
+@@ -3983,6 +4005,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6341",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4003,6 +4026,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6350",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4023,6 +4047,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6351",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4043,6 +4068,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6352",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4062,6 +4088,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6390",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -4081,6 +4108,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6390X",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index c666089af5db..c3ea525a3b19 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -106,6 +106,7 @@ struct mv88e6xxx_info {
+ 	const char *name;
+ 	unsigned int num_databases;
+ 	unsigned int num_ports;
++	unsigned int num_internal_phys;
+ 	unsigned int max_vid;
+ 	unsigned int port_base_addr;
+ 	unsigned int global1_addr;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch b/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch
new file mode 100644
index 0000000..a558dfe
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch
@@ -0,0 +1,135 @@
+From 2399e39cdbc22cbf937307288f3a580767518bf2 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:05 +0100
+Subject: [PATCH 101/127] net: dsa: mv88e6xxx: Add MDIO interrupts for internal
+ PHYs
+
+When registering an MDIO bus, it is possible to pass an array of
+interrupts, one per address on the bus. phylib will then associate the
+interrupt to the PHY device, if no other interrupt is provided.
+
+Some of the global2 interrupts are PHY interrupts. Place them into the
+MDIO bus structure.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c    | 10 +++++++++
+ drivers/net/dsa/mv88e6xxx/global2.c | 32 +++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/global2.h | 16 +++++++++++++++
+ 3 files changed, 58 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 40d33a24875f..9f60e8fa8783 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2511,12 +2511,19 @@ static int mv88e6xxx_mdio_register(struct mv88e6xxx_chip *chip,
+ 	bus->write = mv88e6xxx_mdio_write;
+ 	bus->parent = chip->dev;
+ 
++	if (!external) {
++		err = mv88e6xxx_g2_irq_mdio_setup(chip, bus);
++		if (err)
++			return err;
++	}
++
+ 	if (np)
+ 		err = of_mdiobus_register(bus, np);
+ 	else
+ 		err = mdiobus_register(bus);
+ 	if (err) {
+ 		dev_err(chip->dev, "Cannot register MDIO bus (%d)\n", err);
++		mv88e6xxx_g2_irq_mdio_free(chip, bus);
+ 		return err;
+ 	}
+ 
+@@ -2543,6 +2550,9 @@ static void mv88e6xxx_mdios_unregister(struct mv88e6xxx_chip *chip)
+ 	list_for_each_entry(mdio_bus, &chip->mdios, list) {
+ 		bus = mdio_bus->bus;
+ 
++		if (!mdio_bus->external)
++			mv88e6xxx_g2_irq_mdio_free(chip, bus);
++
+ 		mdiobus_unregister(bus);
+ 	}
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index af0727877825..84dbcfb07f4f 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1106,6 +1106,38 @@ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip)
+ 	return err;
+ }
+ 
++int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus)
++{
++	int phy, irq, err, err_phy;
++
++	for (phy = 0; phy < chip->info->num_internal_phys; phy++) {
++		irq = irq_find_mapping(chip->g2_irq.domain, phy);
++		if (irq < 0) {
++			err = irq;
++			goto out;
++		}
++		bus->irq[chip->info->port_base_addr + phy] = irq;
++	}
++	return 0;
++out:
++	err_phy = phy;
++
++	for (phy = 0; phy < err_phy; phy++)
++		irq_dispose_mapping(bus->irq[phy]);
++
++	return err;
++}
++
++void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus)
++{
++	int phy;
++
++	for (phy = 0; phy < chip->info->num_internal_phys; phy++)
++		irq_dispose_mapping(bus->irq[phy]);
++}
++
+ int mv88e6xxx_g2_setup(struct mv88e6xxx_chip *chip)
+ {
+ 	u16 reg;
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.h b/drivers/net/dsa/mv88e6xxx/global2.h
+index 669f59017b12..0835cda2bba6 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.h
++++ b/drivers/net/dsa/mv88e6xxx/global2.h
+@@ -259,6 +259,11 @@ int mv88e6xxx_g2_setup(struct mv88e6xxx_chip *chip);
+ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip);
+ void mv88e6xxx_g2_irq_free(struct mv88e6xxx_chip *chip);
+ 
++int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus);
++void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus);
++
+ int mv88e6185_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip);
+ int mv88e6352_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip);
+ 
+@@ -364,6 +369,17 @@ static inline void mv88e6xxx_g2_irq_free(struct mv88e6xxx_chip *chip)
+ {
+ }
+ 
++static inline int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++					      struct mii_bus *bus)
++{
++	return 0;
++}
++
++static inline void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++					      struct mii_bus *bus)
++{
++}
++
+ static inline int mv88e6185_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip)
+ {
+ 	return -EOPNOTSUPP;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch b/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch
new file mode 100644
index 0000000..e7afd12
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch
@@ -0,0 +1,263 @@
+From d918fd360d2907e81bd096f4ec3c357c6509ed60 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 5 May 2018 20:58:22 +0200
+Subject: [PATCH 102/127] net: dsa: mv88e6xxx: Fix PHY interrupts by
+ parameterising PHY base address
+
+Most of the mv88e6xxx switches have the PHYs at address 0, 1, 2, ...
+The 6341 however has the PHYs at 0x10, 0x11, 0x12. Add a parameter to
+the info structure for this base address.
+
+Testing of 6f88284f3bd7 ("net: dsa: mv88e6xxx: Add MDIO interrupts for
+internal PHYs") was performed on the 6341. So it works only on the
+6341. Use this base information to correctly set the interrupt.
+
+Fixes: 6f88284f3bd7 ("net: dsa: mv88e6xxx: Add MDIO interrupts for internal PHYs")
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c    | 26 ++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h    |  1 +
+ drivers/net/dsa/mv88e6xxx/global2.c |  2 +-
+ 3 files changed, 28 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 9f60e8fa8783..93f2697efc65 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3605,6 +3605,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3626,6 +3627,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3645,6 +3647,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 8,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3666,6 +3669,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3687,6 +3691,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3706,6 +3711,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3727,6 +3733,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3748,6 +3755,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3769,6 +3777,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3790,6 +3799,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3811,6 +3821,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3832,6 +3843,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3853,6 +3865,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3872,6 +3885,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.tag_protocol = DSA_TAG_PROTO_DSA,
+@@ -3893,6 +3907,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3914,6 +3929,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3935,6 +3951,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3956,6 +3973,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3977,6 +3995,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3998,6 +4017,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4018,6 +4038,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -4039,6 +4060,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4060,6 +4082,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4081,6 +4104,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4101,6 +4125,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -4121,6 +4146,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index c3ea525a3b19..e76b9cd07578 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -109,6 +109,7 @@ struct mv88e6xxx_info {
+ 	unsigned int num_internal_phys;
+ 	unsigned int max_vid;
+ 	unsigned int port_base_addr;
++	unsigned int phy_base_addr;
+ 	unsigned int global1_addr;
+ 	unsigned int global2_addr;
+ 	unsigned int age_time_coeff;
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index 84dbcfb07f4f..f133690e8b92 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1117,7 +1117,7 @@ int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
+ 			err = irq;
+ 			goto out;
+ 		}
+-		bus->irq[chip->info->port_base_addr + phy] = irq;
++		bus->irq[chip->info->phy_base_addr + phy] = irq;
+ 	}
+ 	return 0;
+ out:
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch b/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch
new file mode 100644
index 0000000..d51e698
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch
@@ -0,0 +1,41 @@
+From caa8f17b134d1ed638b2a2b069691f09032b7cd0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Tue, 20 Mar 2018 10:44:42 +0100
+Subject: [PATCH 103/127] net: dsa: mv88e6xxx: Fix interrupt name for g2 irq
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This changes the respective line in /proc/interrupts from
+
+ 49:          x          x  mv88e6xxx-g1   7 Edge      mv88e6xxx-g1
+
+to
+
+ 49:          x          x  mv88e6xxx-g1   7 Edge      mv88e6xxx-g2
+
+which makes more sense.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/global2.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index f133690e8b92..ddf8baaf5ca7 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1089,7 +1089,7 @@ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->device_irq, NULL,
+ 				   mv88e6xxx_g2_irq_thread_fn,
+-				   IRQF_ONESHOT, "mv88e6xxx-g1", chip);
++				   IRQF_ONESHOT, "mv88e6xxx-g2", chip);
+ 	if (err)
+ 		goto out;
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch b/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch
new file mode 100644
index 0000000..92aac8e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch
@@ -0,0 +1,31 @@
+From 449552974d9f46837db2eb70e9314efe7eea683c Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 8 Mar 2018 21:21:36 +0100
+Subject: [PATCH 104/127] net: dsa: mv88e6xxx: Fix irq free'ing
+
+Call the common irq free function, rather than going recursive and
+blowing away the stack, followed by the machine.
+
+Fixes: 294d711ee8c0 ("net: dsa: mv88e6xxx: Poll when no interrupt defined")
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 93f2697efc65..5d9250bf4299 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -375,7 +375,7 @@ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free(chip);
++	mv88e6xxx_g1_irq_free_common(chip);
+ 
+ 	free_irq(chip->irq, chip);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch b/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch
new file mode 100644
index 0000000..730d388
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch
@@ -0,0 +1,38 @@
+From 83f5636f9b2d927e9e0c4d80ea13711899b87431 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 25 Mar 2018 23:43:14 +0200
+Subject: [PATCH 105/127] net: dsa: mv88e6xxx: Use the DT IRQ trigger mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+By calling request_threaded_irq() with the flag IRQF_TRIGGER_FALLING
+we override the trigger mode provided in device tree. And the
+interrupt is actually active low, which is what all the current device
+tree descriptions use.
+
+Suggested-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Acked-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Tested-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 5d9250bf4299..c947cf4fcb54 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -440,7 +440,7 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->irq, NULL,
+ 				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
++				   IRQF_ONESHOT,
+ 				   dev_name(chip->dev), chip);
+ 	if (err)
+ 		mv88e6xxx_g1_irq_free_common(chip);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch b/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch
new file mode 100644
index 0000000..d222fc6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch
@@ -0,0 +1,31 @@
+From f7399689867c46c8e8d060adca10baa17eed8c8e Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 25 Mar 2018 23:43:15 +0200
+Subject: [PATCH 106/127] net: dsa: mv88e6xxx: Call the common IRQ free code
+
+When free'ing the polled IRQs, call the common irq free code.
+Otherwise the interrupts are left registered, and when we come to load
+the driver a second time, we get an Opps.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index c947cf4fcb54..011ae46497b3 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -482,6 +482,8 @@ static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
+ {
++	mv88e6xxx_g1_irq_free_common(chip);
++
+ 	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
+ 	kthread_destroy_worker(chip->kworker);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch b/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch
new file mode 100644
index 0000000..2b9b288
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch
@@ -0,0 +1,43 @@
+From 6dc27d8bb965b895eee531fd36dd4ced2b89d9c1 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:21:09 +0100
+Subject: [PATCH 107/127] net: dsa: mv88e6xxx: Fix IRQ when loading module
+
+Handle polled interrupts correctly when loading the module.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Fixes: 294d711ee8c0 ("net: dsa: mv88e6xxx: Poll when no interrupt defined")
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 011ae46497b3..da30516d14fb 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -4506,13 +4506,15 @@ static void mv88e6xxx_remove(struct mdio_device *mdiodev)
+ 	mv88e6xxx_unregister_switch(chip);
+ 	mv88e6xxx_mdios_unregister(chip);
+ 
+-	if (chip->irq > 0) {
+-		if (chip->info->g2_irqs > 0)
+-			mv88e6xxx_g2_irq_free(chip);
+-		mutex_lock(&chip->reg_lock);
++	if (chip->info->g2_irqs > 0)
++		mv88e6xxx_g2_irq_free(chip);
++
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+-		mutex_unlock(&chip->reg_lock);
+-	}
++	else
++		mv88e6xxx_irq_poll_free(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static const struct of_device_id mv88e6xxx_of_match[] = {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch b/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch
new file mode 100644
index 0000000..07ca113
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch
@@ -0,0 +1,102 @@
+From a89b059be36ef1d221f9a6faa986d56a94b1a7ea Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Fri, 20 Jul 2018 11:53:15 +0200
+Subject: [PATCH 108/127] net: dsa: mv88e6xxx: fix races between lock and irq
+ freeing
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+free_irq() waits until all handlers for this IRQ have completed. As the
+relevant handler (mv88e6xxx_g1_irq_thread_fn()) takes the chip's reg_lock
+it might never return if the thread calling free_irq() holds this lock.
+
+For the same reason kthread_cancel_delayed_work_sync() in the polling case
+must not hold this lock.
+
+Also first free the irq (or stop the worker respectively) such that
+mv88e6xxx_g1_irq_thread_work() isn't called any more before the irq
+mappings are dropped in mv88e6xxx_g1_irq_free_common() to prevent the
+worker thread to call handle_nested_irq(0) which results in a NULL-pointer
+exception.
+
+Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 21 +++++++++++++--------
+ 1 file changed, 13 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index da30516d14fb..cfcd981da236 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -356,6 +356,7 @@ static const struct irq_domain_ops mv88e6xxx_g1_irq_domain_ops = {
+ 	.xlate	= irq_domain_xlate_twocell,
+ };
+ 
++/* To be called with reg_lock held */
+ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int irq, virq;
+@@ -375,9 +376,15 @@ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free_common(chip);
+-
++	/*
++	 * free_irq must be called without reg_lock taken because the irq
++	 * handler takes this lock, too.
++	 */
+ 	free_irq(chip->irq, chip);
++
++	mutex_lock(&chip->reg_lock);
++	mv88e6xxx_g1_irq_free_common(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static int mv88e6xxx_g1_irq_setup_common(struct mv88e6xxx_chip *chip)
+@@ -482,10 +489,12 @@ static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free_common(chip);
+-
+ 	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
+ 	kthread_destroy_worker(chip->kworker);
++
++	mutex_lock(&chip->reg_lock);
++	mv88e6xxx_g1_irq_free_common(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ int mv88e6xxx_wait(struct mv88e6xxx_chip *chip, int addr, int reg, u16 mask)
+@@ -4487,12 +4496,10 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ 	if (chip->info->g2_irqs > 0 && chip->irq > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ out_g1_irq:
+-	mutex_lock(&chip->reg_lock);
+ 	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+ 	else
+ 		mv88e6xxx_irq_poll_free(chip);
+-	mutex_unlock(&chip->reg_lock);
+ out:
+ 	return err;
+ }
+@@ -4509,12 +4516,10 @@ static void mv88e6xxx_remove(struct mdio_device *mdiodev)
+ 	if (chip->info->g2_irqs > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ 
+-	mutex_lock(&chip->reg_lock);
+ 	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+ 	else
+ 		mv88e6xxx_irq_poll_free(chip);
+-	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static const struct of_device_id mv88e6xxx_of_match[] = {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch b/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch
new file mode 100644
index 0000000..24bc034
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch
@@ -0,0 +1,29 @@
+From 0ed95c830283285145f8f3bb2b1ccbcb722c64a5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 17 Aug 2018 12:09:49 +0200
+Subject: [PATCH 109/127] net: dsa: mv88e6xxx: Share main switch IRQ
+
+On some boards the interrupt can be shared between multiple devices.
+For example on Turris Mox the interrupt is shared between all switches.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index cfcd981da236..1335c4b5acc1 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -447,7 +447,7 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->irq, NULL,
+ 				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT,
++				   IRQF_ONESHOT | IRQF_SHARED,
+ 				   dev_name(chip->dev), chip);
+ 	if (err)
+ 		mv88e6xxx_g1_irq_free_common(chip);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch b/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch
new file mode 100644
index 0000000..543e63f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch
@@ -0,0 +1,103 @@
+From dc9c03cbf564ef633cc00038f3a00698e620daad Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 5 Oct 2018 13:23:05 +0200
+Subject: [PATCH 110/127] net: dsa: mc88e6xxx: Fix 88E6141/6341 2500mbps SERDES
+ speed
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The port_set_speed method for the Topaz family must not be the same
+as for Peridot family, since on Topaz port 5 is the SERDES port and
+can be set to 2500mbps spped mode.
+
+This patch adds a new method for the Topaz family, allowing the alt_bit
+mode only for port 0 and 2500 mbps mode for port 5.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c |  4 ++--
+ drivers/net/dsa/mv88e6xxx/port.c | 25 +++++++++++++++++++++++--
+ drivers/net/dsa/mv88e6xxx/port.h |  1 +
+ 3 files changed, 26 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 1335c4b5acc1..4dabd878521c 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2822,7 +2822,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_set_link = mv88e6xxx_port_set_link,
+ 	.port_set_duplex = mv88e6xxx_port_set_duplex,
+ 	.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,
+-	.port_set_speed = mv88e6390_port_set_speed,
++	.port_set_speed = mv88e6341_port_set_speed,
+ 	.port_tag_remap = mv88e6095_port_tag_remap,
+ 	.port_set_frame_mode = mv88e6351_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+@@ -3379,7 +3379,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_set_link = mv88e6xxx_port_set_link,
+ 	.port_set_duplex = mv88e6xxx_port_set_duplex,
+ 	.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,
+-	.port_set_speed = mv88e6390_port_set_speed,
++	.port_set_speed = mv88e6341_port_set_speed,
+ 	.port_tag_remap = mv88e6095_port_tag_remap,
+ 	.port_set_frame_mode = mv88e6351_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 78c9e6c50ab0..ead75477a6a3 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -228,8 +228,11 @@ static int mv88e6xxx_port_set_speed(struct mv88e6xxx_chip *chip, int port,
+ 		ctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_1000;
+ 		break;
+ 	case 2500:
+-		ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |
+-			MV88E6390_PORT_MAC_CTL_ALTSPEED;
++		if (alt_bit)
++			ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |
++				MV88E6390_PORT_MAC_CTL_ALTSPEED;
++		else
++			ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000;
+ 		break;
+ 	case 10000:
+ 		/* all bits set, fall through... */
+@@ -291,6 +294,24 @@ int mv88e6185_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ 	return mv88e6xxx_port_set_speed(chip, port, speed, false, false);
+ }
+ 
++/* Support 10, 100, 200, 1000, 2500 Mbps (e.g. 88E6341) */
++int mv88e6341_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
++{
++	if (speed == SPEED_MAX)
++		speed = port < 5 ? 1000 : 2500;
++
++	if (speed > 2500)
++		return -EOPNOTSUPP;
++
++	if (speed == 200 && port != 0)
++		return -EOPNOTSUPP;
++
++	if (speed == 2500 && port < 5)
++		return -EOPNOTSUPP;
++
++	return mv88e6xxx_port_set_speed(chip, port, speed, !port, true);
++}
++
+ /* Support 10, 100, 200, 1000 Mbps (e.g. 88E6352 family) */
+ int mv88e6352_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ {
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index b31910023bb6..091aa0057f1f 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -279,6 +279,7 @@ int mv88e6xxx_port_set_duplex(struct mv88e6xxx_chip *chip, int port, int dup);
+ 
+ int mv88e6065_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6185_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
++int mv88e6341_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6352_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6390_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6390x_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch b/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch
new file mode 100644
index 0000000..73d1e6e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch
@@ -0,0 +1,107 @@
+From cb0da3adfe03f7275dbbf4574b46137cb8a23f66 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Fri, 13 Jul 2018 18:18:35 +0200
+Subject: [PATCH 111/127] net: ethernet: mvneta: Fix napi structure mixup on
+ armada 3700
+
+The mvneta Ethernet driver is used on a few different Marvell SoCs.
+Some SoCs have per cpu interrupts for Ethernet events. Some SoCs have
+a single interrupt, independent of the CPU. The driver handles this by
+having a per CPU napi structure when there are per CPU interrupts, and
+a global napi structure when there is a single interrupt.
+
+When the napi core calls mvneta_poll(), it passes the napi
+instance. This was not being propagated through the call chain, and
+instead the per-cpu napi instance was passed to napi_gro_receive()
+call. This breaks when there is a single global napi instance.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Fixes: 2636ac3cc2b4 ("net: mvneta: Add network support for Armada 3700 SoC")
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 22 ++++++++++++----------
+ 1 file changed, 12 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 2986f8f1ae4a..8f9a2f05077e 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1905,10 +1905,10 @@ static void mvneta_rxq_drop_pkts(struct mvneta_port *pp,
+ }
+ 
+ /* Main rx processing when using software buffer management */
+-static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
++static int mvneta_rx_swbm(struct napi_struct *napi,
++			  struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+-	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+@@ -1963,7 +1963,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			napi_gro_receive(napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2005,7 +2005,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		napi_gro_receive(napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+@@ -2024,10 +2024,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ }
+ 
+ /* Main rx processing when using hardware buffer management */
+-static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
++static int mvneta_rx_hwbm(struct napi_struct *napi,
++			  struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+-	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+@@ -2089,7 +2089,7 @@ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			napi_gro_receive(napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2133,7 +2133,7 @@ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		napi_gro_receive(napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+@@ -2726,9 +2726,11 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
+ 	if (rx_queue) {
+ 		rx_queue = rx_queue - 1;
+ 		if (pp->bm_priv)
+-			rx_done = mvneta_rx_hwbm(pp, budget, &pp->rxqs[rx_queue]);
++			rx_done = mvneta_rx_hwbm(napi, pp, budget,
++						 &pp->rxqs[rx_queue]);
+ 		else
+-			rx_done = mvneta_rx_swbm(pp, budget, &pp->rxqs[rx_queue]);
++			rx_done = mvneta_rx_swbm(napi, pp, budget,
++						 &pp->rxqs[rx_queue]);
+ 	}
+ 
+ 	if (rx_done < budget) {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch b/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch
new file mode 100644
index 0000000..5788ab0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch
@@ -0,0 +1,77 @@
+From 5f1089e57642c9df9452a5a0c1108080e858b9d0 Mon Sep 17 00:00:00 2001
+From: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
+Date: Fri, 10 Aug 2018 11:36:27 +0800
+Subject: [PATCH 112/127] net: mvneta: fix mvneta_config_rss on armada 3700
+
+The mvneta Ethernet driver is used on a few different Marvell SoCs.
+Some SoCs have per cpu interrupts for Ethernet events, the driver uses
+a per CPU napi structure for this case. Some SoCs such as armada 3700
+have a single interrupt for Ethernet events, the driver uses a global
+napi structure for this case.
+
+Current mvneta_config_rss() always operates the per cpu napi structure.
+Fix it by operating a global napi for "single interrupt" case, and per
+cpu napi structure for remaining cases.
+
+Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
+Fixes: 2636ac3cc2b4 ("net: mvneta: Add network support for Armada 3700 SoC")
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 31 +++++++++++++++++----------
+ 1 file changed, 20 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 8f9a2f05077e..4143b3b57aa5 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3975,13 +3975,18 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
+ 
+ 	on_each_cpu(mvneta_percpu_mask_interrupt, pp, true);
+ 
+-	/* We have to synchronise on the napi of each CPU */
+-	for_each_online_cpu(cpu) {
+-		struct mvneta_pcpu_port *pcpu_port =
+-			per_cpu_ptr(pp->ports, cpu);
++	if (!pp->neta_armada3700) {
++		/* We have to synchronise on the napi of each CPU */
++		for_each_online_cpu(cpu) {
++			struct mvneta_pcpu_port *pcpu_port =
++				per_cpu_ptr(pp->ports, cpu);
+ 
+-		napi_synchronize(&pcpu_port->napi);
+-		napi_disable(&pcpu_port->napi);
++			napi_synchronize(&pcpu_port->napi);
++			napi_disable(&pcpu_port->napi);
++		}
++	} else {
++		napi_synchronize(&pp->napi);
++		napi_disable(&pp->napi);
+ 	}
+ 
+ 	pp->rxq_def = pp->indir[0];
+@@ -3998,12 +4003,16 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
+ 	mvneta_percpu_elect(pp);
+ 	spin_unlock(&pp->lock);
+ 
+-	/* We have to synchronise on the napi of each CPU */
+-	for_each_online_cpu(cpu) {
+-		struct mvneta_pcpu_port *pcpu_port =
+-			per_cpu_ptr(pp->ports, cpu);
++	if (!pp->neta_armada3700) {
++		/* We have to synchronise on the napi of each CPU */
++		for_each_online_cpu(cpu) {
++			struct mvneta_pcpu_port *pcpu_port =
++				per_cpu_ptr(pp->ports, cpu);
+ 
+-		napi_enable(&pcpu_port->napi);
++			napi_enable(&pcpu_port->napi);
++		}
++	} else {
++		napi_enable(&pp->napi);
+ 	}
+ 
+ 	netif_tx_start_all_queues(pp->dev);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch b/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch
new file mode 100644
index 0000000..070af3a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch
@@ -0,0 +1,108 @@
+From 841332d49b280dd92f2ad42b6e34f6b64a387d78 Mon Sep 17 00:00:00 2001
+From: Ken Ma <make@marvell.com>
+Date: Thu, 3 May 2018 14:31:41 +0200
+Subject: [PATCH 113/127] pinctrl: armada-37xx: Correct mpp definitions
+
+This patch icorrects below mpp definitions:
+ - The sdio_sb group is composed of 6 pins and not 5;
+ - The rgmii group contains pins mpp2[17:6] and not mpp2[19:6];
+ - Pin of group "pmic0" is mpp1[6] but not mpp1[16];
+ - Pin of group "pmic1" is mpp1[7] but not mpp1[17];
+ - A new group "smi" is added in A0 with 2 pins - mpp2[19:18], its
+   bitmask is bit4;
+ - Group "pcie1" has 3 pins in A0 - mpp2[5:3], its bit mask is
+   bit5 | bit9 | bit10 but not bit4;
+ - Group "ptp" has 3 pins in A0 as Z1, but its bitmask is changed to
+   bit11 | bit12 | bit13.
+
+Reviewed-on: http://vgitil04.il.marvell.com:8080/41830
+Reviewed-on: http://vgitil04.il.marvell.com:8080/42774
+Reviewed-on: http://vgitil04.il.marvell.com:8080/41970
+Reviewed-on: http://vgitil04.il.marvell.com:8080/42775
+Reviewed-by: Wilson Ding <dingwei@marvell.com>
+Reviewed-by: Evan Wang <xswang@marvell.com>
+Reviewed-by: Victor Gu <xigu@marvell.com>
+Tested-by: Wilson Ding <dingwei@marvell.com>
+Tested-by: iSoC Platform CI <ykjenk@marvell.com>
+Tested-by: Victor Gu <xigu@marvell.com>
+Verified-Armada37x0: Wilson Ding <dingwei@marvell.com>
+Signed-off-by: Ken Ma <make@marvell.com>
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../pinctrl/marvell,armada-37xx-pinctrl.txt        | 14 +++++++++-----
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c        |  9 +++++----
+ 2 files changed, 14 insertions(+), 9 deletions(-)
+
+diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
+index f64060908d5a..e1469852d5ea 100644
+--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
++++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
+@@ -58,11 +58,11 @@ group pwm3
+  - functions pwm, gpio
+ 
+ group pmic1
+- - pin 17
++ - pin 7
+  - functions pmic, gpio
+ 
+ group pmic0
+- - pin 16
++ - pin 6
+  - functions pmic, gpio
+ 
+ group i2c2
+@@ -112,17 +112,21 @@ group usb2_drvvbus1
+  - functions drvbus, gpio
+ 
+ group sdio_sb
+- - pins 60-64
++ - pins 60-65
+  - functions sdio, gpio
+ 
+ group rgmii
+- - pins 42-55
++ - pins 42-53
+  - functions mii, gpio
+ 
+ group pcie1
+- - pins 39-40
++ - pins 39-41
+  - functions pcie, gpio
+ 
++group smi
++ - pins 54-55
++ - functions smi, gpio
++
+ group ptp
+  - pins 56-58
+  - functions ptp, gpio
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 44897d4b9d88..67a9a747a1b9 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -157,8 +157,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
+ 	PIN_GRP_GPIO("pwm1", 12, 1, BIT(4), "pwm"),
+ 	PIN_GRP_GPIO("pwm2", 13, 1, BIT(5), "pwm"),
+ 	PIN_GRP_GPIO("pwm3", 14, 1, BIT(6), "pwm"),
+-	PIN_GRP_GPIO("pmic1", 17, 1, BIT(7), "pmic"),
+-	PIN_GRP_GPIO("pmic0", 16, 1, BIT(8), "pmic"),
++	PIN_GRP_GPIO("pmic1", 7, 1, BIT(7), "pmic"),
++	PIN_GRP_GPIO("pmic0", 6, 1, BIT(8), "pmic"),
+ 	PIN_GRP_GPIO("i2c2", 2, 2, BIT(9), "i2c"),
+ 	PIN_GRP_GPIO("i2c1", 0, 2, BIT(10), "i2c"),
+ 	PIN_GRP_GPIO("spi_cs1", 17, 1, BIT(12), "spi"),
+@@ -182,8 +182,9 @@ static struct armada_37xx_pin_group armada_37xx_sb_groups[] = {
+ 	PIN_GRP_GPIO("usb2_drvvbus1", 1, 1, BIT(1), "drvbus"),
+ 	PIN_GRP_GPIO("sdio_sb", 24, 6, BIT(2), "sdio"),
+ 	PIN_GRP_GPIO("rgmii", 6, 12, BIT(3), "mii"),
+-	PIN_GRP_GPIO("pcie1", 3, 2, BIT(4), "pcie"),
+-	PIN_GRP_GPIO("ptp", 20, 3, BIT(5), "ptp"),
++	PIN_GRP_GPIO("smi", 18, 2, BIT(4), "smi"),
++	PIN_GRP_GPIO("pcie1", 3, 3, BIT(5) | BIT(9) | BIT(10), "pcie"),
++	PIN_GRP_GPIO("ptp", 20, 3, BIT(11) | BIT(12) | BIT(13), "ptp"),
+ 	PIN_GRP("ptp_clk", 21, 1, BIT(6), "ptp", "mii"),
+ 	PIN_GRP("ptp_trig", 22, 1, BIT(7), "ptp", "mii"),
+ 	PIN_GRP_GPIO_3("mii_col", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch b/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch
new file mode 100644
index 0000000..5444d85
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch
@@ -0,0 +1,56 @@
+From b1b1740310ae80041b8b6f963076c216bc99bbaf Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Wed, 21 Mar 2018 11:50:03 +0100
+Subject: [PATCH 114/127] arm64: dts: marvell: armada-37xx: mark the gpio
+ controllers as irq controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This allows to reference these gpio controller as interrupt parent. Also
+add a comment which cpu line names are managed by the controllers
+because "nb" and "sb" usually doesn't appear in schematics, but MPPX_Y
+do.
+
+Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 8cd43ce38571..783fbb7f3b47 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -169,10 +169,13 @@
+ 				compatible = "marvell,armada3710-nb-pinctrl",
+ 					     "syscon", "simple-mfd";
+ 				reg = <0x13800 0x100>, <0x13C00 0x20>;
++				/* MPP1[19:0] */
+ 				gpionb: gpio {
+ 					#gpio-cells = <2>;
+ 					gpio-ranges = <&pinctrl_nb 0 0 36>;
+ 					gpio-controller;
++					interrupt-controller;
++					#interrupt-cells = <2>;
+ 					interrupts =
+ 					<GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+ 					<GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+@@ -231,10 +234,13 @@
+ 				compatible = "marvell,armada3710-sb-pinctrl",
+ 					     "syscon", "simple-mfd";
+ 				reg = <0x18800 0x100>, <0x18C00 0x20>;
++				/* MPP2[23:0] */
+ 				gpiosb: gpio {
+ 					#gpio-cells = <2>;
+ 					gpio-ranges = <&pinctrl_sb 0 0 30>;
+ 					gpio-controller;
++					interrupt-controller;
++					#interrupt-cells = <2>;
+ 					interrupts =
+ 					<GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
+ 					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch b/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch
new file mode 100644
index 0000000..d72e52f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch
@@ -0,0 +1,764 @@
+From f090da3ea5975a0d13dcf2c3c3ca3b4790dbaede Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 8 Aug 2018 16:02:13 +0200
+Subject: [PATCH 115/127] drivers: mfd: Add support for Moxtet bus
+
+On the Turris Mox router there can be connected different modules to
+the main CPU board, currently a module with a SFP cage, a module with
+MiniPCIe connector, a 4-port switch module and a 8-port switch module,
+for example:
+  [CPU]-[PCIe]-[8-port switch]-[8-port switch]-[SFP]
+
+Each of this modules has an input and output shift register, and these
+are connected via SPI to CPU board.
+
+Via this SPI connection we are able to discover which modules are
+connected and we can also read/write some configuration to the modules.
+Fromi/to each module 8 bits can be read (of which lower 4 bits identify
+the module) and written.
+
+For example from the module with a SFP cage we can read the LOS,
+TX-FAULT and MOD-DEF0 signals, while we can write TX-DISABLE and
+RATE-SELECT signals.
+
+Other modules may support something else.
+
+This driver creates a new bus type, called "moxtet". For each Mox module
+it finds via SPI, it creates a new device on the moxtet bus so that
+drivers can be written for them, for example a gpio driver for the
+module with a SFP cage.
+
+The topology of how Mox modules are connected can then be read by
+listing /sys/bus/moxtet/devices.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../devicetree/bindings/mfd/moxtet.txt        |  36 ++
+ MAINTAINERS                                   |   7 +
+ drivers/mfd/Kconfig                           |  10 +
+ drivers/mfd/Makefile                          |   1 +
+ drivers/mfd/moxtet.c                          | 504 ++++++++++++++++++
+ include/linux/mfd/moxtet.h                    | 106 ++++
+ 6 files changed, 664 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/mfd/moxtet.txt
+ create mode 100644 drivers/mfd/moxtet.c
+ create mode 100644 include/linux/mfd/moxtet.h
+
+diff --git a/Documentation/devicetree/bindings/mfd/moxtet.txt b/Documentation/devicetree/bindings/mfd/moxtet.txt
+new file mode 100644
+index 000000000000..02b96fbd5ddd
+--- /dev/null
++++ b/Documentation/devicetree/bindings/mfd/moxtet.txt
+@@ -0,0 +1,36 @@
++Turris Mox module configuration bus (over SPI)
++
++Required properties:
++ - compatible		: Should be "cznic,moxtet".
++ - #address-cells	: Has to be 1
++ - #size-cells		: Has to be 0
++For other required and optional properties of SPI slave
++nodes please refer to ../spi/spi-bus.txt.
++
++Required properties of subnodes:
++ - reg			: Should be position on the Moxtet bus
++ - moxtet,id		: Should be ID of the Moxtet device connected
++
++The driver finds the devices connected to the bus by itself, but it may be
++needed to reference some of them from other parts of the device tree. In that
++case the devices can be defined as subnodes of the moxtet node.
++
++Example:
++
++	moxtet@1 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "cznic,moxtet";
++		reg = <1>;
++		spi-max-frequency = <1000000>;
++		spi-cpol;
++		spi-cpha;
++
++		moxtet_sfp: moxtet-sfp@0 {
++			compatible = "cznic,moxtet-sfp";
++			gpio-controller;
++			#gpio-cells;
++			reg = <0>;
++			moxtet,id = <1>;
++		}
++	};
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 6cb70b853323..ab6dc27c14c9 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1344,6 +1344,13 @@ F:	drivers/clocksource/timer-prima2.c
+ F:	drivers/clocksource/timer-atlas7.c
+ N:	[^a-z]sirf
+ 
++ARM/CZ.NIC TURRIS MOX SUPPORT
++M:	Marek Behun <marek.behun@nic.cz>
++W:	http://mox.turris.cz
++S:	Maintained
++F:	include/mfd/moxtet.h
++F:	drivers/mfd/moxtet.c
++
+ ARM/EBSA110 MACHINE SUPPORT
+ M:	Russell King <linux@armlinux.org.uk>
+ L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
+diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
+index fc5e4fef89d2..663789ef3225 100644
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -761,6 +761,16 @@ config MFD_MAX8998
+ 	  additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config MFD_MOXTET
++	tristate "CZ.NIC Turris Mox module configuration bus"
++	depends on SPI_MASTER && OF
++	help
++	  Say yes here to add support for the module configuration bus found
++	  on CZ.NIC's Turris Mox. This is needed for the ability to read
++	  in what order the modules are connected and to get/set some of
++	  their settings. For example the GPIOs on Mox SFP module are
++	  configured through this bus.
++
+ config MFD_MT6397
+ 	tristate "MediaTek MT6397 PMIC Support"
+ 	select MFD_CORE
+diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
+index 8703ff17998e..79b6e06c20c9 100644
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -150,6 +150,7 @@ max8925-objs			:= max8925-core.o max8925-i2c.o
+ obj-$(CONFIG_MFD_MAX8925)	+= max8925.o
+ obj-$(CONFIG_MFD_MAX8997)	+= max8997.o max8997-irq.o
+ obj-$(CONFIG_MFD_MAX8998)	+= max8998.o max8998-irq.o
++obj-$(CONFIG_MFD_MOXTET)	+= moxtet.o
+ 
+ pcf50633-objs			:= pcf50633-core.o pcf50633-irq.o
+ obj-$(CONFIG_MFD_PCF50633)	+= pcf50633.o
+diff --git a/drivers/mfd/moxtet.c b/drivers/mfd/moxtet.c
+new file mode 100644
+index 000000000000..ec525263566a
+--- /dev/null
++++ b/drivers/mfd/moxtet.c
+@@ -0,0 +1,504 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Turris Mox module configuration bus driver
++ *
++ * Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/of_device.h>
++#include <linux/spi/spi.h>
++#include <linux/mfd/moxtet.h>
++
++static ssize_t
++module_id_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	return sprintf(buf, "0x%x\n", mdev->id);
++}
++static DEVICE_ATTR_RO(module_id);
++
++static ssize_t
++module_name_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	return sprintf(buf, "%s\n", turris_mox_module_name(mdev->id));
++}
++static DEVICE_ATTR_RO(module_name);
++
++static ssize_t
++input_value_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = moxtet_device_read(dev);
++	if (ret < 0)
++		return ret;
++
++	return sprintf(buf, "0x%x\n", ret);
++}
++static DEVICE_ATTR_RO(input_value);
++
++static ssize_t
++output_value_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = moxtet_device_written(dev);
++	if (ret < 0)
++		return ret;
++
++	return sprintf(buf, "0x%x\n", ret);
++}
++
++static ssize_t
++output_value_store(struct device *dev, struct device_attribute *a,
++		   const char *buf, size_t count)
++{
++	unsigned long val;
++	int ret;
++
++	ret = kstrtoul(buf, 0, &val);
++	if (ret < 0)
++		return ret;
++
++	if (val > 0xff)
++		return -ERANGE;
++
++	ret = moxtet_device_write(dev, val);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++static DEVICE_ATTR_RW(output_value);
++
++static struct attribute *moxtet_dev_attrs[] = {
++	&dev_attr_module_id.attr,
++	&dev_attr_module_name.attr,
++	&dev_attr_input_value.attr,
++	&dev_attr_output_value.attr,
++	NULL,
++};
++
++static const struct attribute_group moxtet_dev_group = {
++	.attrs = moxtet_dev_attrs,
++};
++
++static const struct attribute_group *moxtet_dev_groups[] = {
++	&moxtet_dev_group,
++	NULL,
++};
++
++static int moxtet_match(struct device *dev, struct device_driver *drv)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet_driver *tdrv = to_moxtet_driver(drv);
++	const enum turris_mox_module_id *t;
++
++	if (of_driver_match_device(dev, drv))
++		return 1;
++
++	if (!tdrv->id_table)
++		return 0;
++
++	for (t = tdrv->id_table; *t; ++t)
++		if (*t == mdev->id)
++			return 1;
++
++	return 0;
++}
++
++struct bus_type moxtet_bus_type = {
++	.name		= "moxtet",
++	.dev_groups	= moxtet_dev_groups,
++	.match		= moxtet_match,
++};
++EXPORT_SYMBOL_GPL(moxtet_bus_type);
++
++int __moxtet_register_driver(struct module *owner,
++			     struct moxtet_driver *mdrv)
++{
++	mdrv->driver.owner = owner;
++	mdrv->driver.bus = &moxtet_bus_type;
++	return driver_register(&mdrv->driver);
++}
++EXPORT_SYMBOL_GPL(__moxtet_register_driver);
++
++static int moxtet_dev_check(struct device *dev, void *data)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet_device *new_dev = data;
++
++	if (mdev->moxtet == new_dev->moxtet && mdev->id == new_dev->id &&
++	    mdev->idx == new_dev->idx)
++		return -EBUSY;
++	return 0;
++}
++
++static void moxtet_dev_release(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	put_device(mdev->moxtet->dev);
++	kfree(mdev);
++}
++
++static struct moxtet_device *
++moxtet_alloc_device(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++
++	if (!get_device(moxtet->dev))
++		return NULL;
++
++	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
++	if (!dev) {
++		put_device(moxtet->dev);
++		return NULL;
++	}
++
++	dev->moxtet = moxtet;
++	dev->dev.parent = moxtet->dev;
++	dev->dev.bus = &moxtet_bus_type;
++	dev->dev.release = moxtet_dev_release;
++
++	device_initialize(&dev->dev);
++
++	return dev;
++}
++
++static int moxtet_add_device(struct moxtet_device *dev)
++{
++	static DEFINE_MUTEX(add_mutex);
++	int ret;
++
++	if (dev->idx >= TURRIS_MOX_MAX_MODULES || dev->id > 0xf)
++		return -EINVAL;
++
++	dev_set_name(&dev->dev, "moxtet-%s.%u",
++		     turris_mox_module_name(dev->id), dev->idx);
++
++	mutex_lock(&add_mutex);
++
++	ret = bus_for_each_dev(&moxtet_bus_type, NULL, dev,
++			       moxtet_dev_check);
++	if (ret)
++		goto done;
++
++	ret = device_add(&dev->dev);
++	if (ret < 0)
++		dev_err(dev->moxtet->dev, "can't add %s, status %d\n",
++			dev_name(dev->moxtet->dev), ret);
++
++done:
++	mutex_unlock(&add_mutex);
++	return ret;
++}
++
++static int __unregister(struct device *dev, void *null)
++{
++	if (dev->of_node) {
++		of_node_clear_flag(dev->of_node, OF_POPULATED);
++		of_node_put(dev->of_node);
++	}
++
++	device_unregister(dev);
++
++	return 0;
++}
++
++static struct moxtet_device *
++of_register_moxtet_device(struct moxtet *moxtet, struct device_node *nc)
++{
++	struct moxtet_device *dev;
++	u32 val;
++	int ret;
++
++	dev = moxtet_alloc_device(moxtet);
++	if (!dev) {
++		dev_err(moxtet->dev,
++			"Moxtet device alloc error for %pOF\n", nc);
++		return ERR_PTR(-ENOMEM);
++	}
++
++	ret = of_property_read_u32(nc, "reg", &val);
++	if (ret || val >= TURRIS_MOX_MAX_MODULES) {
++		dev_err(moxtet->dev, "%pOF has no valid 'reg' property (%d)\n",
++			nc, ret);
++		goto err_put;
++	}
++	dev->idx = val;
++
++	ret = of_property_read_u32(nc, "moxtet,id", &val);
++	if (ret || val > 0xf) {
++		dev_err(moxtet->dev,
++			"%pOF has no valid 'moxtet,id' property (%d)\n", nc,
++			ret);
++		goto err_put;
++	}
++	dev->id = val;
++
++	if (moxtet->modules[dev->idx] != dev->id) {
++		dev_err(moxtet->dev,
++			"%pOF requested Moxtet device ID 0x%x, 0x%x found\n",
++			nc, dev->id, moxtet->modules[dev->idx]);
++		goto err_put;
++	}
++
++	of_node_get(nc);
++	dev->dev.of_node = nc;
++
++	ret = moxtet_add_device(dev);
++	if (ret) {
++		dev_err(moxtet->dev,
++			"Moxtet device register error for %pOF\n", nc);
++		of_node_put(nc);
++		goto err_put;
++	}
++
++	return dev;
++
++err_put:
++	put_device(&dev->dev);
++	return ERR_PTR(ret);
++}
++
++static void of_register_moxtet_devices(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++	struct device_node *nc;
++
++	if (!moxtet->dev->of_node)
++		return;
++
++	for_each_available_child_of_node(moxtet->dev->of_node, nc) {
++		if (of_node_test_and_set_flag(nc, OF_POPULATED))
++			continue;
++		dev = of_register_moxtet_device(moxtet, nc);
++		if (IS_ERR(dev)) {
++			dev_warn(moxtet->dev,
++				 "Failed to create Moxtet device for %pOF\n",
++				 nc);
++			of_node_clear_flag(nc, OF_POPULATED);
++		}
++	}
++}
++
++static void
++moxtet_register_devices_from_topology(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++	int i, ret;
++
++	for (i = 0; i < moxtet->count; ++i) {
++		dev = moxtet_alloc_device(moxtet);
++		if (!dev) {
++			dev_err(moxtet->dev, "Moxtet device %u alloc error\n",
++				i);
++			continue;
++		}
++
++		dev->idx = i;
++		dev->id = moxtet->modules[i];
++
++		ret = moxtet_add_device(dev);
++		if (ret && ret != -EBUSY) {
++			put_device(&dev->dev);
++			dev_err(moxtet->dev,
++				"Moxtet device %u register error: %i\n", i,
++				ret);
++		}
++	}
++}
++
++static int moxtet_find_topology(struct moxtet *moxtet)
++{
++	u8 buf[TURRIS_MOX_MAX_MODULES];
++	int i, ret;
++
++	ret = spi_read(to_spi_device(moxtet->dev), buf, TURRIS_MOX_MAX_MODULES);
++	if (ret < 0)
++		return ret;
++
++	if (buf[0] == TURRIS_MOX_CPU_ID_EMMC) {
++		dev_info(moxtet->dev, "Found eMMC Turris Mox CPU module\n");
++	} else if (buf[0] == TURRIS_MOX_CPU_ID_SD) {
++		dev_info(moxtet->dev, "Found SD Turris Mox CPU module\n");
++	} else {
++		dev_err(moxtet->dev, "Invalid Turris Mox CPU module 0x%02x\n",
++			buf[0]);
++		return -ENODEV;
++	}
++
++	moxtet->count = 0;
++
++	for (i = 1; i < TURRIS_MOX_MAX_MODULES; ++i) {
++		int module_id;
++
++		if (buf[i] == 0xff)
++			break;
++
++		module_id = buf[i] & 0xf;
++
++		moxtet->modules[i-1] = module_id;
++		++moxtet->count;
++
++		switch (module_id) {
++		case TURRIS_MOX_MODULE_SFP:
++			dev_info(moxtet->dev, "SFP module found\n");
++			break;
++		case TURRIS_MOX_MODULE_PCI:
++			dev_info(moxtet->dev, "PCIe module found\n");
++			break;
++		case TURRIS_MOX_MODULE_TOPAZ:
++			dev_info(moxtet->dev, "Topaz Switch module found\n");
++			break;
++		case TURRIS_MOX_MODULE_PERIDOT:
++			dev_info(moxtet->dev, "Peridot Switch module found\n");
++			break;
++		case TURRIS_MOX_MODULE_USB3:
++			dev_info(moxtet->dev, "USB 3.0 module found\n");
++			break;
++		default:
++			dev_info(moxtet->dev,
++				 "Unknown Moxtet module found (ID 0x%02x)\n",
++				 module_id);
++		}
++	}
++
++	return 0;
++}
++
++int moxtet_device_read(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++	u8 buf[TURRIS_MOX_MAX_MODULES];
++	struct spi_transfer xfer = {
++		.rx_buf = buf,
++		.tx_buf = moxtet->tx,
++		.len = moxtet->count + 1
++	};
++	int ret;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	mutex_lock(&moxtet->lock);
++
++	ret = spi_sync_transfer(to_spi_device(moxtet->dev), &xfer, 1);
++
++	mutex_unlock(&moxtet->lock);
++
++	if (ret < 0)
++		return ret;
++
++	return buf[mdev->idx + 1] >> 4;
++}
++EXPORT_SYMBOL_GPL(moxtet_device_read);
++
++int moxtet_device_write(struct device *dev, u8 val)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++	int ret;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	mutex_lock(&moxtet->lock);
++
++	moxtet->tx[moxtet->count - mdev->idx] = val;
++
++	ret = spi_write(to_spi_device(moxtet->dev), moxtet->tx,
++			moxtet->count + 1);
++
++	mutex_unlock(&moxtet->lock);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(moxtet_device_write);
++
++int moxtet_device_written(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	return moxtet->tx[moxtet->count - mdev->idx];
++}
++EXPORT_SYMBOL_GPL(moxtet_device_written);
++
++static int moxtet_probe(struct spi_device *spi)
++{
++	struct moxtet *moxtet;
++	int ret;
++
++	ret = spi_setup(spi);
++	if (ret < 0)
++		return ret;
++
++	moxtet = devm_kzalloc(&spi->dev, sizeof(struct moxtet),
++			      GFP_KERNEL);
++	if (!moxtet)
++		return -ENOMEM;
++
++	moxtet->dev = &spi->dev;
++	spi_set_drvdata(spi, moxtet);
++
++	mutex_init(&moxtet->lock);
++
++	ret = moxtet_find_topology(moxtet);
++	if (ret < 0)
++		return ret;
++
++	of_register_moxtet_devices(moxtet);
++	moxtet_register_devices_from_topology(moxtet);
++
++	return 0;
++}
++
++static int moxtet_remove(struct spi_device *spi)
++{
++	struct moxtet *moxtet = spi_get_drvdata(spi);
++	int dummy;
++
++	dummy = device_for_each_child(moxtet->dev, NULL, __unregister);
++
++	mutex_destroy(&moxtet->lock);
++
++	return 0;
++}
++
++static const struct of_device_id moxtet_dt_ids[] = {
++	{ .compatible = "cznic,moxtet" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, moxtet_dt_ids);
++
++static struct spi_driver moxtet_driver = {
++	.driver = {
++		.name		= "moxtet",
++		.of_match_table = moxtet_dt_ids,
++	},
++	.probe		= moxtet_probe,
++	.remove		= moxtet_remove,
++};
++module_spi_driver(moxtet_driver);
++
++static int __init moxtet_init(void)
++{
++	return bus_register(&moxtet_bus_type);
++}
++
++postcore_initcall(moxtet_init);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("CZ.NIC's Turris Mox module configuration bus");
++MODULE_LICENSE("GPL v2");
+diff --git a/include/linux/mfd/moxtet.h b/include/linux/mfd/moxtet.h
+new file mode 100644
+index 000000000000..fcb7bb0d4465
+--- /dev/null
++++ b/include/linux/mfd/moxtet.h
+@@ -0,0 +1,106 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Turris Mox module configuration bus driver
++ *
++ * Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#ifndef __LINUX_MFD_MOXTET_H
++#define __LINUX_MFD_MOXTET_H
++
++#include <linux/device.h>
++#include <linux/mutex.h>
++
++#define TURRIS_MOX_MAX_MODULES	10
++
++enum turris_mox_cpu_module_id {
++	TURRIS_MOX_CPU_ID_EMMC	= 0x00,
++	TURRIS_MOX_CPU_ID_SD	= 0x10,
++};
++
++enum turris_mox_module_id {
++	TURRIS_MOX_MODULE_SFP		= 0x01,
++	TURRIS_MOX_MODULE_PCI		= 0x02,
++	TURRIS_MOX_MODULE_TOPAZ		= 0x03,
++	TURRIS_MOX_MODULE_PERIDOT	= 0x04,
++	TURRIS_MOX_MODULE_USB3		= 0x05,
++};
++
++static inline const char *turris_mox_module_name(unsigned int id)
++{
++	switch (id) {
++	case TURRIS_MOX_MODULE_SFP:
++		return "sfp";
++	case TURRIS_MOX_MODULE_PCI:
++		return "pci";
++	case TURRIS_MOX_MODULE_TOPAZ:
++		return "topaz";
++	case TURRIS_MOX_MODULE_PERIDOT:
++		return "peridot";
++	case TURRIS_MOX_MODULE_USB3:
++		return "usb3";
++	default:
++		return "unknown";
++	}
++}
++
++extern struct bus_type moxtet_type;
++
++struct moxtet {
++	struct device	*dev;
++	struct mutex	lock;
++	u8		modules[TURRIS_MOX_MAX_MODULES];
++	int		count;
++	u8		tx[TURRIS_MOX_MAX_MODULES];
++	char		module_topology[128];
++};
++
++struct moxtet_driver {
++	const enum turris_mox_module_id	*id_table;
++	struct device_driver		driver;
++};
++
++static inline struct moxtet_driver *
++to_moxtet_driver(struct device_driver *drv)
++{
++	if (!drv)
++		return NULL;
++	return container_of(drv, struct moxtet_driver, driver);
++}
++
++extern int __moxtet_register_driver(struct module *owner,
++				    struct moxtet_driver *mdrv);
++
++static inline void moxtet_unregister_driver(struct moxtet_driver *mdrv)
++{
++	if (mdrv)
++		driver_unregister(&mdrv->driver);
++}
++
++#define moxtet_register_driver(driver) \
++	__moxtet_register_driver(THIS_MODULE, driver)
++
++#define module_moxtet_driver(__moxtet_driver) \
++	module_driver(__moxtet_driver, moxtet_register_driver, \
++			moxtet_unregister_driver)
++
++struct moxtet_device {
++	struct device			dev;
++	struct moxtet			*moxtet;
++	enum turris_mox_module_id	id;
++	unsigned int			idx;
++};
++
++extern int moxtet_device_read(struct device *dev);
++extern int moxtet_device_write(struct device *dev, u8 val);
++extern int moxtet_device_written(struct device *dev);
++
++static inline struct moxtet_device *
++to_moxtet_device(struct device *dev)
++{
++	if (!dev)
++		return NULL;
++	return container_of(dev, struct moxtet_device, dev);
++}
++
++#endif /* __LINUX_MFD_MOXTET_H */
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch b/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch
new file mode 100644
index 0000000..f177bac
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch
@@ -0,0 +1,280 @@
+From f38a007d4d31dafcb911b5d49f401d05dd9f3c76 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 8 Aug 2018 16:14:52 +0200
+Subject: [PATCH 116/127] drivers: gpio: Add support for GPIOs over Moxtet bus
+
+This adds support for interpreting the input and output bits of one
+device on Moxtet bus as GPIOs.
+This is needed for example by the SFP cage module of Turris Mox.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ MAINTAINERS                |   1 +
+ drivers/gpio/Kconfig       |   9 ++
+ drivers/gpio/Makefile      |   1 +
+ drivers/gpio/gpio-moxtet.c | 209 +++++++++++++++++++++++++++++++++++++
+ 4 files changed, 220 insertions(+)
+ create mode 100644 drivers/gpio/gpio-moxtet.c
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index ab6dc27c14c9..155e88024387 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1349,6 +1349,7 @@ M:	Marek Behun <marek.behun@nic.cz>
+ W:	http://mox.turris.cz
+ S:	Maintained
+ F:	include/mfd/moxtet.h
++F:	drivers/gpio/gpio-moxtet.c
+ F:	drivers/mfd/moxtet.c
+ 
+ ARM/EBSA110 MACHINE SUPPORT
+diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
+index 3f80f167ed56..798b7aff37a1 100644
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -995,6 +995,15 @@ config GPIO_MAX77620
+ 	  driver also provides interrupt support for each of the gpios.
+ 	  Say yes here to enable the max77620 to be used as gpio controller.
+ 
++config GPIO_MOXTET
++	tristate "Turris Mox Moxtet bus GPIO expander"
++	depends on MFD_MOXTET
++	help
++	  Say yes here if you are building for the Turris Mox router.
++	  This is the driver needed for configuring the GPIOs via the Moxtet
++	  bus. For example the Mox module with SFP cage needs this driver
++	  so that phylink can use corresponding GPIOs.
++
+ config GPIO_MSIC
+ 	bool "Intel MSIC mixed signal gpio support"
+ 	depends on (X86 || COMPILE_TEST) && MFD_INTEL_MSIC
+diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
+index 8a2dfba3b231..0adfa2ea5be7 100644
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -83,6 +83,7 @@ obj-$(CONFIG_GPIO_MC9S08DZ60)	+= gpio-mc9s08dz60.o
+ obj-$(CONFIG_GPIO_ML_IOH)	+= gpio-ml-ioh.o
+ obj-$(CONFIG_GPIO_MM_LANTIQ)	+= gpio-mm-lantiq.o
+ obj-$(CONFIG_GPIO_MOCKUP)      += gpio-mockup.o
++obj-$(CONFIG_GPIO_MOXTET)	+= gpio-moxtet.o
+ obj-$(CONFIG_GPIO_MPC5200)	+= gpio-mpc5200.o
+ obj-$(CONFIG_GPIO_MPC8XXX)	+= gpio-mpc8xxx.o
+ obj-$(CONFIG_GPIO_MSIC)		+= gpio-msic.o
+diff --git a/drivers/gpio/gpio-moxtet.c b/drivers/gpio/gpio-moxtet.c
+new file mode 100644
+index 000000000000..d0b50581118d
+--- /dev/null
++++ b/drivers/gpio/gpio-moxtet.c
+@@ -0,0 +1,209 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ *  Turris Mox Moxtet GPIO expander
++ *
++ *  Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/gpio/consumer.h>
++#include <linux/gpio.h>
++#include <linux/mfd/moxtet.h>
++#include <linux/module.h>
++#include <linux/of_gpio.h>
++
++struct moxtet_gpio_chip {
++	struct device		*dev;
++	struct gpio_chip	gpio_chip;
++	u8			in_mask;
++	u8			out_mask;
++};
++
++static int moxtet_gpio_dir_mask(struct gpio_chip *gc, unsigned int offset,
++				int *dir, u8 *mask)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int i;
++
++	*dir = 0;
++	for (i = 0; i < 4; ++i) {
++		*mask = 1 << i;
++		if (*mask & chip->in_mask) {
++			if (offset == 0)
++				return 0;
++			--offset;
++		}
++	}
++
++	*dir = 1;
++	for (i = 0; i < 8; ++i) {
++		*mask = 1 << i;
++		if (*mask & chip->out_mask) {
++			if (offset == 0)
++				return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
++static int moxtet_gpio_get_value(struct gpio_chip *gc, unsigned int offset)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int ret, dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (dir)
++		ret = moxtet_device_written(chip->dev);
++	else
++		ret = moxtet_device_read(chip->dev);
++
++	if (ret < 0)
++		return ret;
++
++	return (ret & mask) ? 1 : 0;
++}
++
++static void moxtet_gpio_set_value(struct gpio_chip *gc, unsigned int offset,
++				  int val)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int state, dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return;
++
++	/* cannot change input GPIO */
++	if (!dir)
++		return;
++
++	state = moxtet_device_written(chip->dev);
++	if (state < 0)
++		return;
++
++	if (val)
++		state |= mask;
++	else
++		state &= ~mask;
++
++	moxtet_device_write(chip->dev, state);
++}
++
++static int moxtet_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	return dir;
++}
++
++static int moxtet_gpio_direction_input(struct gpio_chip *gc,
++				       unsigned int offset)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (dir)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int moxtet_gpio_direction_output(struct gpio_chip *gc,
++					unsigned int offset, int val)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (!dir)
++		return -EINVAL;
++
++	moxtet_gpio_set_value(gc, offset, val);
++	return 0;
++}
++
++static int moxtet_gpio_probe(struct device *dev)
++{
++	struct moxtet_gpio_chip *chip;
++	struct device_node *nc = dev->of_node;
++	int ret;
++	u32 val;
++
++	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++
++	chip->dev = dev;
++	chip->gpio_chip.parent = dev;
++
++	ret = of_property_read_u32(nc, "moxtet,input-mask", &val);
++	if (ret < 0 || val > 0xf) {
++		dev_err(dev,
++			"%pOF has no valid 'moxtet,input-mask' property\n", nc);
++		return ret < 0 ? ret : -ERANGE;
++	}
++	chip->in_mask = val;
++
++	ret = of_property_read_u32(nc, "moxtet,output-mask", &val);
++	if (ret < 0 || val > 0xff) {
++		dev_err(dev,
++			"%pOF has no valid 'moxtet,output-mask' property\n",
++			nc);
++		return ret < 0 ? ret : -ERANGE;
++	}
++	chip->out_mask = val;
++
++	if (!chip->in_mask && !chip->out_mask) {
++		dev_err(dev, "%pOF has zero GPIOs defined\n", nc);
++		return -EINVAL;
++	}
++
++	dev_set_drvdata(dev, chip);
++
++	chip->gpio_chip.label = dev_name(dev);
++	chip->gpio_chip.get_direction = moxtet_gpio_get_direction;
++	chip->gpio_chip.direction_input = moxtet_gpio_direction_input;
++	chip->gpio_chip.direction_output = moxtet_gpio_direction_output;
++	chip->gpio_chip.get = moxtet_gpio_get_value;
++	chip->gpio_chip.set = moxtet_gpio_set_value;
++	chip->gpio_chip.base = -1;
++
++	chip->gpio_chip.ngpio = hweight8(chip->in_mask) +
++				hweight8(chip->out_mask);
++
++	chip->gpio_chip.can_sleep = true;
++	chip->gpio_chip.owner = THIS_MODULE;
++
++	return devm_gpiochip_add_data(dev, &chip->gpio_chip, chip);
++}
++
++static const struct of_device_id moxtet_gpio_dt_ids[] = {
++	{ .compatible = "cznic,moxtet-gpio" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, moxtet_gpio_dt_ids);
++
++static struct moxtet_driver moxtet_gpio_driver = {
++	.driver = {
++		.name		= "moxtet-gpio",
++		.of_match_table	= moxtet_gpio_dt_ids,
++		.probe		= moxtet_gpio_probe,
++	},
++};
++module_moxtet_driver(moxtet_gpio_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Turris Mox Moxtet GPIO expander");
++MODULE_LICENSE("GPL v2");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch b/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
new file mode 100644
index 0000000..c8f8fe4
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
@@ -0,0 +1,461 @@
+From aff32743eabfb165e15b3a623e241cddeaa55ce3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:45:21 +0200
+Subject: [PATCH 117/127] watchdog: Add support for Armada 37xx CPU watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for the CPU watchdog found on Marvell Armada 37xx
+SoCs.
+
+There are 4 counters which can be set as CPU watchdog counters.
+This driver uses the second counter (ID 1, counting from 0) as watchdog
+counter, and first counter (ID 0) to implement pinging on the second
+counter without the need to disable it.
+
+Since counters IDs 2 and 3 are enabled already before even U-Boot
+starts, this driver does not use them at all, for example by adding a
+device tree property for counter selection.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+Reviewed-by: Guenter Roeck <linux@roeck-us.net>
+Tested-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/watchdog/Kconfig           |  11 +
+ drivers/watchdog/Makefile          |   1 +
+ drivers/watchdog/armada_37xx_wdt.c | 388 +++++++++++++++++++++++++++++
+ 3 files changed, 400 insertions(+)
+ create mode 100644 drivers/watchdog/armada_37xx_wdt.c
+
+diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
+index 3ece1335ba84..1deba6f2dece 100644
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -255,6 +255,17 @@ config ARM_SBSA_WATCHDOG
+ 	  To compile this driver as module, choose M here: The module
+ 	  will be called sbsa_gwdt.
+ 
++config ARMADA_37XX_WATCHDOG
++	tristate "Armada 37xx watchdog"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	select MFD_SYSCON
++	select WATCHDOG_CORE
++	help
++	   Say Y here to include support for the watchdog timer found on
++	   Marvell Armada 37xx SoCs.
++	   To compile this driver as a module, choose M here: the
++	   module will be called armada_37xx_wdt.
++
+ config ASM9260_WATCHDOG
+ 	tristate "Alphascale ASM9260 watchdog"
+ 	depends on MACH_ASM9260 || COMPILE_TEST
+diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
+index 715a21078e0c..eae72c5fa1e0 100644
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -38,6 +38,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
+ # ARM Architecture
+ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
+ obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
++obj-$(CONFIG_ARMADA_37XX_WATCHDOG) += armada_37xx_wdt.o
+ obj-$(CONFIG_ASM9260_WATCHDOG) += asm9260_wdt.o
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+diff --git a/drivers/watchdog/armada_37xx_wdt.c b/drivers/watchdog/armada_37xx_wdt.c
+new file mode 100644
+index 000000000000..4b4054f54df9
+--- /dev/null
++++ b/drivers/watchdog/armada_37xx_wdt.c
+@@ -0,0 +1,388 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Watchdog driver for Marvell Armada 37xx SoCs
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/types.h>
++#include <linux/watchdog.h>
++
++/*
++ * There are four counters that can be used for watchdog on Armada 37xx.
++ * The addresses for counter control registers are register base plus ID*0x10,
++ * where ID is 0, 1, 2 or 3.
++ *
++ * In this driver we use IDs 0 and 1. Counter ID 1 is used as watchdog counter,
++ * while counter ID 0 is used to implement pinging the watchdog: counter ID 1 is
++ * set to restart counting from initial value on counter ID 0 end count event.
++ * Pinging is done by forcing immediate end count event on counter ID 0.
++ * If only one counter was used, pinging would have to be implemented by
++ * disabling and enabling the counter, leaving the system in a vulnerable state
++ * for a (really) short period of time.
++ *
++ * Counters ID 2 and 3 are enabled by default even before U-Boot loads,
++ * therefore this driver does not provide a way to use them, eg. by setting a
++ * property in device tree.
++ */
++
++#define CNTR_ID_RETRIGGER		0
++#define CNTR_ID_WDOG			1
++
++/* relative to cpu_misc */
++#define WDT_TIMER_SELECT		0x64
++#define WDT_TIMER_SELECT_MASK		0xf
++#define WDT_TIMER_SELECT_VAL		BIT(CNTR_ID_WDOG)
++
++/* relative to reg */
++#define CNTR_CTRL(id)			((id) * 0x10)
++#define CNTR_CTRL_ENABLE		0x0001
++#define CNTR_CTRL_ACTIVE		0x0002
++#define CNTR_CTRL_MODE_MASK		0x000c
++#define CNTR_CTRL_MODE_ONESHOT		0x0000
++#define CNTR_CTRL_MODE_HWSIG		0x000c
++#define CNTR_CTRL_TRIG_SRC_MASK		0x00f0
++#define CNTR_CTRL_TRIG_SRC_PREV_CNTR	0x0050
++#define CNTR_CTRL_PRESCALE_MASK		0xff00
++#define CNTR_CTRL_PRESCALE_MIN		2
++#define CNTR_CTRL_PRESCALE_SHIFT	8
++
++#define CNTR_COUNT_LOW(id)		(CNTR_CTRL(id) + 0x4)
++#define CNTR_COUNT_HIGH(id)		(CNTR_CTRL(id) + 0x8)
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++struct armada_37xx_watchdog {
++	struct watchdog_device wdt;
++	struct regmap *cpu_misc;
++	void __iomem *reg;
++	u64 timeout; /* in clock ticks */
++	unsigned long clk_rate;
++	struct clk *clk;
++};
++
++static u64 get_counter_value(struct armada_37xx_watchdog *dev, int id)
++{
++	u64 val;
++
++	/*
++	 * when low is read, high is latched into flip-flops so that it can be
++	 * read consistently without using software debouncing
++	 */
++	val = readl(dev->reg + CNTR_COUNT_LOW(id));
++	val |= ((u64)readl(dev->reg + CNTR_COUNT_HIGH(id))) << 32;
++
++	return val;
++}
++
++static void set_counter_value(struct armada_37xx_watchdog *dev, int id, u64 val)
++{
++	writel(val & 0xffffffff, dev->reg + CNTR_COUNT_LOW(id));
++	writel(val >> 32, dev->reg + CNTR_COUNT_HIGH(id));
++}
++
++static void counter_enable(struct armada_37xx_watchdog *dev, int id)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++	reg |= CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static void counter_disable(struct armada_37xx_watchdog *dev, int id)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++	reg &= ~CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static void init_counter(struct armada_37xx_watchdog *dev, int id, u32 mode,
++			 u32 trig_src)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++
++	reg &= ~(CNTR_CTRL_MODE_MASK | CNTR_CTRL_PRESCALE_MASK |
++		 CNTR_CTRL_TRIG_SRC_MASK);
++
++	/* set mode */
++	reg |= mode & CNTR_CTRL_MODE_MASK;
++
++	/* set prescaler to the min value */
++	reg |= CNTR_CTRL_PRESCALE_MIN << CNTR_CTRL_PRESCALE_SHIFT;
++
++	/* set trigger source */
++	reg |= trig_src & CNTR_CTRL_TRIG_SRC_MASK;
++
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static int armada_37xx_wdt_ping(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	/* counter 1 is retriggered by forcing end count on counter 0 */
++	counter_disable(dev, CNTR_ID_RETRIGGER);
++	counter_enable(dev, CNTR_ID_RETRIGGER);
++
++	return 0;
++}
++
++static unsigned int armada_37xx_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	u64 res;
++
++	res = get_counter_value(dev, CNTR_ID_WDOG) * CNTR_CTRL_PRESCALE_MIN;
++	do_div(res, dev->clk_rate);
++
++	return res;
++}
++
++static int armada_37xx_wdt_set_timeout(struct watchdog_device *wdt,
++				       unsigned int timeout)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	wdt->timeout = timeout;
++
++	/*
++	 * Compute the timeout in clock rate. We use smallest possible
++	 * prescaler, which divides the clock rate by 2
++	 * (CNTR_CTRL_PRESCALE_MIN).
++	 */
++	dev->timeout = (u64)dev->clk_rate * timeout;
++	do_div(dev->timeout, CNTR_CTRL_PRESCALE_MIN);
++
++	return 0;
++}
++
++static bool armada_37xx_wdt_is_running(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	regmap_read(dev->cpu_misc, WDT_TIMER_SELECT, &reg);
++	if ((reg & WDT_TIMER_SELECT_MASK) != WDT_TIMER_SELECT_VAL)
++		return false;
++
++	reg = readl(dev->reg + CNTR_CTRL(CNTR_ID_WDOG));
++	return !!(reg & CNTR_CTRL_ACTIVE);
++}
++
++static int armada_37xx_wdt_start(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	/* select counter 1 as watchdog counter */
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, WDT_TIMER_SELECT_VAL);
++
++	/* init counter 0 as retrigger counter for counter 1 */
++	init_counter(dev, CNTR_ID_RETRIGGER, CNTR_CTRL_MODE_ONESHOT, 0);
++	set_counter_value(dev, CNTR_ID_RETRIGGER, 0);
++
++	/* init counter 1 to be retriggerable by counter 0 end count */
++	init_counter(dev, CNTR_ID_WDOG, CNTR_CTRL_MODE_HWSIG,
++		     CNTR_CTRL_TRIG_SRC_PREV_CNTR);
++	set_counter_value(dev, CNTR_ID_WDOG, dev->timeout);
++
++	/* enable counter 1 */
++	counter_enable(dev, CNTR_ID_WDOG);
++
++	/* start counter 1 by forcing immediate end count on counter 0 */
++	counter_enable(dev, CNTR_ID_RETRIGGER);
++
++	return 0;
++}
++
++static int armada_37xx_wdt_stop(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	counter_disable(dev, CNTR_ID_WDOG);
++	counter_disable(dev, CNTR_ID_RETRIGGER);
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, 0);
++
++	return 0;
++}
++
++static const struct watchdog_info armada_37xx_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Armada 37xx Watchdog",
++};
++
++static const struct watchdog_ops armada_37xx_wdt_ops = {
++	.owner = THIS_MODULE,
++	.start = armada_37xx_wdt_start,
++	.stop = armada_37xx_wdt_stop,
++	.ping = armada_37xx_wdt_ping,
++	.set_timeout = armada_37xx_wdt_set_timeout,
++	.get_timeleft = armada_37xx_wdt_get_timeleft,
++};
++
++static int armada_37xx_wdt_probe(struct platform_device *pdev)
++{
++	struct armada_37xx_watchdog *dev;
++	struct resource *res;
++	struct regmap *regmap;
++	int ret;
++
++	dev = devm_kzalloc(&pdev->dev, sizeof(struct armada_37xx_watchdog),
++			   GFP_KERNEL);
++	if (!dev)
++		return -ENOMEM;
++
++	dev->wdt.info = &armada_37xx_wdt_info;
++	dev->wdt.ops = &armada_37xx_wdt_ops;
++
++	regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
++						 "marvell,system-controller");
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++	dev->cpu_misc = regmap;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENODEV;
++	dev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++
++	/* init clock */
++	dev->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(dev->clk))
++		return PTR_ERR(dev->clk);
++
++	ret = clk_prepare_enable(dev->clk);
++	if (ret)
++		return ret;
++
++	dev->clk_rate = clk_get_rate(dev->clk);
++	if (!dev->clk_rate) {
++		ret = -EINVAL;
++		goto disable_clk;
++	}
++
++	/*
++	 * Since the timeout in seconds is given as 32 bit unsigned int, and
++	 * the counters hold 64 bit values, even after multiplication by clock
++	 * rate the counter can hold timeout of UINT_MAX seconds.
++	 */
++	dev->wdt.min_timeout = 1;
++	dev->wdt.max_timeout = UINT_MAX;
++	dev->wdt.parent = &pdev->dev;
++
++	/* default value, possibly override by module parameter or dtb */
++	dev->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
++
++	platform_set_drvdata(pdev, &dev->wdt);
++	watchdog_set_drvdata(&dev->wdt, dev);
++
++	armada_37xx_wdt_set_timeout(&dev->wdt, dev->wdt.timeout);
++
++	if (armada_37xx_wdt_is_running(dev))
++		set_bit(WDOG_HW_RUNNING, &dev->wdt.status);
++
++	watchdog_set_nowayout(&dev->wdt, nowayout);
++	ret = watchdog_register_device(&dev->wdt);
++	if (ret)
++		goto disable_clk;
++
++	dev_info(&pdev->dev, "Initial timeout %d sec%s\n",
++		 dev->wdt.timeout, nowayout ? ", nowayout" : "");
++
++	return 0;
++
++disable_clk:
++	clk_disable_unprepare(dev->clk);
++	return ret;
++}
++
++static int armada_37xx_wdt_remove(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	watchdog_unregister_device(wdt);
++	clk_disable_unprepare(dev->clk);
++	return 0;
++}
++
++static void armada_37xx_wdt_shutdown(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++
++	armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_suspend(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	return armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_resume(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(wdt))
++		return armada_37xx_wdt_start(wdt);
++
++	return 0;
++}
++
++static const struct dev_pm_ops armada_37xx_wdt_dev_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(armada_37xx_wdt_suspend,
++				armada_37xx_wdt_resume)
++};
++
++#ifdef CONFIG_OF
++static const struct of_device_id armada_37xx_wdt_match[] = {
++	{ .compatible = "marvell,armada-3700-wdt", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, armada_37xx_wdt_match);
++#endif
++
++static struct platform_driver armada_37xx_wdt_driver = {
++	.probe		= armada_37xx_wdt_probe,
++	.remove		= armada_37xx_wdt_remove,
++	.shutdown	= armada_37xx_wdt_shutdown,
++	.driver		= {
++		.name	= "armada_37xx_wdt",
++		.of_match_table = of_match_ptr(armada_37xx_wdt_match),
++		.pm = &armada_37xx_wdt_dev_pm_ops,
++	},
++};
++
++module_platform_driver(armada_37xx_wdt_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Armada 37xx CPU Watchdog");
++
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:armada_37xx_wdt");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch b/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch
new file mode 100644
index 0000000..bc958df
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch
@@ -0,0 +1,52 @@
+From 3d324b197a937ea27149f8e7808950ec2d7558dc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:49:24 +0200
+Subject: [PATCH 118/127] dt-bindings: watchdog: Document armada-37xx-wdt
+ binding
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds device tree binding documentation for the CPU watchdog found
+on Armada 37xx SOCs (EspressoBin, Turris Mox).
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+Cc: Rob Herring <robh+dt@kernel.org>
+Cc: devicetree@vger.kernel.org
+---
+ .../bindings/watchdog/armada-37xx-wdt.txt     | 23 +++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+
+diff --git a/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+new file mode 100644
+index 000000000000..a8d00c31a1d8
+--- /dev/null
++++ b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+@@ -0,0 +1,23 @@
++* Armada 37xx CPU Watchdog Timer Controller
++
++Required properties:
++- compatible : must be "marvell,armada-3700-wdt"
++- reg : base physical address of the controller and length of memory mapped
++	region.
++- clocks : the clock feeding the watchdog timer. See clock-bindings.txt
++- marvell,system-controller : reference to syscon node for the CPU Miscellaneous
++	Registers
++
++Example:
++
++	cpu_misc: system-controller@d000 {
++		compatible = "marvell,armada-3700-cpu-misc", "syscon";
++		reg = <0xd000 0x1000>;
++	};
++
++	wdt: watchdog@8300 {
++		compatible = "marvell,armada-3700-wdt";
++		reg = <0x8300 0x40>;
++		marvell,system-controller = <&cpu_misc>;
++		clocks = <&xtalclk>;
++	};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch b/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch
new file mode 100644
index 0000000..ab699c6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch
@@ -0,0 +1,37 @@
+From 24003e346a2216b681081fd04a3326dd7b38a465 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:53:00 +0200
+Subject: [PATCH 119/127] documentation: watchdog: add documentation for
+ armada-37xx-wdt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add documentation for the kernel module parameters accepted by
+armada-37xx-wdt.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+Reviewed-by: Guenter Roeck <linux@roeck-us.net>
+---
+ Documentation/watchdog/watchdog-parameters.txt | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/Documentation/watchdog/watchdog-parameters.txt b/Documentation/watchdog/watchdog-parameters.txt
+index 6f9d7b418917..d322a907d231 100644
+--- a/Documentation/watchdog/watchdog-parameters.txt
++++ b/Documentation/watchdog/watchdog-parameters.txt
+@@ -45,6 +45,11 @@ timeout: Timeout value. Limited to be 1 or 2 seconds. (default=2)
+ nowayout: Watchdog cannot be stopped once started
+ 	(default=kernel config parameter)
+ -------------------------------------------------
++armada_37xx_wdt:
++timeout: Watchdog timeout in seconds. (default=120)
++nowayout: Disable watchdog shutdown on close
++	(default=kernel config parameter)
++-------------------------------------------------
+ at91rm9200_wdt:
+ wdt_time: Watchdog time in seconds. (default=5)
+ nowayout: Watchdog cannot be stopped once started
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch b/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
new file mode 100644
index 0000000..363b672
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
@@ -0,0 +1,44 @@
+From cd2c543d7c18dbd47844558330fc68f3cd280b36 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:54:41 +0200
+Subject: [PATCH 120/127] arm64: dts: marvell: armada-37xx: add nodes to
+ support watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds the system controller node for CPU Miscellaneous Registers
+(which is needed for the watchdog node) and the watchdog node.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 783fbb7f3b47..70378339ab5b 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -101,6 +101,19 @@
+ 			/* 32M internal register @ 0xd000_0000 */
+ 			ranges = <0x0 0x0 0xd0000000 0x2000000>;
+ 
++			wdt: watchdog@8300 {
++				compatible = "marvell,armada-3700-wdt";
++				reg = <0x8300 0x40>;
++				marvell,system-controller = <&cpu_misc>;
++				clocks = <&xtalclk>;
++			};
++
++			cpu_misc: system-controller@d000 {
++				compatible = "marvell,armada-3700-cpu-misc",
++					     "syscon";
++				reg = <0xd000 0x1000>;
++			};
++
+ 			spi0: spi@10600 {
+ 				compatible = "marvell,armada-3700-spi";
+ 				#address-cells = <1>;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch b/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch
new file mode 100644
index 0000000..5f7f8eb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch
@@ -0,0 +1,121 @@
+From 96d797e5903817474c467140f2e01e9736934693 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 24 Oct 2018 16:55:11 +0200
+Subject: [PATCH 121/127] PCI: aadrvark: warm reset the cores and card
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add code to do a warm reset on the PHY and PCIE cores and if PERSTN GPIO
+is specified in device tree (as reset-gpio), also reset the card.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ drivers/pci/host/pci-aardvark.c | 46 +++++++++++++++++++++++++++++++--
+ 1 file changed, 44 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 50e8addc22f9..ccce013bbef8 100644
+--- a/drivers/pci/host/pci-aardvark.c
++++ b/drivers/pci/host/pci-aardvark.c
+@@ -21,6 +21,7 @@
+ #include <linux/platform_device.h>
+ #include <linux/of_address.h>
+ #include <linux/of_pci.h>
++#include <linux/of_gpio.h>
+ 
+ /* PCIe core registers */
+ #define PCIE_CORE_CMD_STATUS_REG				0x4
+@@ -147,6 +148,9 @@
+ #define     CTRL_MODE_MASK			0x1
+ #define     PCIE_CORE_MODE_DIRECT		0x0
+ #define     PCIE_CORE_MODE_COMMAND		0x1
++#define CTRL_WARM_RESET_REG			(CTRL_CORE_BASE_ADDR + 0x4)
++#define     CTRL_PCIE_CORE_WARM_RESET		BIT(0)
++#define     CTRL_PHY_CORE_WARM_RESET		BIT(1)
+ 
+ /* PCIe Central Interrupts Registers */
+ #define CENTRAL_INT_BASE_ADDR			0x1b000
+@@ -270,8 +274,25 @@ static void advk_pcie_set_ob_win(struct advk_pcie *pcie,
+ 	advk_writel(pcie, match_ls | BIT(0), OB_WIN_MATCH_LS(win_num));
+ }
+ 
++static void advk_pcie_warm_reset(struct advk_pcie *pcie)
++{
++	u32 reg;
++
++	reg = advk_readl(pcie, CTRL_WARM_RESET_REG);
++	reg |= CTRL_PCIE_CORE_WARM_RESET | CTRL_PHY_CORE_WARM_RESET;
++	advk_writel(pcie, reg, CTRL_WARM_RESET_REG);
++
++	mdelay(100);
++
++	reg = advk_readl(pcie, CTRL_WARM_RESET_REG);
++	reg &= ~(CTRL_PCIE_CORE_WARM_RESET | CTRL_PHY_CORE_WARM_RESET);
++	advk_writel(pcie, reg, CTRL_WARM_RESET_REG);
++}
++
+ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ {
++	struct device *dev = &pcie->pdev->dev;
++	struct device_node *node = dev->of_node;
+ 	u32 reg;
+ 	int i;
+ 
+@@ -311,10 +332,15 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ 		PCIE_CORE_CTRL2_TD_ENABLE;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+ 
+-	/* Set GEN2 */
++	/* Set GEN */
+ 	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+ 	reg &= ~PCIE_GEN_SEL_MSK;
+-	reg |= SPEED_GEN_2;
++	if (of_pci_get_max_link_speed(node) == 1)
++		reg |= SPEED_GEN_1;
++	if (of_pci_get_max_link_speed(node) == 3)
++		reg |= SPEED_GEN_3;
++	else
++		reg |= SPEED_GEN_2;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+ 
+ 	/* Set lane X1 */
+@@ -948,6 +974,8 @@ static int advk_pcie_probe(struct platform_device *pdev)
+ 	struct pci_bus *bus, *child;
+ 	struct pci_host_bridge *bridge;
+ 	int ret, irq;
++	int reset_gpio;
++	enum of_gpio_flags flags;
+ 
+ 	bridge = devm_pci_alloc_host_bridge(dev, sizeof(struct advk_pcie));
+ 	if (!bridge)
+@@ -970,12 +998,26 @@ static int advk_pcie_probe(struct platform_device *pdev)
+ 		return ret;
+ 	}
+ 
++	advk_pcie_warm_reset(pcie);
++
+ 	ret = advk_pcie_parse_request_of_pci_ranges(pcie);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to parse resources\n");
+ 		return ret;
+ 	}
+ 
++	/* Config reset gpio for pcie if there is valid gpio setting in DTS */
++	reset_gpio = of_get_named_gpio_flags(pdev->dev.of_node, "reset-gpio",
++					     0, &flags);
++	if (gpio_is_valid(reset_gpio)) {
++		struct gpio_desc *reset_gpiod;
++		reset_gpiod = gpio_to_desc(reset_gpio);
++		gpiod_direction_output(reset_gpiod, 0);
++		mdelay(200);
++		gpiod_direction_output(reset_gpiod, 1);
++		mdelay(200);
++	}
++
+ 	advk_pcie_setup_hw(pcie);
+ 
+ 	ret = advk_pcie_init_irq_domain(pcie);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch b/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch
new file mode 100644
index 0000000..aa8bbb6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch
@@ -0,0 +1,328 @@
+From 9d79a3d17da4a7a3a9ce2127a0ab9855e8b0ce63 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:17:35 +0100
+Subject: [PATCH 122/127] mailbox: Add support for Armada 37xx rWTM mailbox
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for the mailbox via which the kernel can communicate
+with the firmware running on the secure processor of the Armada 37xx
+SOC.
+
+The rWTM secure processor has access to internal eFuses and
+cryptographic circuits, such as the Entropy Bit Generator to generate
+true random numbers.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ drivers/mailbox/Kconfig                    |  10 +
+ drivers/mailbox/Makefile                   |   2 +
+ drivers/mailbox/armada-37xx-rwtm-mailbox.c | 230 +++++++++++++++++++++
+ include/linux/armada-37xx-rwtm-mailbox.h   |  23 +++
+ 4 files changed, 265 insertions(+)
+ create mode 100644 drivers/mailbox/armada-37xx-rwtm-mailbox.c
+ create mode 100644 include/linux/armada-37xx-rwtm-mailbox.h
+
+diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
+index c5731e5e3c6c..6b0cfe37558f 100644
+--- a/drivers/mailbox/Kconfig
++++ b/drivers/mailbox/Kconfig
+@@ -35,6 +35,16 @@ config PL320_MBOX
+ 	  Management Engine, primarily for cpufreq. Say Y here if you want
+ 	  to use the PL320 IPCM support.
+ 
++config ARMADA_37XX_RWTM_MBOX
++	tristate "Armada 37xx rWTM BIU Mailbox"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	depends on OF
++	help
++	  Mailbox implementation for communication with the the firmware
++	  running on the Cortex-M3 rWTM secure processor of the Armada 37xx
++	  SOC. Say Y here if you are building for such a device (for example
++	  the Turris Mox router).
++
+ config OMAP2PLUS_MBOX
+ 	tristate "OMAP2+ Mailbox framework support"
+ 	depends on ARCH_OMAP2PLUS
+diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
+index 4896f8dcae95..4aebeac2a6bd 100644
+--- a/drivers/mailbox/Makefile
++++ b/drivers/mailbox/Makefile
+@@ -7,6 +7,8 @@ obj-$(CONFIG_MAILBOX_TEST)	+= mailbox-test.o
+ 
+ obj-$(CONFIG_ARM_MHU)	+= arm_mhu.o
+ 
++obj-$(CONFIG_ARMADA_37XX_RWTM_MBOX)	+= armada-37xx-rwtm-mailbox.o
++
+ obj-$(CONFIG_PLATFORM_MHU)	+= platform_mhu.o
+ 
+ obj-$(CONFIG_PL320_MBOX)	+= pl320-ipc.o
+diff --git a/drivers/mailbox/armada-37xx-rwtm-mailbox.c b/drivers/mailbox/armada-37xx-rwtm-mailbox.c
+new file mode 100644
+index 000000000000..483a16d312cc
+--- /dev/null
++++ b/drivers/mailbox/armada-37xx-rwtm-mailbox.c
+@@ -0,0 +1,230 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * rWTM BIU Mailbox driver for Armada 37xx
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/device.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mailbox_controller.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/armada-37xx-rwtm-mailbox.h>
++
++#define DRIVER_NAME	"armada-37xx-rwtm-mailbox"
++
++/* relative to rWTM BIU Mailbox Registers */
++#define RWTM_MBOX_PARAM(i)		(0x0 + ((i) << 2))
++#define RWTM_MBOX_COMMAND		0x40
++#define RWTM_MBOX_RETURN_STATUS		0x80
++#define RWTM_MBOX_STATUS(i)		(0x84 + ((i) << 2))
++#define RWTM_MBOX_FIFO_STATUS		0xc4
++#define FIFO_STS_RDY			0x100
++#define FIFO_STS_CNTR_MASK		0x7
++#define FIFO_STS_CNTR_MAX		4
++
++#define RWTM_HOST_INT_RESET		0xc8
++#define RWTM_HOST_INT_MASK		0xcc
++#define SP_CMD_COMPLETE			BIT(0)
++#define SP_CMD_QUEUE_FULL_ACCESS	BIT(17)
++#define SP_CMD_QUEUE_FULL		BIT(18)
++
++
++struct a37xx_mbox {
++	struct device *dev;
++	struct mbox_controller controller;
++	void __iomem *base;
++	int irq;
++};
++
++static void a37xx_mbox_receive(struct mbox_chan *chan)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	struct armada_37xx_rwtm_rx_msg rx_msg;
++	int i;
++
++	rx_msg.retval = readl(mbox->base + RWTM_MBOX_RETURN_STATUS);
++	for (i = 0; i < 16; ++i)
++		rx_msg.status[i] = readl(mbox->base + RWTM_MBOX_STATUS(i));
++
++	mbox_chan_received_data(chan, &rx_msg);
++}
++
++static irqreturn_t a37xx_mbox_irq_handler(int irq, void *data)
++{
++	struct mbox_chan *chan = data;
++	struct a37xx_mbox *mbox = chan->con_priv;
++	u32 reg;
++
++	reg = readl(mbox->base + RWTM_HOST_INT_RESET);
++
++	if (reg & SP_CMD_COMPLETE)
++		a37xx_mbox_receive(chan);
++
++	if (reg & (SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL))
++		dev_err(mbox->dev, "Secure processor command queue full\n");
++
++	writel(reg, mbox->base + RWTM_HOST_INT_RESET);
++	if (reg)
++		mbox_chan_txdone(chan, 0);
++
++	return reg ? IRQ_HANDLED : IRQ_NONE;
++}
++
++static int a37xx_mbox_send_data(struct mbox_chan *chan, void *data)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	struct armada_37xx_rwtm_tx_msg *msg = data;
++	int i;
++	u32 reg;
++
++	if (!data)
++		return -EINVAL;
++
++	reg = readl(mbox->base + RWTM_MBOX_FIFO_STATUS);
++	if (!(reg & FIFO_STS_RDY)) {
++		dev_err(mbox->dev, "Secure processor not ready\n");
++		return -EAGAIN;
++	}
++
++	if ((reg & FIFO_STS_CNTR_MASK) >= FIFO_STS_CNTR_MAX) {
++		dev_err(mbox->dev, "Secure processor command queue full\n");
++		return -EBUSY;
++	}
++
++	for (i = 0; i < 16; ++i)
++		writel(msg->args[i], mbox->base + RWTM_MBOX_PARAM(i));
++	writel(msg->command, mbox->base + RWTM_MBOX_COMMAND);
++
++	return 0;
++}
++
++static int a37xx_mbox_startup(struct mbox_chan *chan)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	u32 reg;
++	int ret;
++
++	ret = devm_request_irq(mbox->dev, mbox->irq, a37xx_mbox_irq_handler, 0,
++			       DRIVER_NAME, chan);
++	if (ret < 0) {
++		dev_err(mbox->dev, "Cannot request irq\n");
++		return ret;
++	}
++
++	dev_info(mbox->dev, "Trust Status: %08x\n", readl(mbox->base + 0xd4));
++
++	/* enable IRQ generation */
++	reg = readl(mbox->base + RWTM_HOST_INT_MASK);
++	reg &= ~(SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL);
++	writel(reg, mbox->base + RWTM_HOST_INT_MASK);
++
++	return 0;
++}
++
++static void a37xx_mbox_shutdown(struct mbox_chan *chan)
++{
++	u32 reg;
++	struct a37xx_mbox *mbox = chan->con_priv;
++
++	/* disable interrupt generation */
++	reg = readl(mbox->base + RWTM_HOST_INT_MASK);
++	reg |= SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL;
++	writel(reg, mbox->base + RWTM_HOST_INT_MASK);
++
++	devm_free_irq(mbox->dev, mbox->irq, chan);
++}
++
++static const struct mbox_chan_ops a37xx_mbox_ops = {
++	.send_data	= a37xx_mbox_send_data,
++	.startup	= a37xx_mbox_startup,
++	.shutdown	= a37xx_mbox_shutdown,
++};
++
++static int armada_37xx_mbox_probe(struct platform_device *pdev)
++{
++	struct a37xx_mbox *mbox;
++	struct resource *regs;
++	struct mbox_chan *chans;
++	int ret;
++
++	mbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);
++	if (!mbox)
++		return -ENOMEM;
++
++	/* Allocated one channel */
++	chans = devm_kzalloc(&pdev->dev, sizeof(*chans), GFP_KERNEL);
++	if (!chans)
++		return -ENOMEM;
++
++	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	mbox->base = devm_ioremap_resource(&pdev->dev, regs);
++	if (IS_ERR(mbox->base)) {
++		dev_err(&pdev->dev, "ioremap failed\n");
++		return PTR_ERR(mbox->base);
++	}
++
++	mbox->irq = platform_get_irq(pdev, 0);
++	if (mbox->irq < 0) {
++		dev_err(&pdev->dev, "Cannot get irq\n");
++		return mbox->irq;
++	}
++
++	mbox->dev = &pdev->dev;
++
++	/* Hardware supports only one channel. */
++	chans[0].con_priv = mbox;
++	mbox->controller.dev = mbox->dev;
++	mbox->controller.num_chans = 1;
++	mbox->controller.chans = chans;
++	mbox->controller.ops = &a37xx_mbox_ops;
++	mbox->controller.txdone_irq = true;
++
++	ret = mbox_controller_register(&mbox->controller);
++	if (ret) {
++		dev_err(&pdev->dev, "Could not register mailbox controller\n");
++		return ret;
++	}
++
++	platform_set_drvdata(pdev, mbox);
++	return ret;
++}
++
++static int armada_37xx_mbox_remove(struct platform_device *pdev)
++{
++	struct a37xx_mbox *mbox = platform_get_drvdata(pdev);
++
++	if (!mbox)
++		return -EINVAL;
++
++	mbox_controller_unregister(&mbox->controller);
++
++	return 0;
++}
++
++static const struct of_device_id armada_37xx_mbox_match[] = {
++	{ .compatible = "marvell,armada-37xx-rwtm-mailbox" },
++	{ },
++};
++
++MODULE_DEVICE_TABLE(of, armada_37xx_mbox_match);
++
++static struct platform_driver armada_37xx_mbox_driver = {
++	.probe	= armada_37xx_mbox_probe,
++	.remove	= armada_37xx_mbox_remove,
++	.driver	= {
++		.name		= DRIVER_NAME,
++		.of_match_table	= armada_37xx_mbox_match,
++	},
++};
++
++module_platform_driver(armada_37xx_mbox_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("rWTM BIU Mailbox driver for Armada 37xx");
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
+diff --git a/include/linux/armada-37xx-rwtm-mailbox.h b/include/linux/armada-37xx-rwtm-mailbox.h
+new file mode 100644
+index 000000000000..57bb54f6767a
+--- /dev/null
++++ b/include/linux/armada-37xx-rwtm-mailbox.h
+@@ -0,0 +1,23 @@
++/* SPDX-License-Identifier: GPL-2.0+ */
++/*
++ * rWTM BIU Mailbox driver for Armada 37xx
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#ifndef _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_
++#define _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_
++
++#include <linux/types.h>
++
++struct armada_37xx_rwtm_tx_msg {
++	u16 command;
++	u32 args[16];
++};
++
++struct armada_37xx_rwtm_rx_msg {
++	u32 retval;
++	u32 status[16];
++};
++
++#endif /* _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_ */
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch b/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch
new file mode 100644
index 0000000..cfbe64f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch
@@ -0,0 +1,38 @@
+From a29a9e62c9bad5b868f78e4ee80292abcc40c76a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:21:44 +0100
+Subject: [PATCH 123/127] arm64: dts: marvell: armada37xx: add rWTM mailbox
+ node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds node for the rWTM mailbox. rWTM is a Cortex-M3 processor on
+the Armada 37xx SOC used for security purposes.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 70378339ab5b..72b38abbff31 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -335,6 +335,13 @@
+ 				clocks = <&nb_periph_clk 15>;
+ 			};
+ 
++			rwtm: mailbox@b0000 {
++				compatible = "marvell,armada-37xx-rwtm-mailbox";
++				reg = <0xb0000 0x100>;
++				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
++				#mbox-cells = <1>;
++			};
++
+ 			sdhci1: sdhci@d0000 {
+ 				compatible = "marvell,armada-3700-sdhci",
+ 					     "marvell,sdhci-xenon";
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch b/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch
new file mode 100644
index 0000000..5625f96
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch
@@ -0,0 +1,454 @@
+From 30ed67c5a721bd7c0967a6fee472d14fb056d306 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:23:05 +0100
+Subject: [PATCH 124/127] crypto: Add Turris Mox rWTM firmware driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds a driver to communicate with the firmware running on the
+secure processor of the Turris Mox router, enabling the kernel to
+retrieve true random numbers from the Entropy Bit Generator and to
+sign messages with the ECDSA private key burned into each Turris Mox
+device.
+
+This also adds support to read the device serial number and other
+manufacturing information.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ drivers/crypto/Kconfig           |  15 ++
+ drivers/crypto/Makefile          |   1 +
+ drivers/crypto/turris-mox-rwtm.c | 382 +++++++++++++++++++++++++++++++
+ 3 files changed, 398 insertions(+)
+ create mode 100644 drivers/crypto/turris-mox-rwtm.c
+
+diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
+index 342bc777841c..c57ca4b00103 100644
+--- a/drivers/crypto/Kconfig
++++ b/drivers/crypto/Kconfig
+@@ -709,6 +709,21 @@ config CRYPTO_DEV_SAFEXCEL
+ 	  chain mode, AES cipher mode and SHA1/SHA224/SHA256/SHA512 hash
+ 	  algorithms.
+ 
++config CRYPTO_DEV_TURRIS_MOX_RWTM
++	tristate "Turris Mox rWTM secure firmware driver"
++	depends on HAS_DMA && OF
++	depends on MAILBOX
++	select HW_RANDOM
++	select CRYPTO_AKCIPHER
++	select ARMADA_37XX_RWTM_MBOX
++	help
++	  This driver communicates with the firmware on the Cortex-M3 secure
++	  processor of the Turris Mox router. Enable if you are building for
++	  Turris Mox, and you will be able to read the serial number and
++	  other manufacturing data, sign messages with the internal ECDSA-521
++	  private key and utilize the Entropy Bit Generator as hardware random
++	  number generator.
++
+ config CRYPTO_DEV_ARTPEC6
+ 	tristate "Support for Axis ARTPEC-6/7 hardware crypto acceleration."
+ 	depends on ARM && (ARCH_ARTPEC || COMPILE_TEST)
+diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
+index c00708d04be6..7d3dde966e2d 100644
+--- a/drivers/crypto/Makefile
++++ b/drivers/crypto/Makefile
+@@ -40,6 +40,7 @@ obj-$(CONFIG_CRYPTO_DEV_SAHARA) += sahara.o
+ obj-$(CONFIG_ARCH_STM32) += stm32/
+ obj-$(CONFIG_CRYPTO_DEV_SUN4I_SS) += sunxi-ss/
+ obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
++obj-$(CONFIG_CRYPTO_DEV_TURRIS_MOX_RWTM) += turris-mox-rwtm.o
+ obj-$(CONFIG_CRYPTO_DEV_UX500) += ux500/
+ obj-$(CONFIG_CRYPTO_DEV_VIRTIO) += virtio/
+ obj-$(CONFIG_CRYPTO_DEV_VMX) += vmx/
+diff --git a/drivers/crypto/turris-mox-rwtm.c b/drivers/crypto/turris-mox-rwtm.c
+new file mode 100644
+index 000000000000..212337293b38
+--- /dev/null
++++ b/drivers/crypto/turris-mox-rwtm.c
+@@ -0,0 +1,382 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Turris Mox rWTM firmware driver
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/armada-37xx-rwtm-mailbox.h>
++#include <linux/completion.h>
++#include <linux/dma-mapping.h>
++#include <linux/hw_random.h>
++#include <linux/mailbox_client.h>
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++
++#define DRIVER_NAME		"turris-mox-rwtm"
++
++#define MBOX_STS_SUCCESS	(0 << 30)
++#define MBOX_STS_FAIL		(1 << 30)
++#define MBOX_STS_BADCMD		(2 << 30)
++#define MBOX_STS_ERROR(s)	((s) & (3 << 30))
++#define MBOX_STS_VALUE(s)	(((s) >> 10) & 0xfffff)
++#define MBOX_STS_CMD(s)		((s) & 0x3ff)
++
++enum mbox_cmd {
++	MBOX_CMD_GET_RANDOM	= 1,
++	MBOX_CMD_BOARD_INFO,
++	MBOX_CMD_ECDSA_PUB_KEY,
++	MBOX_CMD_HASH,
++	MBOX_CMD_SIGN,
++	MBOX_CMD_VERIFY,
++
++	MBOX_CMD_OTP_READ,
++	MBOX_CMD_OTP_WRITE
++};
++
++struct mox_rwtm {
++	struct device *dev;
++	void *buf;
++	dma_addr_t buf_phys;
++	struct mbox_client mbox_client;
++	struct mbox_chan *mbox;
++	struct mutex busy;
++	struct completion cmd_done;
++	struct armada_37xx_rwtm_rx_msg reply;
++	struct hwrng hwrng;
++
++	/* board information */
++	u64 serial_number;
++	int board_version, ram_size;
++	u8 mac_address1[6], mac_address2[6];
++	u8 pubkey[135];
++	u8 last_sig[136];
++	int last_sig_done;
++};
++
++#define MOX_ATTR(name, format)						\
++static ssize_t								\
++mox_##name##_show(struct device *dev, struct device_attribute *a,	\
++		  char *buf)						\
++{									\
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);			\
++	return sprintf(buf, format, rwtm->name);			\
++}									\
++static DEVICE_ATTR_RO(mox_##name);
++
++MOX_ATTR(serial_number, "%016llX\n");
++MOX_ATTR(board_version, "%i\n");
++MOX_ATTR(ram_size, "%i\n");
++MOX_ATTR(mac_address1, "%pM\n");
++MOX_ATTR(mac_address2, "%pM\n");
++MOX_ATTR(pubkey, "%s\n");
++
++static ssize_t
++mox_do_sign_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);
++
++	if (!rwtm->last_sig_done)
++		return -ENODATA;
++
++	rwtm->last_sig_done = 0;
++	memcpy(buf, rwtm->last_sig, 136);
++	return 136;
++}
++
++static void be32_to_cpu_array(u32 *buf, int n)
++{
++	for (; n > 0; --n, ++buf)
++		*buf = be32_to_cpu(*buf);
++}
++
++static void cpu_to_be32_array(u32 *buf, int n)
++{
++	for (; n > 0; --n, ++buf)
++		*buf = cpu_to_be32(*buf);
++}
++
++static ssize_t
++mox_do_sign_store(struct device *dev, struct device_attribute *a,
++		  const char *buf, size_t count)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);
++	struct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;
++	struct armada_37xx_rwtm_tx_msg msg;
++	int ret;
++
++	if (count != 64)
++		return -EINVAL;
++
++	if (rwtm->last_sig_done)
++		return -EBUSY;
++
++	if (!mutex_trylock(&rwtm->busy))
++		return -EBUSY;
++
++	memset(rwtm->buf, 0, 4);
++	memcpy(rwtm->buf + 4, buf, 64);
++	be32_to_cpu_array(rwtm->buf, 17);
++
++	msg.command = MBOX_CMD_SIGN;
++	msg.args[0] = 1;
++	msg.args[1] = rwtm->buf_phys;
++	msg.args[2] = rwtm->buf_phys + 68;
++	msg.args[3] = rwtm->buf_phys + 2 * 68;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = wait_for_completion_interruptible(&rwtm->cmd_done);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = MBOX_STS_VALUE(reply->retval);
++	if (MBOX_STS_ERROR(reply->retval) != MBOX_STS_SUCCESS)
++		goto unlock_mutex;
++
++	memcpy(rwtm->last_sig, rwtm->buf + 68, 136);
++	cpu_to_be32_array((u32 *) rwtm->last_sig, 34);
++	rwtm->last_sig_done = 1;
++
++	mutex_unlock(&rwtm->busy);
++	return count;
++unlock_mutex:
++	mutex_unlock(&rwtm->busy);
++	return ret;
++}
++
++static DEVICE_ATTR_RW(mox_do_sign);
++
++static struct attribute *mox_rwtm_attrs[] = {
++	&dev_attr_mox_serial_number.attr,
++	&dev_attr_mox_board_version.attr,
++	&dev_attr_mox_ram_size.attr,
++	&dev_attr_mox_mac_address1.attr,
++	&dev_attr_mox_mac_address2.attr,
++	&dev_attr_mox_pubkey.attr,
++	&dev_attr_mox_do_sign.attr,
++	NULL
++};
++ATTRIBUTE_GROUPS(mox_rwtm);
++
++static void mox_rwtm_rx_callback(struct mbox_client *cl, void *data)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(cl->dev);
++	struct armada_37xx_rwtm_rx_msg *msg = data;
++
++	rwtm->reply = *msg;
++	complete(&rwtm->cmd_done);
++}
++
++static int mox_get_status(enum mbox_cmd cmd, u32 retval)
++{
++	if (MBOX_STS_CMD(retval) != cmd ||
++	    MBOX_STS_ERROR(retval) != MBOX_STS_SUCCESS)
++		return -EIO;
++	else if (MBOX_STS_ERROR(retval) == MBOX_STS_FAIL)
++		return -(int)MBOX_STS_VALUE(retval);
++	else
++		return MBOX_STS_VALUE(retval);
++}
++
++static void reply_to_mac(u8 *mac, u32 t1, u32 t2)
++{
++	mac[0] = t1 >> 8;
++	mac[1] = t1;
++	mac[2] = t2 >> 24;
++	mac[3] = t2 >> 16;
++	mac[4] = t2 >> 8;
++	mac[5] = t2;
++}
++
++static int mox_board_info(struct mox_rwtm *rwtm)
++{
++	struct armada_37xx_rwtm_tx_msg msg;
++	struct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;
++	int ret;
++
++	msg.command = MBOX_CMD_BOARD_INFO;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		return ret;
++
++	ret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);
++	if (ret < 0)
++		return ret;
++
++	ret = mox_get_status(MBOX_CMD_BOARD_INFO, reply->retval);
++	if (ret < 0)
++		return ret;
++
++	rwtm->serial_number = reply->status[1];
++	rwtm->serial_number <<= 32;
++	rwtm->serial_number |= reply->status[0];
++	rwtm->board_version = reply->status[2];
++	rwtm->ram_size = reply->status[3];
++	reply_to_mac(rwtm->mac_address1, reply->status[4], reply->status[5]);
++	reply_to_mac(rwtm->mac_address2, reply->status[6], reply->status[7]);
++
++	pr_info("Turris Mox serial number %016llX\n", rwtm->serial_number);
++	pr_info("           board version %i\n", rwtm->board_version);
++	pr_info("           burned RAM size %i MiB\n", rwtm->ram_size);
++
++	msg.command = MBOX_CMD_ECDSA_PUB_KEY;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		return ret;
++
++	ret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);
++	if (ret < 0)
++		return ret;
++
++	ret = mox_get_status(MBOX_CMD_ECDSA_PUB_KEY, reply->retval);
++	if (ret < 0 && ret != -ENODATA) {
++		return ret;
++	} else if (ret == -ENODATA) {
++		strcpy(rwtm->pubkey, "none");
++	} else {
++		u32 *s = reply->status;
++		sprintf(rwtm->pubkey,
++			"%06x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x",
++			ret, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],
++			s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
++	}
++
++	return 0;
++}
++
++static int mox_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)
++{
++	struct mox_rwtm *rwtm = (struct mox_rwtm *) rng->priv;
++	struct armada_37xx_rwtm_tx_msg msg;
++	int ret;
++
++	if (max > 4096)
++		max = 4096;
++
++	msg.command = MBOX_CMD_GET_RANDOM;
++	msg.args[0] = 1;
++	msg.args[1] = rwtm->buf_phys;
++	msg.args[2] = (max + 3) & ~3;
++
++	if (!wait) {
++		if (!mutex_trylock(&rwtm->busy))
++			return -EBUSY;
++	} else {
++		mutex_lock(&rwtm->busy);
++	}
++
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = wait_for_completion_interruptible(&rwtm->cmd_done);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = mox_get_status(MBOX_CMD_GET_RANDOM, rwtm->reply.retval);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	memcpy(data, rwtm->buf, max);
++	ret = max;
++
++unlock_mutex:
++	mutex_unlock(&rwtm->busy);
++	return ret;
++}
++
++static int turris_mox_rwtm_probe(struct platform_device *pdev)
++{
++	struct mox_rwtm *rwtm;
++	struct device *dev = &pdev->dev;
++	int ret;
++
++	rwtm = devm_kzalloc(dev, sizeof(*rwtm), GFP_KERNEL);
++	if (!rwtm)
++		return -ENOMEM;
++
++	rwtm->dev = dev;
++	rwtm->buf = dmam_alloc_coherent(dev, PAGE_SIZE, &rwtm->buf_phys,
++					GFP_KERNEL);
++	if (!rwtm->buf)
++		return -ENOMEM;
++
++	ret = devm_device_add_groups(dev, mox_rwtm_groups);
++	if (ret < 0)
++		return ret;
++
++	platform_set_drvdata(pdev, rwtm);
++
++	mutex_init(&rwtm->busy);
++
++	rwtm->mbox_client.dev = dev;
++	rwtm->mbox_client.rx_callback = mox_rwtm_rx_callback;
++
++	rwtm->mbox = mbox_request_channel(&rwtm->mbox_client, 0);
++	if (IS_ERR(rwtm->mbox)) {
++		ret = PTR_ERR(rwtm->mbox);
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Cannot request mailbox channel: %i\n",
++				ret);
++		return ret;
++	}
++
++	init_completion(&rwtm->cmd_done);
++
++	ret = mox_board_info(rwtm);
++	if (ret < 0) {
++		dev_err(dev, "Cannot read board information!\n");
++		goto free_channel;
++	}
++
++	rwtm->hwrng.name = DRIVER_NAME "_hwrng";
++	rwtm->hwrng.read = mox_hwrng_read;
++	rwtm->hwrng.priv = (unsigned long) rwtm;
++	rwtm->hwrng.quality = 1024;
++
++	ret = devm_hwrng_register(dev, &rwtm->hwrng);
++	if (ret < 0) {
++		dev_err(dev, "Cannot register HWRNG: %i\n", ret);
++		goto free_channel;
++	}
++
++	return 0;
++
++free_channel:
++	mbox_free_channel(rwtm->mbox);
++	return ret;
++}
++
++static int turris_mox_rwtm_remove(struct platform_device *pdev)
++{
++	struct mox_rwtm *rwtm = platform_get_drvdata(pdev);
++
++	mbox_free_channel(rwtm->mbox);
++
++	return 0;
++}
++
++static const struct of_device_id turris_mox_rwtm_match[] = {
++	{ .compatible = "cznic,turris-mox-rwtm", },
++	{ },
++};
++
++MODULE_DEVICE_TABLE(of, turris_mox_rwtm_match);
++
++static struct platform_driver turris_mox_rwtm_driver = {
++	.probe	= turris_mox_rwtm_probe,
++	.remove	= turris_mox_rwtm_remove,
++	.driver	= {
++		.name		= DRIVER_NAME,
++		.of_match_table	= turris_mox_rwtm_match,
++	},
++};
++module_platform_driver(turris_mox_rwtm_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Turris Mox rWTM firmware driver");
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch b/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch
new file mode 100644
index 0000000..0c96089
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch
@@ -0,0 +1,931 @@
+From 49ba023db8bed0af25f2fb6b8d0ccd8e1e310610 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 24 Oct 2018 17:01:12 +0200
+Subject: [PATCH 125/127] ARM64: dts: marvell: Add DTS file for Turris Mox
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds basic support for the Turris Mox board from CZ.NIC.
+
+Turris Mox is a modular router based on the Armada 3720 SOC (same as
+EspressoBin).
+
+The basic module can be extended by different modules.
+When those modules are connected, U-Boot shall patch this basic
+device-tree with nodes corresponding to those modules.
+
+Signed-off-by: Marek Behn <marek.behun@nic.cz>
+---
+ .../arm/marvell/armada-3720-turris-mox.txt    |   6 +
+ MAINTAINERS                                   |   1 +
+ arch/arm64/boot/dts/marvell/Makefile          |   1 +
+ .../dts/marvell/armada-3720-turris-mox.dts    | 859 ++++++++++++++++++
+ 4 files changed, 867 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+
+diff --git a/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt b/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+new file mode 100644
+index 000000000000..408fc07a9bbf
+--- /dev/null
++++ b/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+@@ -0,0 +1,6 @@
++CZ.NIC's Turris Mox SOHO router Device Tree Bindings
++----------------------------------------------------
++
++Required root node property:
++
++compatible: must contain "cznic,turris-mox"
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 155e88024387..791f306df34c 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1348,6 +1348,7 @@ ARM/CZ.NIC TURRIS MOX SUPPORT
+ M:	Marek Behun <marek.behun@nic.cz>
+ W:	http://mox.turris.cz
+ S:	Maintained
++F:	arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+ F:	include/mfd/moxtet.h
+ F:	drivers/gpio/gpio-moxtet.c
+ F:	drivers/mfd/moxtet.c
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 5633676fa9d0..51782b31b441 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -6,6 +6,7 @@ dtb-$(CONFIG_ARCH_BERLIN) += berlin4ct-stb.dtb
+ # Mvebu SoC Family
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-7040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-mcbin.dtb
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+new file mode 100644
+index 000000000000..f397be1c4244
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -0,0 +1,859 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-372x.dtsi"
++
++/ {
++	model = "CZ.NIC Turris Mox Board";
++	compatible = "cznic,turris-mox", "marvell,armada3720",
++		     "marvell,armada3710";
++
++	aliases {
++		spi0 = &spi0;
++		ethernet1 = &eth1;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		red {
++			gpios = <&gpiosb 21 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "default-on";
++		};
++	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset-button {
++			label = "reset";
++			linux,code = <BTN_MISC>;
++			gpios = <&gpiosb 20 GPIO_ACTIVE_LOW>;
++			debounce-interval = <60>;
++		};
++	};
++
++	exp_usb3_vbus: usb3-vbus {
++		compatible = "regulator-fixed";
++		regulator-name = "usb3-vbus";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++		regulator-always-on;
++		gpio = <&gpiosb 0 GPIO_ACTIVE_HIGH>;
++	};
++
++	usb3_phy: usb3-phy {
++		compatible = "usb-nop-xceiv";
++		vcc-supply = <&exp_usb3_vbus>;
++	};
++
++	vsdc_reg: vsdc-reg {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdc";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 23 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++
++	vsdio_reg: vsdio-reg {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdio";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 22 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++
++	sdhci1_pwrseq: sdhci1-pwrseq {
++		compatible = "mmc-pwrseq-simple";
++		reset-gpios = <&gpionb 19 GPIO_ACTIVE_HIGH>;
++		status = "okay";
++	};
++
++	sfp: sfp {
++		compatible = "sff,sfp+";
++		i2c-bus = <&i2c0>;
++		los-gpio = <&moxtet_sfp 0 GPIO_ACTIVE_HIGH>;
++		tx-fault-gpio = <&moxtet_sfp 1 GPIO_ACTIVE_HIGH>;
++		mod-def0-gpio = <&moxtet_sfp 2 GPIO_ACTIVE_LOW>;
++		tx-disable-gpio = <&moxtet_sfp 3 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpio = <&moxtet_sfp 4 GPIO_ACTIVE_HIGH>;
++		status = "disabled";
++	};
++
++	soc {
++		internal-regs@d0000000 {
++			turris_mox_crypto: crypto@0 {
++				compatible = "cznic,turris-mox-rwtm";
++				mboxes = <&rwtm 0>;
++				status = "okay";
++			};
++		};
++	};
++};
++
++&pinctrl_nb {
++	spi_cs1_pins: spi-cs1-pins {
++		groups = "spi_cs1";
++		function = "spi";
++	};
++
++	sdio0_pins: sdio0-pins {
++		groups = "sdio0";
++		function = "sdio";
++	};
++};
++
++&pinctrl_sb {
++	sdio_sb_pins: sdio-sb-pins {
++		groups = "sdio_sb";
++		function = "sdio";
++	};
++
++	smi_pins: smi-pins {
++		groups = "smi";
++		function = "smi";
++	};
++
++	pcie_pins: pcie1-pins {
++		groups = "pcie1";
++		function = "gpio";
++	};
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c1_pins>;
++	status = "okay";
++
++	rtc@6f {
++		compatible = "microchip,mcp7940x";
++		reg = <0x6f>;
++	};
++};
++
++&pcie0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie_pins>;
++	status = "okay";
++	max-link-speed = <2>;
++	reset-gpio = <&gpiosb 3 GPIO_ACTIVE_HIGH>;
++
++	/* this shall be enabled by u-boot if the PCIe module is present */
++	status = "disabled";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&eth0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmii_pins>;
++	phy-mode = "rgmii-id";
++	phy = <&phy1>;
++	status = "okay";
++};
++
++&eth1 {
++	phy-mode = "1000base-x";
++	managed = "in-band-status";
++};
++
++&mdio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&smi_pins>;
++	status = "okay";
++
++	phy1: ethernet-phy@1 {
++		reg = <1>;
++	};
++
++	switch0@10 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x10 0>;
++		dsa,member = <0 0>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1: switch0phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch0phy2: switch0phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch0phy3: switch0phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch0phy4: switch0phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch0phy5: switch0phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch0phy6: switch0phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch0phy7: switch0phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch0phy8: switch0phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan5";
++				phy-handle = <&switch0phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan6";
++				phy-handle = <&switch0phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan7";
++				phy-handle = <&switch0phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan8";
++				phy-handle = <&switch0phy8>;
++			};
++
++			port@9 {
++				reg = <0x9>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++
++			switch0port10: port@a {
++				reg = <0xa>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port9 &switch2port9>;
++				status = "disabled";
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch0@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 0>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1_topaz: switch0phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch0phy2_topaz: switch0phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch0phy3_topaz: switch0phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch0phy4_topaz: switch0phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++		};
++	};
++
++	switch1@11 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x11 0>;
++		dsa,member = <0 1>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch1phy1: switch1phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch1phy2: switch1phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch1phy3: switch1phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch1phy4: switch1phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch1phy5: switch1phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch1phy6: switch1phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch1phy7: switch1phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch1phy8: switch1phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan9";
++				phy-handle = <&switch1phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan10";
++				phy-handle = <&switch1phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan11";
++				phy-handle = <&switch1phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan12";
++				phy-handle = <&switch1phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan13";
++				phy-handle = <&switch1phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan14";
++				phy-handle = <&switch1phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan15";
++				phy-handle = <&switch1phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan16";
++				phy-handle = <&switch1phy8>;
++			};
++
++			switch1port9: port@9 {
++				reg = <0x9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch0port10>;
++			};
++
++			switch1port10: port@a {
++				reg = <0xa>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch2port9>;
++				status = "disabled";
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch1@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 1>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch1phy1_topaz: switch1phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch1phy2_topaz: switch1phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch1phy3_topaz: switch1phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch1phy4_topaz: switch1phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan9";
++				phy-handle = <&switch1phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan10";
++				phy-handle = <&switch1phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan11";
++				phy-handle = <&switch1phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan12";
++				phy-handle = <&switch1phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch0port10>;
++			};
++		};
++	};
++
++	switch2@12 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x12 0>;
++		dsa,member = <0 2>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch2phy1: switch2phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch2phy2: switch2phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch2phy3: switch2phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch2phy4: switch2phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch2phy5: switch2phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch2phy6: switch2phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch2phy7: switch2phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch2phy8: switch2phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan17";
++				phy-handle = <&switch2phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan18";
++				phy-handle = <&switch2phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan19";
++				phy-handle = <&switch2phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan20";
++				phy-handle = <&switch2phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan21";
++				phy-handle = <&switch2phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan22";
++				phy-handle = <&switch2phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan23";
++				phy-handle = <&switch2phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan24";
++				phy-handle = <&switch2phy8>;
++			};
++
++			switch2port9: port@9 {
++				reg = <0x9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port10 &switch0port10>;
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch2@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 2>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch2phy1_topaz: switch2phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch2phy2_topaz: switch2phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch2phy3_topaz: switch2phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch2phy4_topaz: switch2phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan17";
++				phy-handle = <&switch2phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan18";
++				phy-handle = <&switch2phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan19";
++				phy-handle = <&switch2phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan20";
++				phy-handle = <&switch2phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port10 &switch0port10>;
++			};
++		};
++	};
++
++};
++
++&sdhci0 {
++	wp-inverted;
++	bus-width = <4>;
++	cd-gpios = <&gpionb 10 GPIO_ACTIVE_HIGH>;
++	vqmmc-supply = <&vsdc_reg>;
++	marvell,pad-type = "sd";
++	status = "okay";
++};
++
++&sdhci1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdio0_pins &sdio_sb_pins>;
++	non-removable;
++	bus-width = <4>;
++	marvell,pad-type = "sd";
++	vqmmc-supply = <&vsdio_reg>;
++	mmc-pwrseq = <&sdhci1_pwrseq>;
++	status = "okay";
++};
++
++&spi0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi_quad_pins &spi_cs1_pins>;
++	assigned-clocks = <&nb_periph_clk 7>;
++	assigned-clock-parents = <&tbg 1>;
++	assigned-clock-rates = <20000000>;
++
++	spi-flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <20000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "secure-firmware";
++				reg = <0x0 0x20000>;
++			};
++
++			partition@20000 {
++				label = "u-boot";
++				reg = <0x20000 0x160000>;
++			};
++
++			partition@180000 {
++				label = "u-boot-env";
++				reg = <0x180000 0x10000>;
++			};
++
++			partition@190000 {
++				label = "Rescue system";
++				reg = <0x190000 0x660000>;
++			};
++
++			partition@7f0000 {
++				label = "dtb";
++				reg = <0x7f0000 0x10000>;
++			};
++		};
++	};
++
++	moxtet@1 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "cznic,moxtet";
++		reg = <1>;
++		reset-gpios = <&gpiosb 2 GPIO_ACTIVE_LOW>;
++		spi-max-frequency = <10000000>;
++		spi-cpol;
++		spi-cpha;
++
++		moxtet_sfp: gpio@0 {
++			compatible = "cznic,moxtet-gpio";
++			gpio-controller;
++			#gpio-cells = <2>;
++			reg = <0>;
++			moxtet,id = <1>;
++			moxtet,input-mask = <0x7>;
++			moxtet,output-mask = <0x3>;
++			status = "disabled";
++		};
++	};
++};
++
++&rwtm {
++	status = "okay";
++};
++
++&usb2 {
++	status = "okay";
++};
++
++&usb3 {
++	status = "okay";
++	usb-phy = <&usb3_phy>;
++};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch b/target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
similarity index 89%
rename from target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch
rename to target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
index b442f71..112fbfc 100644
--- a/target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch
+++ b/target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
@@ -1,7 +1,7 @@
-From d419edef1a2429acfa35341eb6fbfaea3b6c87c4 Mon Sep 17 00:00:00 2001
+From 590c614469090540b43012223079d216da4e1b00 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
 Date: Mon, 14 Jan 2019 17:00:04 +0100
-Subject: [PATCH] arm64: restart: Armada 3700 restart code
+Subject: [PATCH 126/127] arm64: restart: Armada 3700 restart code
 MIME-Version: 1.0
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: 8bit
@@ -40,5 +40,5 @@ index 9e773732520c..2ae392c218fc 100644
  	/*
  	 * Whoops - the architecture was unable to reboot.
 -- 
-2.19.2
+2.21.0
 
diff --git a/target/linux/mvebu/patches-4.14/508-cpufreq-armada-37xx-Fix-clock-leak.patch b/target/linux/mvebu/patches-4.14/9508-cpufreq-armada-37xx-Fix-clock-leak.patch
similarity index 100%
rename from target/linux/mvebu/patches-4.14/508-cpufreq-armada-37xx-Fix-clock-leak.patch
rename to target/linux/mvebu/patches-4.14/9508-cpufreq-armada-37xx-Fix-clock-leak.patch
-- 
2.22.0

