From 5c7fed78547688817c24ceac4f341e30830bcd26 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Thu, 24 Sep 2020 00:28:51 +0200
Subject: [PATCH 9/9] mvebu: add support for Turris SFP module

---
 target/linux/mvebu/config-5.15                |   1 +
 ...te-supported_interfaces-with-lower-m.patch | 144 ++++++
 ...-supported-PHY-interface-modes-to-ph.patch | 123 +++++
 ...ell10g-add-downshift-tunable-support.patch | 220 +++++++++
 ...0g-Use-generic-macro-for-supported-i.patch |  35 ++
 ...0g-Use-tabs-instead-of-spaces-for-in.patch |  51 ++
 ...0g-select-host-interface-configurati.patch | 242 ++++++++++
 ...w-attaching-phy-for-SFP-modules-on-8.patch |  48 ++
 ...estroy-I2C-mdiobus-before-PHY-probe-.patch | 181 ++++++++
 ...-support-I2C-MDIO-protocol-for-RollB.patch | 434 ++++++++++++++++++
 ...ort-for-multigig-RollBall-transceive.patch | 156 +++++++
 ...SFP-parsing-with-phy_interface_t-bit.patch | 340 ++++++++++++++
 ...phy_interface_t-bitmaps-for-optical-.patch | 203 ++++++++
 13 files changed, 2178 insertions(+)
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-01-net-phylink-update-supported_interfaces-with-lower-m.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-02-net-phylink-pass-supported-PHY-interface-modes-to-ph.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-03-net-phy-marvell10g-add-downshift-tunable-support.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-04-net-phy-marvell10g-Use-generic-macro-for-supported-i.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-05-net-phy-marvell10g-Use-tabs-instead-of-spaces-for-in.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-06-net-phy-marvell10g-select-host-interface-configurati.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-07-net-phylink-allow-attaching-phy-for-SFP-modules-on-8.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-08-net-sfp-create-destroy-I2C-mdiobus-before-PHY-probe-.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-09-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-10-net-sfp-add-support-for-multigig-RollBall-transceive.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-11-net-sfp-augment-SFP-parsing-with-phy_interface_t-bit.patch
 create mode 100644 target/linux/mvebu/patches-5.15/706-TurrisSFP-12-net-phylink-use-phy_interface_t-bitmaps-for-optical-.patch

diff --git a/target/linux/mvebu/config-5.15 b/target/linux/mvebu/config-5.15
index 0811ee6d4c..f3548c94b7 100644
--- a/target/linux/mvebu/config-5.15
+++ b/target/linux/mvebu/config-5.15
@@ -241,6 +241,7 @@ CONFIG_MACH_MVEBU_V7=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_MANGLE_BOOTARGS=y
 CONFIG_MARVELL_PHY=y
+CONFIG_MARVELL_10G_PHY=y
 CONFIG_MDIO_BUS=y
 CONFIG_MDIO_DEVICE=y
 CONFIG_MDIO_DEVRES=y
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-01-net-phylink-update-supported_interfaces-with-lower-m.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-01-net-phylink-update-supported_interfaces-with-lower-m.patch
new file mode 100644
index 0000000000..c0c274d278
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-01-net-phylink-update-supported_interfaces-with-lower-m.patch
@@ -0,0 +1,144 @@
+From e6ad7e8ac63cf2190a94af5e4d88f19c4353c1ba Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 4 Nov 2021 20:57:33 +0100
+Subject: [PATCH 01/12] net: phylink: update supported_interfaces with lower
+ modes
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Update the bitmap of interfaces supported by the MAC with lower modes
+that should be supported if upper are.
+
+As Russell King says,
+  conventionally phy-mode has meant "this is the mode we want to operate
+  the PHY interface in" which was fine when PHYs didn't change their
+  mode depending on the media speed
+
+An example is DT defining
+  phy-mode = "sgmii";
+but the board supporting also 1000base-x and 2500base-x.
+
+Add the following logic to keep this backwards compatiblity:
+- if one PHY mode is defined:
+  - if it is sgmii, 1000base-x or 2500base-x, add all three and then do
+    the intersection
+  - if it is 10gbase-r or usxgmii, add both, and also 5gbase-r,
+    2500base-x, 1000base-x and sgmii, and then do the intersection
+
+This is simple enough and should work for all boards.
+
+Nonetheless it is possible (although extremely unlikely, in my opinion)
+that a board will be found that (for example) defines
+  phy-mode = "sgmii";
+and the MAC drivers supports sgmii, 1000base-x and 2500base-x, but the
+board DOESN'T support 2500base-x, because of electrical reasons (since
+the frequency is 2.5x of sgmii).
+Our code will in this case incorrectly infer also support for
+2500base-x. To avoid this, the board maintainer should add a fix into
+the function we are introducing in this commit.
+
+Another example would be a board with device-tree defining
+  phy-mode = "10gbase-r";
+We infer from this all other modes (sgmii, 1000base-x, 2500base-x,
+5gbase-r, usxgmii), and these then get filtered by those supported by
+the driver. But it is possible that a driver supports all of these
+modes, and yet not all are supported because the board has an older
+version of the TF-A firmware, which implements changing of PHY modes via
+SMC calls. For this case, the board maintainer should add a fix into
+this function that somehow checks for this situation. But this is a
+really improbable scenario, in my opinion.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+---
+ drivers/net/phy/phylink.c | 67 +++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 67 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 49eb7fd4ed51..fbcab015ff7d 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -300,6 +300,71 @@ static int phylink_parse_fixedlink(struct phylink *pl,
+ 	return 0;
+ }
+
++static void phylink_update_phy_modes(struct phylink *pl,
++				     struct fwnode_handle *fwnode)
++{
++	unsigned long *supported = pl->config->supported_interfaces;
++	DECLARE_PHY_INTERFACE_MASK(modes);
++
++	/* FIXME: If supported is empty, leave it as it is. This happens for
++	 * unconverted drivers that don't fill up supported_interfaces. Once all
++	 * such drivers are converted, we can drop this.
++	 */
++	if (phy_interface_empty(supported))
++		return;
++
++	/* If no modes are defined in fwnode, interpret it as all modes
++	 * supported by the MAC are supported by the board.
++	 */
++	if (phy_interface_empty(modes))
++		return;
++
++	/* We want the intersection of given supported modes with those defined
++	 * in DT.
++	 *
++	 * Some older device-trees mention only one of `sgmii`, `1000base-x` or
++	 * `2500base-x`, while supporting all three. Other mention `10gbase-r`
++	 * or `usxgmii`, while supporting both, and also `sgmii`, `1000base-x`,
++	 * `2500base-x` and `5gbase-r`.
++	 * For backwards compatibility with these older DTs, make it so that if
++	 * one of these modes is mentioned in DT and MAC supports more of them,
++	 * keep all that are supported according to the logic above.
++	 *
++	 * Nonetheless it is possible that a device may support only one mode,
++	 * for example 1000base-x, due to strapping pins or some other reasons.
++	 * If a specific device supports only the mode mentioned in DT, the
++	 * exception should be made here with of_machine_is_compatible().
++	 */
++	if (bitmap_weight(modes, PHY_INTERFACE_MODE_MAX) == 1) {
++		DECLARE_PHY_INTERFACE_MASK(mask);
++		bool lower = false;
++
++		if (test_bit(PHY_INTERFACE_MODE_10GBASER, modes) ||
++		    test_bit(PHY_INTERFACE_MODE_USXGMII, modes)) {
++			phy_interface_zero(mask);
++			__set_bit(PHY_INTERFACE_MODE_5GBASER, mask);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, mask);
++			__set_bit(PHY_INTERFACE_MODE_USXGMII, mask);
++			phy_interface_and(mask, supported, mask);
++			phy_interface_or(modes, modes, mask);
++			lower = true;
++		}
++
++		if (lower || (test_bit(PHY_INTERFACE_MODE_SGMII, modes) ||
++			      test_bit(PHY_INTERFACE_MODE_1000BASEX, modes) ||
++			      test_bit(PHY_INTERFACE_MODE_2500BASEX, modes))) {
++			phy_interface_zero(mask);
++			__set_bit(PHY_INTERFACE_MODE_SGMII, mask);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, mask);
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, mask);
++			phy_interface_and(mask, supported, mask);
++			phy_interface_or(modes, modes, mask);
++		}
++	}
++
++	phy_interface_and(supported, supported, modes);
++}
++
+ static int phylink_parse_mode(struct phylink *pl, struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_handle *dn;
+@@ -911,6 +976,8 @@ struct phylink *phylink_create(struct phylink_config *config,
+ 	__set_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state);
+ 	timer_setup(&pl->link_poll, phylink_fixed_poll, 0);
+
++	phylink_update_phy_modes(pl, fwnode);
++
+ 	bitmap_fill(pl->supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 	linkmode_copy(pl->link_config.advertising, pl->supported);
+ 	phylink_validate(pl, pl->supported, &pl->link_config);
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-02-net-phylink-pass-supported-PHY-interface-modes-to-ph.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-02-net-phylink-pass-supported-PHY-interface-modes-to-ph.patch
new file mode 100644
index 0000000000..a528045987
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-02-net-phylink-pass-supported-PHY-interface-modes-to-ph.patch
@@ -0,0 +1,123 @@
+From 3b7db3ec50d7ccc39ab98b592a2f0bdeee632cc1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 22 Nov 2021 21:39:41 +0100
+Subject: [PATCH 02/12] net: phylink: pass supported PHY interface modes to
+ phylib
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Pass the supported PHY interface types to phylib so that PHY drivers
+can select an appropriate host configuration mode for their interface
+according to the host capabilities.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Reviewed-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/phylink.c | 28 ++++++++++++++++++++++++++++
+ include/linux/phy.h       | 10 ++++++++++
+ 2 files changed, 38 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index fbcab015ff7d..9d248802253a 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1195,6 +1195,10 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ 		pl->link_config.interface = pl->link_interface;
+ 	}
+
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy->host_interfaces,
++			   pl->config->supported_interfaces);
++
+ 	ret = phylink_attach_phy(pl, phy, pl->link_interface);
+ 	if (ret < 0)
+ 		return ret;
+@@ -1264,6 +1268,10 @@ int phylink_fwnode_phy_connect(struct phylink *pl,
+ 	if (!phy_dev)
+ 		return -ENODEV;
+
++	/* Set the PHY's host supported interfaces */
++	phy_interface_copy(phy_dev->host_interfaces,
++			   pl->config->supported_interfaces);
++
+ 	ret = phy_attach_direct(pl->netdev, phy_dev, flags,
+ 				pl->link_interface);
+ 	if (ret) {
+@@ -2448,6 +2456,8 @@ static bool phylink_phy_no_inband(struct phy_device *phy)
+ 		(phy->c45_ids.device_ids[1] & 0xfffffff0) == 0xae025150;
+ }
+
++static DECLARE_PHY_INTERFACE_MASK(phylink_sfp_interfaces);
++
+ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ {
+ 	struct phylink *pl = upstream;
+@@ -2469,6 +2479,10 @@ static int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)
+ 	else
+ 		mode = MLO_AN_INBAND;
+
++	/* Set the PHY's host supported interfaces */
++	phy_interface_and(phy->host_interfaces, phylink_sfp_interfaces,
++			  pl->config->supported_interfaces);
++
+ 	/* Do the initial configuration */
+ 	ret = phylink_sfp_config(pl, mode, phy->supported, phy->advertising);
+ 	if (ret < 0)
+@@ -2852,4 +2866,18 @@ void phylink_mii_c45_pcs_get_state(struct mdio_device *pcs,
+ }
+ EXPORT_SYMBOL_GPL(phylink_mii_c45_pcs_get_state);
+
++static int __init phylink_init(void)
++{
++	__set_bit(PHY_INTERFACE_MODE_USXGMII, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_10GBASER, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_5GBASER, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_SGMII, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX, phylink_sfp_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_100BASEX, phylink_sfp_interfaces);
++
++	return 0;
++}
++module_init(phylink_init);
++
+ MODULE_LICENSE("GPL v2");
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index c270e6b3c3f6..4262f49c1eae 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -169,6 +169,12 @@ static inline bool phy_interface_empty(const unsigned long *intf)
+ 	return bitmap_empty(intf, PHY_INTERFACE_MODE_MAX);
+ }
+
++static inline void phy_interface_copy(unsigned long *dst,
++				      const unsigned long *src)
++{
++	bitmap_copy(dst, src, PHY_INTERFACE_MODE_MAX);
++}
++
+ static inline void phy_interface_and(unsigned long *dst, const unsigned long *a,
+ 				     const unsigned long *b)
+ {
+@@ -563,6 +569,7 @@ struct macsec_ops;
+  * @advertising: Currently advertised linkmodes
+  * @adv_old: Saved advertised while power saving for WoL
+  * @lp_advertising: Current link partner advertised linkmodes
++ * @host_interfaces: PHY interface modes supported by host
+  * @eee_broken_modes: Energy efficient ethernet modes which should be prohibited
+  * @autoneg: Flag autoneg being used
+  * @link: Current link state
+@@ -658,6 +665,9 @@ struct phy_device {
+ 	/* used with phy_speed_down */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
+
++	/* host supported PHY interface types */
++	DECLARE_PHY_INTERFACE_MASK(host_interfaces);
++
+ 	/* Energy efficient ethernet modes which should be prohibited */
+ 	u32 eee_broken_modes;
+
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-03-net-phy-marvell10g-add-downshift-tunable-support.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-03-net-phy-marvell10g-add-downshift-tunable-support.patch
new file mode 100644
index 0000000000..4ccb537861
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-03-net-phy-marvell10g-add-downshift-tunable-support.patch
@@ -0,0 +1,220 @@
+From b09b1757932fb02420dcb29933bc8d15f9797403 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Wed, 29 Sep 2021 16:28:53 +0100
+Subject: [PATCH 03/12] net: phy: marvell10g: add downshift tunable support
+
+Add support for the downshift tunable for the Marvell 88x3310 PHY.
+Downshift is only usable with firmware 0.3.5.0 and later.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/marvell10g.c | 107 ++++++++++++++++++++++++++++++++++-
+ 1 file changed, 106 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index df33637c5269..2b7d0720720b 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -22,6 +22,7 @@
+  * If both the fiber and copper ports are connected, the first to gain
+  * link takes priority and the other port is completely locked out.
+  */
++#include <linux/bitfield.h>
+ #include <linux/ctype.h>
+ #include <linux/delay.h>
+ #include <linux/hwmon.h>
+@@ -33,6 +34,8 @@
+ #define MV_PHY_ALASKA_NBT_QUIRK_MASK	0xfffffffe
+ #define MV_PHY_ALASKA_NBT_QUIRK_REV	(MARVELL_PHY_ID_88X3310 | 0xa)
+
++#define MV_VERSION(a,b,c,d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))
++
+ enum {
+ 	MV_PMA_FW_VER0		= 0xc011,
+ 	MV_PMA_FW_VER1		= 0xc012,
+@@ -62,6 +65,15 @@ enum {
+ 	MV_PCS_CSCR1_MDIX_MDIX	= 0x0020,
+ 	MV_PCS_CSCR1_MDIX_AUTO	= 0x0060,
+
++	MV_PCS_DSC1		= 0x8003,
++	MV_PCS_DSC1_ENABLE	= BIT(9),
++	MV_PCS_DSC1_10GBT	= 0x01c0,
++	MV_PCS_DSC1_1GBR	= 0x0038,
++	MV_PCS_DSC1_100BTX	= 0x0007,
++	MV_PCS_DSC2		= 0x8004,
++	MV_PCS_DSC2_2P5G	= 0xf000,
++	MV_PCS_DSC2_5G		= 0x0f00,
++
+ 	MV_PCS_CSSR1		= 0x8008,
+ 	MV_PCS_CSSR1_SPD1_MASK	= 0xc000,
+ 	MV_PCS_CSSR1_SPD1_SPD2	= 0xc000,
+@@ -125,6 +137,7 @@ enum {
+ };
+
+ struct mv3310_chip {
++	bool (*has_downshift)(struct phy_device *phydev);
+ 	void (*init_supported_interfaces)(unsigned long *mask);
+ 	int (*get_mactype)(struct phy_device *phydev);
+ 	int (*init_interface)(struct phy_device *phydev, int mactype);
+@@ -138,6 +151,7 @@ struct mv3310_priv {
+ 	DECLARE_BITMAP(supported_interfaces, PHY_INTERFACE_MODE_MAX);
+
+ 	u32 firmware_ver;
++	bool has_downshift;
+ 	bool rate_match;
+ 	phy_interface_t const_interface;
+
+@@ -330,6 +344,71 @@ static int mv3310_reset(struct phy_device *phydev, u32 unit)
+ 					 5000, 100000, true);
+ }
+
++static int mv3310_get_downshift(struct phy_device *phydev, u8 *ds)
++{
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++	int val;
++
++	if (!priv->has_downshift)
++		return -EOPNOTSUPP;
++
++	val = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1);
++	if (val < 0)
++		return val;
++
++	if (val & MV_PCS_DSC1_ENABLE)
++		/* assume that all fields are the same */
++		*ds = 1 + FIELD_GET(MV_PCS_DSC1_10GBT, (u16)val);
++	else
++		*ds = DOWNSHIFT_DEV_DISABLE;
++
++	return 0;
++}
++
++static int mv3310_set_downshift(struct phy_device *phydev, u8 ds)
++{
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++	u16 val;
++	int err;
++
++	if (!priv->has_downshift)
++		return -EOPNOTSUPP;
++
++	if (ds == DOWNSHIFT_DEV_DISABLE)
++		return phy_clear_bits_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1,
++					  MV_PCS_DSC1_ENABLE);
++
++	/* DOWNSHIFT_DEV_DEFAULT_COUNT is confusing. It looks like it should
++	 * set the default settings for the PHY. However, it is used for
++	 * "ethtool --set-phy-tunable ethN downshift on". The intention is
++	 * to enable downshift at a default number of retries. The default
++	 * settings for 88x3310 are for two retries with downshift disabled.
++	 * So let's use two retries with downshift enabled.
++	 */
++	if (ds == DOWNSHIFT_DEV_DEFAULT_COUNT)
++		ds = 2;
++
++	if (ds > 8)
++		return -E2BIG;
++
++	ds -= 1;
++	val = FIELD_PREP(MV_PCS_DSC2_2P5G, ds);
++	val |= FIELD_PREP(MV_PCS_DSC2_5G, ds);
++	err = phy_modify_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC2,
++			     MV_PCS_DSC2_2P5G | MV_PCS_DSC2_5G, val);
++	if (err < 0)
++		return err;
++
++	val = MV_PCS_DSC1_ENABLE;
++	val |= FIELD_PREP(MV_PCS_DSC1_10GBT, ds);
++	val |= FIELD_PREP(MV_PCS_DSC1_1GBR, ds);
++	val |= FIELD_PREP(MV_PCS_DSC1_100BTX, ds);
++
++	return phy_modify_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1,
++			      MV_PCS_DSC1_ENABLE | MV_PCS_DSC1_10GBT |
++			      MV_PCS_DSC1_1GBR | MV_PCS_DSC1_100BTX, val);
++}
++
+ static int mv3310_get_edpd(struct phy_device *phydev, u16 *edpd)
+ {
+ 	int val;
+@@ -448,6 +527,9 @@ static int mv3310_probe(struct phy_device *phydev)
+ 		    priv->firmware_ver >> 24, (priv->firmware_ver >> 16) & 255,
+ 		    (priv->firmware_ver >> 8) & 255, priv->firmware_ver & 255);
+
++	if (chip->has_downshift)
++		priv->has_downshift = chip->has_downshift(phydev);
++
+ 	/* Powering down the port when not in use saves about 600mW */
+ 	ret = mv3310_power_down(phydev);
+ 	if (ret)
+@@ -616,7 +698,16 @@ static int mv3310_config_init(struct phy_device *phydev)
+ 	}
+
+ 	/* Enable EDPD mode - saving 600mW */
+-	return mv3310_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);
++	err = mv3310_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);
++	if (err)
++		return err;
++
++	/* Allow downshift */
++	err = mv3310_set_downshift(phydev, DOWNSHIFT_DEV_DEFAULT_COUNT);
++	if (err && err != -EOPNOTSUPP)
++		return err;
++
++	return 0;
+ }
+
+ static int mv3310_get_features(struct phy_device *phydev)
+@@ -886,6 +977,8 @@ static int mv3310_get_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, void *data)
+ {
+ 	switch (tuna->id) {
++	case ETHTOOL_PHY_DOWNSHIFT:
++		return mv3310_get_downshift(phydev, data);
+ 	case ETHTOOL_PHY_EDPD:
+ 		return mv3310_get_edpd(phydev, data);
+ 	default:
+@@ -897,6 +990,8 @@ static int mv3310_set_tunable(struct phy_device *phydev,
+ 			      struct ethtool_tunable *tuna, const void *data)
+ {
+ 	switch (tuna->id) {
++	case ETHTOOL_PHY_DOWNSHIFT:
++		return mv3310_set_downshift(phydev, *(u8 *)data);
+ 	case ETHTOOL_PHY_EDPD:
+ 		return mv3310_set_edpd(phydev, *(u16 *)data);
+ 	default:
+@@ -904,6 +999,14 @@ static int mv3310_set_tunable(struct phy_device *phydev,
+ 	}
+ }
+
++static bool mv3310_has_downshift(struct phy_device *phydev)
++{
++	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
++
++	/* Fails to downshift with firmware older than v0.3.5.0 */
++	return priv->firmware_ver >= MV_VERSION(0,3,5,0);
++}
++
+ static void mv3310_init_supported_interfaces(unsigned long *mask)
+ {
+ 	__set_bit(PHY_INTERFACE_MODE_SGMII, mask);
+@@ -943,6 +1046,7 @@ static void mv2111_init_supported_interfaces(unsigned long *mask)
+ }
+
+ static const struct mv3310_chip mv3310_type = {
++	.has_downshift = mv3310_has_downshift,
+ 	.init_supported_interfaces = mv3310_init_supported_interfaces,
+ 	.get_mactype = mv3310_get_mactype,
+ 	.init_interface = mv3310_init_interface,
+@@ -953,6 +1057,7 @@ static const struct mv3310_chip mv3310_type = {
+ };
+
+ static const struct mv3310_chip mv3340_type = {
++	.has_downshift = mv3310_has_downshift,
+ 	.init_supported_interfaces = mv3340_init_supported_interfaces,
+ 	.get_mactype = mv3310_get_mactype,
+ 	.init_interface = mv3340_init_interface,
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-04-net-phy-marvell10g-Use-generic-macro-for-supported-i.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-04-net-phy-marvell10g-Use-generic-macro-for-supported-i.patch
new file mode 100644
index 0000000000..76f3479f3a
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-04-net-phy-marvell10g-Use-generic-macro-for-supported-i.patch
@@ -0,0 +1,35 @@
+From 9a4f26cb3e71400555c0c3a7edbcbd0d29fd4464 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 4 Nov 2021 17:25:25 +0100
+Subject: [PATCH 04/12] net: phy: marvell10g: Use generic macro for supported
+ interfaces
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Now that phy.h defines macro DECLARE_PHY_INTERFACE_MASK(), use it
+instead of DECLARE_BITMAP().
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Reviewed-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/marvell10g.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index 2b7d0720720b..6e8de692c0f5 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -148,7 +148,7 @@ struct mv3310_chip {
+ };
+
+ struct mv3310_priv {
+-	DECLARE_BITMAP(supported_interfaces, PHY_INTERFACE_MODE_MAX);
++	DECLARE_PHY_INTERFACE_MASK(supported_interfaces);
+
+ 	u32 firmware_ver;
+ 	bool has_downshift;
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-05-net-phy-marvell10g-Use-tabs-instead-of-spaces-for-in.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-05-net-phy-marvell10g-Use-tabs-instead-of-spaces-for-in.patch
new file mode 100644
index 0000000000..2d931ba43e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-05-net-phy-marvell10g-Use-tabs-instead-of-spaces-for-in.patch
@@ -0,0 +1,51 @@
+From fe4dc078a329618d3a14bec90d365942953e9a47 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 4 Nov 2021 17:26:35 +0100
+Subject: [PATCH 05/12] net: phy: marvell10g: Use tabs instead of spaces for
+ indentation
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some register definitions were defined with spaces used for indentation.
+Change them to tabs.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Reviewed-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/marvell10g.c | 18 +++++++++---------
+ 1 file changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index 6e8de692c0f5..2249f737beaf 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -117,16 +117,16 @@ enum {
+ 	MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_NO_SGMII_AN	= 0x5,
+ 	MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH	= 0x6,
+ 	MV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII			= 0x7,
+-	MV_V2_PORT_INTR_STS     = 0xf040,
+-	MV_V2_PORT_INTR_MASK    = 0xf043,
+-	MV_V2_PORT_INTR_STS_WOL_EN      = BIT(8),
+-	MV_V2_MAGIC_PKT_WORD0   = 0xf06b,
+-	MV_V2_MAGIC_PKT_WORD1   = 0xf06c,
+-	MV_V2_MAGIC_PKT_WORD2   = 0xf06d,
++	MV_V2_PORT_INTR_STS		= 0xf040,
++	MV_V2_PORT_INTR_MASK		= 0xf043,
++	MV_V2_PORT_INTR_STS_WOL_EN	= BIT(8),
++	MV_V2_MAGIC_PKT_WORD0		= 0xf06b,
++	MV_V2_MAGIC_PKT_WORD1		= 0xf06c,
++	MV_V2_MAGIC_PKT_WORD2		= 0xf06d,
+ 	/* Wake on LAN registers */
+-	MV_V2_WOL_CTRL          = 0xf06e,
+-	MV_V2_WOL_CTRL_CLEAR_STS        = BIT(15),
+-	MV_V2_WOL_CTRL_MAGIC_PKT_EN     = BIT(0),
++	MV_V2_WOL_CTRL			= 0xf06e,
++	MV_V2_WOL_CTRL_CLEAR_STS	= BIT(15),
++	MV_V2_WOL_CTRL_MAGIC_PKT_EN	= BIT(0),
+ 	/* Temperature control/read registers (88X3310 only) */
+ 	MV_V2_TEMP_CTRL		= 0xf08a,
+ 	MV_V2_TEMP_CTRL_MASK	= 0xc000,
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-06-net-phy-marvell10g-select-host-interface-configurati.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-06-net-phy-marvell10g-select-host-interface-configurati.patch
new file mode 100644
index 0000000000..b40e361036
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-06-net-phy-marvell10g-select-host-interface-configurati.patch
@@ -0,0 +1,242 @@
+From 18cdeb60b63e4362df32da136ece815b38c3031e Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Thu, 4 Nov 2021 23:23:38 +0100
+Subject: [PATCH 06/12] net: phy: marvell10g: select host interface
+ configuration
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Select the host interface configuration according to the capabilities of
+the host.
+
+The PHY supports several configurations of host communication:
+- always communicate with host in 10gbase-r, even if copper speed is
+  lower (rate matching mode),
+- the same as above but use xaui/rxaui instead of 10gbase-r,
+- switch host SerDes mode between 10gbase-r, 5gbase-r, 2500base-x and
+  sgmii according to copper speed,
+- the same as above but use xaui/rxaui instead of 10gbase-r.
+
+This mode of host communication, called MACTYPE, is by default selected
+by strapping pins, but it can be changed in software.
+
+This adds support for selecting this mode according to which modes are
+supported by the host.
+
+This allows the kernel to:
+- support SFP modules with 88X33X0 or 88E21X0 inside them
+- switch interface modes when the PHY is used with the mvpp2 MAC
+  (e.g. on MacchiatoBIN)
+
+Note: we use mv3310_select_mactype() for both 88X3310 and 88X3340,
+although 88X3340 does not support XAUI. This is not a problem because
+88X3340 does not declare XAUI in it's supported_interfaces, and so this
+function will never choose that MACTYPE.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[ rebase, updated, also added support for 88E21X0 ]
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+---
+ drivers/net/phy/marvell10g.c | 120 +++++++++++++++++++++++++++++++++--
+ 1 file changed, 115 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index 2249f737beaf..b16e67b352bf 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -96,6 +96,11 @@ enum {
+ 	MV_PCS_PORT_INFO_NPORTS_MASK	= 0x0380,
+ 	MV_PCS_PORT_INFO_NPORTS_SHIFT	= 7,
+
++	/* SerDes reinitialization 88E21X0 */
++	MV_AN_21X0_SERDES_CTRL2	= 0x800f,
++	MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS	= BIT(13),
++	MV_AN_21X0_SERDES_CTRL2_RUN_INIT	= BIT(15),
++
+ 	/* These registers appear at 0x800X and 0xa00X - the 0xa00X control
+ 	 * registers appear to set themselves to the 0x800X when AN is
+ 	 * restarted, but status registers appear readable from either.
+@@ -140,6 +145,8 @@ struct mv3310_chip {
+ 	bool (*has_downshift)(struct phy_device *phydev);
+ 	void (*init_supported_interfaces)(unsigned long *mask);
+ 	int (*get_mactype)(struct phy_device *phydev);
++	int (*set_mactype)(struct phy_device *phydev, int mactype);
++	int (*select_mactype)(unsigned long *interfaces);
+ 	int (*init_interface)(struct phy_device *phydev, int mactype);
+
+ #ifdef CONFIG_HWMON
+@@ -593,6 +600,49 @@ static int mv2110_get_mactype(struct phy_device *phydev)
+ 	return mactype & MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK;
+ }
+
++static int mv2110_set_mactype(struct phy_device *phydev, int mactype)
++{
++	int err, val;
++
++	mactype &= MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK;
++	err = phy_modify_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_21X0_PORT_CTRL,
++			     MV_PMA_21X0_PORT_CTRL_SWRST |
++			     MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK,
++			     MV_PMA_21X0_PORT_CTRL_SWRST | mactype);
++	if (err)
++		return err;
++
++	err = phy_set_bits_mmd(phydev, MDIO_MMD_AN, MV_AN_21X0_SERDES_CTRL2,
++			       MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS |
++			       MV_AN_21X0_SERDES_CTRL2_RUN_INIT);
++	if (err)
++		return err;
++
++	err = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_AN,
++					MV_AN_21X0_SERDES_CTRL2, val,
++					!(val &
++					  MV_AN_21X0_SERDES_CTRL2_RUN_INIT),
++					5000, 100000, true);
++	if (err)
++		return err;
++
++	return phy_clear_bits_mmd(phydev, MDIO_MMD_AN, MV_AN_21X0_SERDES_CTRL2,
++				  MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS);
++}
++
++static int mv2110_select_mactype(unsigned long *interfaces)
++{
++	if (test_bit(PHY_INTERFACE_MODE_USXGMII, interfaces))
++		return MV_PMA_21X0_PORT_CTRL_MACTYPE_USXGMII;
++	else if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&
++		 !test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))
++		return MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER;
++	else if (test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))
++		return MV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH;
++	else
++		return -1;
++}
++
+ static int mv3310_get_mactype(struct phy_device *phydev)
+ {
+ 	int mactype;
+@@ -604,6 +654,46 @@ static int mv3310_get_mactype(struct phy_device *phydev)
+ 	return mactype & MV_V2_33X0_PORT_CTRL_MACTYPE_MASK;
+ }
+
++static int mv3310_set_mactype(struct phy_device *phydev, int mactype)
++{
++	int ret;
++
++	mactype &= MV_V2_33X0_PORT_CTRL_MACTYPE_MASK;
++	ret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,
++				     MV_V2_33X0_PORT_CTRL_MACTYPE_MASK,
++				     mactype);
++	if (ret <= 0)
++		return ret;
++
++	return phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,
++				MV_V2_33X0_PORT_CTRL_SWRST);
++}
++
++static int mv3310_select_mactype(unsigned long *interfaces)
++{
++	if (test_bit(PHY_INTERFACE_MODE_USXGMII, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII;
++	else if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&
++		 test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER;
++	else if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&
++		 test_bit(PHY_INTERFACE_MODE_RXAUI, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI;
++	else if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&
++		 test_bit(PHY_INTERFACE_MODE_XAUI, interfaces))
++		return MV_V2_3310_PORT_CTRL_MACTYPE_XAUI;
++	else if (test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH;
++	else if (test_bit(PHY_INTERFACE_MODE_RXAUI, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH;
++	else if (test_bit(PHY_INTERFACE_MODE_XAUI, interfaces))
++		return MV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH;
++	else if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces))
++		return MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER;
++	else
++		return -1;
++}
++
+ static int mv2110_init_interface(struct phy_device *phydev, int mactype)
+ {
+ 	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
+@@ -674,10 +764,16 @@ static int mv3310_config_init(struct phy_device *phydev)
+ {
+ 	struct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);
+ 	const struct mv3310_chip *chip = to_mv3310_chip(phydev);
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	int err, mactype;
+
+-	/* Check that the PHY interface type is compatible */
+-	if (!test_bit(phydev->interface, priv->supported_interfaces))
++	/* In case host didn't provide supported interfaces */
++	__set_bit(phydev->interface, phydev->host_interfaces);
++
++	/* Check that there is at least one compatible PHY interface type */
++	phy_interface_and(interfaces, phydev->host_interfaces,
++			  priv->supported_interfaces);
++	if (phy_interface_empty(interfaces))
+ 		return -ENODEV;
+
+ 	phydev->mdix_ctrl = ETH_TP_MDI_AUTO;
+@@ -687,9 +783,15 @@ static int mv3310_config_init(struct phy_device *phydev)
+ 	if (err)
+ 		return err;
+
+-	mactype = chip->get_mactype(phydev);
+-	if (mactype < 0)
+-		return mactype;
++	mactype = chip->select_mactype(interfaces);
++	if (mactype < 0) {
++		mactype = chip->get_mactype(phydev);
++	} else {
++		phydev_info(phydev, "Changing MACTYPE to %i\n", mactype);
++		err = chip->set_mactype(phydev, mactype);
++		if (err)
++			return err;
++	}
+
+ 	err = chip->init_interface(phydev, mactype);
+ 	if (err) {
+@@ -1049,6 +1151,8 @@ static const struct mv3310_chip mv3310_type = {
+ 	.has_downshift = mv3310_has_downshift,
+ 	.init_supported_interfaces = mv3310_init_supported_interfaces,
+ 	.get_mactype = mv3310_get_mactype,
++	.set_mactype = mv3310_set_mactype,
++	.select_mactype = mv3310_select_mactype,
+ 	.init_interface = mv3310_init_interface,
+
+ #ifdef CONFIG_HWMON
+@@ -1060,6 +1164,8 @@ static const struct mv3310_chip mv3340_type = {
+ 	.has_downshift = mv3310_has_downshift,
+ 	.init_supported_interfaces = mv3340_init_supported_interfaces,
+ 	.get_mactype = mv3310_get_mactype,
++	.set_mactype = mv3310_set_mactype,
++	.select_mactype = mv3310_select_mactype,
+ 	.init_interface = mv3340_init_interface,
+
+ #ifdef CONFIG_HWMON
+@@ -1070,6 +1176,8 @@ static const struct mv3310_chip mv3340_type = {
+ static const struct mv3310_chip mv2110_type = {
+ 	.init_supported_interfaces = mv2110_init_supported_interfaces,
+ 	.get_mactype = mv2110_get_mactype,
++	.set_mactype = mv2110_set_mactype,
++	.select_mactype = mv2110_select_mactype,
+ 	.init_interface = mv2110_init_interface,
+
+ #ifdef CONFIG_HWMON
+@@ -1080,6 +1188,8 @@ static const struct mv3310_chip mv2110_type = {
+ static const struct mv3310_chip mv2111_type = {
+ 	.init_supported_interfaces = mv2111_init_supported_interfaces,
+ 	.get_mactype = mv2110_get_mactype,
++	.set_mactype = mv2110_set_mactype,
++	.select_mactype = mv2110_select_mactype,
+ 	.init_interface = mv2110_init_interface,
+
+ #ifdef CONFIG_HWMON
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-07-net-phylink-allow-attaching-phy-for-SFP-modules-on-8.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-07-net-phylink-allow-attaching-phy-for-SFP-modules-on-8.patch
new file mode 100644
index 0000000000..bd9f2b6ae0
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-07-net-phylink-allow-attaching-phy-for-SFP-modules-on-8.patch
@@ -0,0 +1,48 @@
+From 3f8b2734f1df8dc6f4f619d8f165d70fdea25232 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Sun, 10 Jan 2021 00:29:41 +0100
+Subject: [PATCH 07/12] net: phylink: allow attaching phy for SFP modules on
+ 802.3z mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some SFPs may contain an internal PHY which may in some cases want to
+connect with the host interface in 1000base-x/2500base-x mode.
+Do not fail if such PHY is being attached in one of these PHY interface
+modes.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Reviewed-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Pali Roh√°r <pali@kernel.org>
+Cc: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/phy/phylink.c | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 9d248802253a..f1fad9e18d03 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1161,7 +1161,7 @@ static int phylink_attach_phy(struct phylink *pl, struct phy_device *phy,
+ {
+ 	if (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED ||
+ 		    (pl->cfg_link_an_mode == MLO_AN_INBAND &&
+-		     phy_interface_mode_is_8023z(interface))))
++		     phy_interface_mode_is_8023z(interface) && !pl->sfp_bus)))
+ 		return -EINVAL;
+
+ 	if (pl->phydev)
+@@ -2347,9 +2347,6 @@ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 		    phylink_an_mode_str(mode), phy_modes(config.interface),
+ 		    __ETHTOOL_LINK_MODE_MASK_NBITS, support);
+
+-	if (phy_interface_mode_is_8023z(iface) && pl->phydev)
+-		return -EINVAL;
+-
+ 	changed = !linkmode_equal(pl->supported, support) ||
+ 		  !linkmode_equal(pl->link_config.advertising,
+ 				  config.advertising);
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-08-net-sfp-create-destroy-I2C-mdiobus-before-PHY-probe-.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-08-net-sfp-create-destroy-I2C-mdiobus-before-PHY-probe-.patch
new file mode 100644
index 0000000000..8ce0a3fcd0
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-08-net-sfp-create-destroy-I2C-mdiobus-before-PHY-probe-.patch
@@ -0,0 +1,181 @@
+From 36941751c1ebc9b8d755c49688e7e4637cbc25ea Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Thu, 4 Nov 2021 23:58:53 +0100
+Subject: [PATCH 08/12] net: sfp: create/destroy I2C mdiobus before PHY
+ probe/after PHY release
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Instead of configuring the I2C mdiobus when SFP driver is probed,
+create/destroy the mdiobus before the PHY is probed for/after it is
+released.
+
+This way we can tell the mdio-i2c code which protocol to use for each
+SFP transceiver.
+
+Move the code that determines MDIO I2C protocol from
+sfp_sm_probe_for_phy() to sfp_sm_mod_probe(), where most of the SFP ID
+parsing is done. Don't allocate I2C bus if no PHY is expected.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+---
+ drivers/net/phy/sfp.c         | 64 ++++++++++++++++++++++++++++-------
+ include/linux/mdio/mdio-i2c.h |  6 ++++
+ 2 files changed, 57 insertions(+), 13 deletions(-)
+
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 1df5d5008ab2..5932addfc5d9 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -218,6 +218,7 @@ struct sfp {
+ 	struct i2c_adapter *i2c;
+ 	struct mii_bus *i2c_mii;
+ 	struct sfp_bus *sfp_bus;
++	enum mdio_i2c_proto mdio_protocol;
+ 	struct phy_device *mod_phy;
+ 	const struct sff_data *type;
+ 	size_t i2c_block_size;
+@@ -532,9 +533,6 @@ static int sfp_i2c_write(struct sfp *sfp, bool a2, u8 dev_addr, void *buf,
+
+ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ {
+-	struct mii_bus *i2c_mii;
+-	int ret;
+-
+ 	if (!i2c_check_functionality(i2c, I2C_FUNC_I2C))
+ 		return -EINVAL;
+
+@@ -542,7 +540,15 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ 	sfp->read = sfp_i2c_read;
+ 	sfp->write = sfp_i2c_write;
+
+-	i2c_mii = mdio_i2c_alloc(sfp->dev, i2c);
++	return 0;
++}
++
++static int sfp_i2c_mdiobus_create(struct sfp *sfp)
++{
++	struct mii_bus *i2c_mii;
++	int ret;
++
++	i2c_mii = mdio_i2c_alloc(sfp->dev, sfp->i2c);
+ 	if (IS_ERR(i2c_mii))
+ 		return PTR_ERR(i2c_mii);
+
+@@ -560,6 +566,12 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ 	return 0;
+ }
+
++static void sfp_i2c_mdiobus_destroy(struct sfp *sfp)
++{
++	mdiobus_unregister(sfp->i2c_mii);
++	sfp->i2c_mii = NULL;
++}
++
+ /* Interface */
+ static int sfp_read(struct sfp *sfp, bool a2, u8 addr, void *buf, size_t len)
+ {
+@@ -1724,6 +1736,14 @@ static void sfp_sm_fault(struct sfp *sfp, unsigned int next_state, bool warn)
+ 	}
+ }
+
++static int sfp_sm_add_mdio_bus(struct sfp *sfp)
++{
++	if (sfp->mdio_protocol != MDIO_I2C_NONE)
++		return sfp_i2c_mdiobus_create(sfp);
++
++	return 0;
++}
++
+ /* Probe a SFP for a PHY device if the module supports copper - the PHY
+  * normally sits at I2C bus address 0x56, and may either be a clause 22
+  * or clause 45 PHY.
+@@ -1739,19 +1759,19 @@ static int sfp_sm_probe_for_phy(struct sfp *sfp)
+ {
+ 	int err = 0;
+
+-	switch (sfp->id.base.extended_cc) {
+-	case SFF8024_ECC_10GBASE_T_SFI:
+-	case SFF8024_ECC_10GBASE_T_SR:
+-	case SFF8024_ECC_5GBASE_T:
+-	case SFF8024_ECC_2_5GBASE_T:
+-		err = sfp_sm_probe_phy(sfp, true);
++	switch (sfp->mdio_protocol) {
++	case MDIO_I2C_NONE:
+ 		break;
+
+-	default:
+-		if (sfp->id.base.e1000_base_t)
+-			err = sfp_sm_probe_phy(sfp, false);
++	case MDIO_I2C_MARVELL_C22:
++		err = sfp_sm_probe_phy(sfp, false);
++		break;
++
++	case MDIO_I2C_C45:
++		err = sfp_sm_probe_phy(sfp, true);
+ 		break;
+ 	}
++
+ 	return err;
+ }
+
+@@ -2073,6 +2093,16 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 	if (sfp->quirk && sfp->quirk->fixup)
+ 		sfp->quirk->fixup(sfp);
+
++	if (sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SFI ||
++	    sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SR ||
++	    sfp->id.base.extended_cc == SFF8024_ECC_5GBASE_T ||
++	    sfp->id.base.extended_cc == SFF8024_ECC_2_5GBASE_T)
++		sfp->mdio_protocol = MDIO_I2C_C45;
++	else if (sfp->id.base.e1000_base_t)
++		sfp->mdio_protocol = MDIO_I2C_MARVELL_C22;
++	else
++		sfp->mdio_protocol = MDIO_I2C_NONE;
++
+ 	return 0;
+ }
+
+@@ -2244,6 +2274,8 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 			sfp_module_stop(sfp->sfp_bus);
+ 		if (sfp->mod_phy)
+ 			sfp_sm_phy_detach(sfp);
++		if (sfp->i2c_mii)
++			sfp_i2c_mdiobus_destroy(sfp);
+ 		sfp_module_tx_disable(sfp);
+ 		sfp_soft_stop_poll(sfp);
+ 		sfp_sm_next(sfp, SFP_S_DOWN, 0);
+@@ -2306,6 +2338,12 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 				     sfp->sm_fault_retries == N_FAULT_INIT);
+ 		} else if (event == SFP_E_TIMEOUT || event == SFP_E_TX_CLEAR) {
+ 	init_done:
++			/* Create mdiobus and start trying for PHY */
++			ret = sfp_sm_add_mdio_bus(sfp);
++			if (ret < 0) {
++				sfp_sm_next(sfp, SFP_S_FAIL, 0);
++				break;
++			}
+ 			sfp->sm_phy_retries = R_PHY_RETRY;
+ 			goto phy_probe;
+ 		}
+diff --git a/include/linux/mdio/mdio-i2c.h b/include/linux/mdio/mdio-i2c.h
+index b1d27f7cd23f..3bde1a555a49 100644
+--- a/include/linux/mdio/mdio-i2c.h
++++ b/include/linux/mdio/mdio-i2c.h
+@@ -11,6 +11,12 @@ struct device;
+ struct i2c_adapter;
+ struct mii_bus;
+
++enum mdio_i2c_proto {
++	MDIO_I2C_NONE,
++	MDIO_I2C_MARVELL_C22,
++	MDIO_I2C_C45,
++};
++
+ struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c);
+
+ #endif
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-09-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-09-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
new file mode 100644
index 0000000000..2806501dd0
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-09-net-phy-mdio-i2c-support-I2C-MDIO-protocol-for-RollB.patch
@@ -0,0 +1,434 @@
+From afa187b54a94c9a2de7873c2c78accd195bcb60c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 11 Jan 2021 05:36:26 +0100
+Subject: [PATCH 09/12] net: phy: mdio-i2c: support I2C MDIO protocol for
+ RollBall SFP modules
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some multigig SFPs from RollBall and Hilink do not expose functional
+MDIO access to the internal PHY of the SFP via I2C address 0x56
+(although there seems to be read-only clause 22 access on this address).
+
+Instead these SFPs PHY can be accessed via I2C via the SFP Enhanced
+Digital Diagnostic Interface - I2C address 0x51. The SFP_PAGE has to be
+selected to 3 and the password must be filled with 0xff bytes for this
+PHY communication to work.
+
+This extends the mdio-i2c driver to support this protocol by adding a
+special parameter to mdio_i2c_alloc function via which this RollBall
+protocol can be selected.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Cc: Andrew Lunn <andrew@lunn.ch>
+Cc: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/mdio/mdio-i2c.c   | 310 +++++++++++++++++++++++++++++++++-
+ drivers/net/phy/sfp.c         |   6 +-
+ include/linux/mdio/mdio-i2c.h |   4 +-
+ 3 files changed, 313 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/net/mdio/mdio-i2c.c b/drivers/net/mdio/mdio-i2c.c
+index 09200a70b315..bf8bf5e20faf 100644
+--- a/drivers/net/mdio/mdio-i2c.c
++++ b/drivers/net/mdio/mdio-i2c.c
+@@ -3,6 +3,7 @@
+  * MDIO I2C bridge
+  *
+  * Copyright (C) 2015-2016 Russell King
++ * Copyright (C) 2021 Marek Behun
+  *
+  * Network PHYs can appear on I2C buses when they are part of SFP module.
+  * This driver exposes these PHYs to the networking PHY code, allowing
+@@ -12,6 +13,7 @@
+ #include <linux/i2c.h>
+ #include <linux/mdio/mdio-i2c.h>
+ #include <linux/phy.h>
++#include <linux/sfp.h>
+
+ /*
+  * I2C bus addresses 0x50 and 0x51 are normally an EEPROM, which is
+@@ -28,7 +30,7 @@ static unsigned int i2c_mii_phy_addr(int phy_id)
+ 	return phy_id + 0x40;
+ }
+
+-static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
++static int i2c_mii_read_default(struct mii_bus *bus, int phy_id, int reg)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msgs[2];
+@@ -62,7 +64,8 @@ static int i2c_mii_read(struct mii_bus *bus, int phy_id, int reg)
+ 	return data[0] << 8 | data[1];
+ }
+
+-static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
++static int i2c_mii_write_default(struct mii_bus *bus, int phy_id, int reg,
++				 u16 val)
+ {
+ 	struct i2c_adapter *i2c = bus->priv;
+ 	struct i2c_msg msg;
+@@ -91,9 +94,288 @@ static int i2c_mii_write(struct mii_bus *bus, int phy_id, int reg, u16 val)
+ 	return ret < 0 ? ret : 0;
+ }
+
+-struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c)
++/* RollBall SFPs do not access internal PHY via I2C address 0x56, but
++ * instead via address 0x51, when SFP page is set to 0x03 and password to
++ * 0xffffffff.
++ *
++ * address  size  contents  description
++ * -------  ----  --------  -----------
++ * 0x80     1     CMD       0x01/0x02/0x04 for write/read/done
++ * 0x81     1     DEV       Clause 45 device
++ * 0x82     2     REG       Clause 45 register
++ * 0x84     2     VAL       Register value
++ */
++#define ROLLBALL_PHY_I2C_ADDR		0x51
++
++#define ROLLBALL_PASSWORD		(SFP_VSL + 3)
++
++#define ROLLBALL_CMD_ADDR		0x80
++#define ROLLBALL_DATA_ADDR		0x81
++
++#define ROLLBALL_CMD_WRITE		0x01
++#define ROLLBALL_CMD_READ		0x02
++#define ROLLBALL_CMD_DONE		0x04
++
++#define SFP_PAGE_ROLLBALL_MDIO		3
++
++static int __i2c_transfer_err(struct i2c_adapter *i2c, struct i2c_msg *msgs,
++			      int num)
++{
++	int ret;
++
++	ret = __i2c_transfer(i2c, msgs, num);
++	if (ret < 0)
++		return ret;
++	else if (ret != num)
++		return -EIO;
++	else
++		return 0;
++}
++
++static int __i2c_rollball_get_page(struct i2c_adapter *i2c, int bus_addr,
++				   u8 *page)
++{
++	struct i2c_msg msgs[2];
++	u8 addr = SFP_PAGE;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &addr;
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = 1;
++	msgs[1].buf = page;
++
++	return __i2c_transfer_err(i2c, msgs, 2);
++}
++
++static int __i2c_rollball_set_page(struct i2c_adapter *i2c, int bus_addr,
++				   u8 page)
++{
++	struct i2c_msg msg;
++	u8 buf[2];
++
++	buf[0] = SFP_PAGE;
++	buf[1] = page;
++
++	msg.addr = bus_addr;
++	msg.flags = 0;
++	msg.len = 2;
++	msg.buf = buf;
++
++	return __i2c_transfer_err(i2c, &msg, 1);
++}
++
++/* In order to not interfere with other SFP code (which possibly may manipulate
++ * SFP_PAGE), for every transfer we do this:
++ *   1. lock the bus
++ *   2. save content of SFP_PAGE
++ *   3. set SFP_PAGE to 3
++ *   4. do the transfer
++ *   5. restore original SFP_PAGE
++ *   6. unlock the bus
++ * Note that one might think that steps 2 to 5 could be theoretically done all
++ * in one call to i2c_transfer (by constructing msgs array in such a way), but
++ * unfortunately tests show that this does not work :-( Changed SFP_PAGE does
++ * not take into account until i2c_transfer() is done.
++ */
++static int i2c_transfer_rollball(struct i2c_adapter *i2c,
++				 struct i2c_msg *msgs, int num)
++{
++	int ret, main_err = 0;
++	u8 saved_page;
++
++	i2c_lock_bus(i2c, I2C_LOCK_SEGMENT);
++
++	/* save original page */
++	ret = __i2c_rollball_get_page(i2c, msgs->addr, &saved_page);
++	if (ret)
++		goto unlock;
++
++	/* change to RollBall MDIO page */
++	ret = __i2c_rollball_set_page(i2c, msgs->addr, SFP_PAGE_ROLLBALL_MDIO);
++	if (ret)
++		goto unlock;
++
++	/* do the transfer; we try to restore original page if this fails */
++	ret = __i2c_transfer_err(i2c, msgs, num);
++	if (ret)
++		main_err = ret;
++
++	/* restore original page */
++	ret = __i2c_rollball_set_page(i2c, msgs->addr, saved_page);
++
++unlock:
++	i2c_unlock_bus(i2c, I2C_LOCK_SEGMENT);
++
++	return main_err ? : ret;
++}
++
++static int i2c_rollball_mii_poll(struct mii_bus *bus, int bus_addr, u8 *buf,
++				 size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 cmd_addr, tmp, *res;
++	int i, ret;
++
++	cmd_addr = ROLLBALL_CMD_ADDR;
++
++	res = buf ? buf : &tmp;
++	len = buf ? len : 1;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = 1;
++	msgs[0].buf = &cmd_addr;
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = I2C_M_RD;
++	msgs[1].len = len;
++	msgs[1].buf = res;
++
++	/* By experiment it takes up to 70 ms to access a register for these
++	 * SFPs. Sleep 20ms between iterations and try 10 times.
++	 */
++	i = 10;
++	do {
++		msleep(20);
++
++		ret = i2c_transfer_rollball(i2c, msgs, ARRAY_SIZE(msgs));
++		if (ret)
++			return ret;
++
++		if (*res == ROLLBALL_CMD_DONE)
++			return 0;
++	} while (i-- > 0);
++
++	dev_dbg(&bus->dev, "poll timed out\n");
++
++	return -ETIMEDOUT;
++}
++
++static int i2c_rollball_mii_cmd(struct mii_bus *bus, int bus_addr, u8 cmd,
++				u8 *data, size_t len)
++{
++	struct i2c_adapter *i2c = bus->priv;
++	struct i2c_msg msgs[2];
++	u8 cmdbuf[2];
++
++	cmdbuf[0] = ROLLBALL_CMD_ADDR;
++	cmdbuf[1] = cmd;
++
++	msgs[0].addr = bus_addr;
++	msgs[0].flags = 0;
++	msgs[0].len = len;
++	msgs[0].buf = data;
++
++	msgs[1].addr = bus_addr;
++	msgs[1].flags = 0;
++	msgs[1].len = sizeof(cmdbuf);
++	msgs[1].buf = cmdbuf;
++
++	return i2c_transfer_rollball(i2c, msgs, ARRAY_SIZE(msgs));
++}
++
++static int i2c_mii_read_rollball(struct mii_bus *bus, int phy_id, int reg)
++{
++	u8 buf[4], res[6];
++	int bus_addr, ret;
++	u16 val;
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++	if (bus_addr != ROLLBALL_PHY_I2C_ADDR)
++		return 0xffff;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_READ, buf,
++				   sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, res, sizeof(res));
++	if (ret == -ETIMEDOUT)
++		return 0xffff;
++	else if (ret < 0)
++		return ret;
++
++	val = res[4] << 8 | res[5];
++
++	return val;
++}
++
++static int i2c_mii_write_rollball(struct mii_bus *bus, int phy_id, int reg,
++				  u16 val)
++{
++	int bus_addr, ret;
++	u8 buf[6];
++
++	if (!(reg & MII_ADDR_C45))
++		return -EOPNOTSUPP;
++
++	bus_addr = i2c_mii_phy_addr(phy_id);
++	if (bus_addr != ROLLBALL_PHY_I2C_ADDR)
++		return 0;
++
++	buf[0] = ROLLBALL_DATA_ADDR;
++	buf[1] = (reg >> 16) & 0x1f;
++	buf[2] = (reg >> 8) & 0xff;
++	buf[3] = reg & 0xff;
++	buf[4] = val >> 8;
++	buf[5] = val & 0xff;
++
++	ret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_WRITE, buf,
++				   sizeof(buf));
++	if (ret < 0)
++		return ret;
++
++	ret = i2c_rollball_mii_poll(bus, bus_addr, NULL, 0);
++	if (ret < 0)
++		return ret;
++
++	return 0;
++}
++
++static int i2c_mii_init_rollball(struct i2c_adapter *i2c)
++{
++	struct i2c_msg msg;
++	u8 pw[5];
++	int ret;
++
++	pw[0] = ROLLBALL_PASSWORD;
++	pw[1] = 0xff;
++	pw[2] = 0xff;
++	pw[3] = 0xff;
++	pw[4] = 0xff;
++
++	msg.addr = ROLLBALL_PHY_I2C_ADDR;
++	msg.flags = 0;
++	msg.len = sizeof(pw);
++	msg.buf = pw;
++
++	ret = i2c_transfer(i2c, &msg, 1);
++	if (ret < 0)
++		return ret;
++	else if (ret != 1)
++		return -EIO;
++	else
++		return 0;
++}
++
++struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c,
++			       enum mdio_i2c_proto protocol)
+ {
+ 	struct mii_bus *mii;
++	int ret;
+
+ 	if (!i2c_check_functionality(i2c, I2C_FUNC_I2C))
+ 		return ERR_PTR(-EINVAL);
+@@ -104,10 +386,28 @@ struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c)
+
+ 	snprintf(mii->id, MII_BUS_ID_SIZE, "i2c:%s", dev_name(parent));
+ 	mii->parent = parent;
+-	mii->read = i2c_mii_read;
+-	mii->write = i2c_mii_write;
+ 	mii->priv = i2c;
+
++	switch (protocol) {
++	case MDIO_I2C_ROLLBALL:
++		ret = i2c_mii_init_rollball(i2c);
++		if (ret < 0) {
++			dev_err(parent,
++				"Cannot initialize RollBall MDIO I2C protocol: %d\n",
++				ret);
++			mdiobus_free(mii);
++			return ERR_PTR(ret);
++		}
++
++		mii->read = i2c_mii_read_rollball;
++		mii->write = i2c_mii_write_rollball;
++		break;
++	default:
++		mii->read = i2c_mii_read_default;
++		mii->write = i2c_mii_write_default;
++		break;
++	}
++
+ 	return mii;
+ }
+ EXPORT_SYMBOL_GPL(mdio_i2c_alloc);
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 5932addfc5d9..b2c8c640ac96 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -548,7 +548,7 @@ static int sfp_i2c_mdiobus_create(struct sfp *sfp)
+ 	struct mii_bus *i2c_mii;
+ 	int ret;
+
+-	i2c_mii = mdio_i2c_alloc(sfp->dev, sfp->i2c);
++	i2c_mii = mdio_i2c_alloc(sfp->dev, sfp->i2c, sfp->mdio_protocol);
+ 	if (IS_ERR(i2c_mii))
+ 		return PTR_ERR(i2c_mii);
+
+@@ -1770,6 +1770,10 @@ static int sfp_sm_probe_for_phy(struct sfp *sfp)
+ 	case MDIO_I2C_C45:
+ 		err = sfp_sm_probe_phy(sfp, true);
+ 		break;
++
++	case MDIO_I2C_ROLLBALL:
++		err = -EOPNOTSUPP;
++		break;
+ 	}
+
+ 	return err;
+diff --git a/include/linux/mdio/mdio-i2c.h b/include/linux/mdio/mdio-i2c.h
+index 3bde1a555a49..65b550a6fc32 100644
+--- a/include/linux/mdio/mdio-i2c.h
++++ b/include/linux/mdio/mdio-i2c.h
+@@ -15,8 +15,10 @@ enum mdio_i2c_proto {
+ 	MDIO_I2C_NONE,
+ 	MDIO_I2C_MARVELL_C22,
+ 	MDIO_I2C_C45,
++	MDIO_I2C_ROLLBALL,
+ };
+
+-struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c);
++struct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c,
++			       enum mdio_i2c_proto protocol);
+
+ #endif
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-10-net-sfp-add-support-for-multigig-RollBall-transceive.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-10-net-sfp-add-support-for-multigig-RollBall-transceive.patch
new file mode 100644
index 0000000000..1d775870a1
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-10-net-sfp-add-support-for-multigig-RollBall-transceive.patch
@@ -0,0 +1,156 @@
+From 4997e61943215ab7940ca633def47f743edc8970 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Fri, 5 Nov 2021 00:21:19 +0100
+Subject: [PATCH 10/12] net: sfp: add support for multigig RollBall
+ transceivers
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for multigig copper SFP modules from RollBall/Hilink.
+These modules have a specific way to access clause 45 registers of the
+internal PHY.
+
+We also need to wait at least 22 seconds after deasserting TX disable
+before accessing the PHY. The code waits for 25 seconds just to be sure.
+
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+Reviewed-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/sfp-bus.c |  6 ++++++
+ drivers/net/phy/sfp.c     | 41 ++++++++++++++++++++++++++++-----------
+ 2 files changed, 36 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 0a9099c77694..22dba5895ef6 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -130,6 +130,12 @@ bool sfp_may_have_phy(struct sfp_bus *bus, const struct sfp_eeprom_id *id)
+ 		}
+ 	}
+
++	if (((!memcmp(id->base.vendor_name, "OEM             ", 16) ||
++	      !memcmp(id->base.vendor_name, "Turris          ", 16)) &&
++	     (!memcmp(id->base.vendor_pn, "SFP-10G-T       ", 16) ||
++	      !memcmp(id->base.vendor_pn, "RTSFP-10", 8))))
++		return true;
++
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(sfp_may_have_phy);
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index b2c8c640ac96..49e69f1d9b1b 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -166,6 +166,7 @@ static const enum gpiod_flags gpio_flags[] = {
+  * on board (for a copper SFP) time to initialise.
+  */
+ #define T_WAIT			msecs_to_jiffies(50)
++#define T_WAIT_ROLLBALL		msecs_to_jiffies(25000)
+ #define T_START_UP		msecs_to_jiffies(300)
+ #define T_START_UP_BAD_GPON	msecs_to_jiffies(60000)
+
+@@ -205,8 +206,11 @@ static const enum gpiod_flags gpio_flags[] = {
+
+ /* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
++ * RollBall SFPs access phy via SFP Enhanced Digital Diagnostic Interface
++ * via address 0x51 (mdio-i2c will use RollBall protocol on this address).
+  */
+-#define SFP_PHY_ADDR	22
++#define SFP_PHY_ADDR		22
++#define SFP_PHY_ADDR_ROLLBALL	17
+
+ struct sff_data {
+ 	unsigned int gpios;
+@@ -252,6 +256,7 @@ struct sfp {
+ 	struct sfp_eeprom_id id;
+ 	unsigned int module_power_mW;
+ 	unsigned int module_t_start_up;
++	unsigned int module_t_wait;
+ 	bool tx_fault_ignore;
+
+ 	const struct sfp_quirk *quirk;
+@@ -1636,12 +1641,12 @@ static void sfp_sm_phy_detach(struct sfp *sfp)
+ 	sfp->mod_phy = NULL;
+ }
+
+-static int sfp_sm_probe_phy(struct sfp *sfp, bool is_c45)
++static int sfp_sm_probe_phy(struct sfp *sfp, int addr, bool is_c45)
+ {
+ 	struct phy_device *phy;
+ 	int err;
+
+-	phy = get_phy_device(sfp->i2c_mii, SFP_PHY_ADDR, is_c45);
++	phy = get_phy_device(sfp->i2c_mii, addr, is_c45);
+ 	if (phy == ERR_PTR(-ENODEV))
+ 		return PTR_ERR(phy);
+ 	if (IS_ERR(phy)) {
+@@ -1764,15 +1769,15 @@ static int sfp_sm_probe_for_phy(struct sfp *sfp)
+ 		break;
+
+ 	case MDIO_I2C_MARVELL_C22:
+-		err = sfp_sm_probe_phy(sfp, false);
++		err = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR, false);
+ 		break;
+
+ 	case MDIO_I2C_C45:
+-		err = sfp_sm_probe_phy(sfp, true);
++		err = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR, true);
+ 		break;
+
+ 	case MDIO_I2C_ROLLBALL:
+-		err = -EOPNOTSUPP;
++		err = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR_ROLLBALL, true);
+ 		break;
+ 	}
+
+@@ -2097,7 +2102,20 @@ static int sfp_sm_mod_probe(struct sfp *sfp, bool report)
+ 	if (sfp->quirk && sfp->quirk->fixup)
+ 		sfp->quirk->fixup(sfp);
+
+-	if (sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SFI ||
++	sfp->module_t_wait = T_WAIT;
++
++	if (((!memcmp(id.base.vendor_name, "OEM             ", 16) ||
++	      !memcmp(id.base.vendor_name, "Turris          ", 16)) &&
++	     (!memcmp(id.base.vendor_pn, "SFP-10G-T       ", 16) ||
++	      !memcmp(id.base.vendor_pn, "RTSFP-10", 8)))) {
++		sfp->mdio_protocol = MDIO_I2C_ROLLBALL;
++		sfp->module_t_wait = T_WAIT_ROLLBALL;
++
++		/* RollBall SFPs may have wrong (zero) extended compliance code
++		 * burned in EEPROM. For PHY probing we need the correct one.
++		 */
++		id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;
++	} else if (sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SFI ||
+ 	    sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SR ||
+ 	    sfp->id.base.extended_cc == SFF8024_ECC_5GBASE_T ||
+ 	    sfp->id.base.extended_cc == SFF8024_ECC_2_5GBASE_T)
+@@ -2303,9 +2321,10 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+
+ 		/* We need to check the TX_FAULT state, which is not defined
+ 		 * while TX_DISABLE is asserted. The earliest we want to do
+-		 * anything (such as probe for a PHY) is 50ms.
++		 * anything (such as probe for a PHY) is 50ms (or more on
++		 * specific modules).
+ 		 */
+-		sfp_sm_next(sfp, SFP_S_WAIT, T_WAIT);
++		sfp_sm_next(sfp, SFP_S_WAIT, sfp->module_t_wait);
+ 		break;
+
+ 	case SFP_S_WAIT:
+@@ -2319,8 +2338,8 @@ static void sfp_sm_main(struct sfp *sfp, unsigned int event)
+ 			 * deasserting.
+ 			 */
+ 			timeout = sfp->module_t_start_up;
+-			if (timeout > T_WAIT)
+-				timeout -= T_WAIT;
++			if (timeout > sfp->module_t_wait)
++				timeout -= sfp->module_t_wait;
+ 			else
+ 				timeout = 1;
+
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-11-net-sfp-augment-SFP-parsing-with-phy_interface_t-bit.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-11-net-sfp-augment-SFP-parsing-with-phy_interface_t-bit.patch
new file mode 100644
index 0000000000..bda0114281
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-11-net-sfp-augment-SFP-parsing-with-phy_interface_t-bit.patch
@@ -0,0 +1,340 @@
+From abdd0ad38b4e970f98600cdde9de37e2dbbcad5f Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 11:57:39 +0000
+Subject: [PATCH 11/12] net: sfp: augment SFP parsing with phy_interface_t
+ bitmap
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We currently parse the SFP EEPROM to a bitmap of ethtool link modes,
+and then attempt to convert the link modes to a PHY interface mode.
+While this works at present, there are cases where this is sub-optimal.
+For example, where a module can operate with several different PHY
+interface modes.
+
+To start addressing this, arrange for the SFP EEPROM parsing to also
+provide a bitmap of the possible PHY interface modes.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[ added 5gbase-r interface ]
+Signed-off-by: Marek Beh√∫n <kabel@kernel.org>
+---
+ drivers/net/phy/marvell-88x2222.c |  3 +-
+ drivers/net/phy/marvell.c         |  3 +-
+ drivers/net/phy/marvell10g.c      |  3 +-
+ drivers/net/phy/phylink.c         |  4 +-
+ drivers/net/phy/sfp-bus.c         | 68 +++++++++++++++++++++++--------
+ drivers/net/phy/sfp.c             |  7 +++-
+ drivers/net/phy/sfp.h             |  3 +-
+ include/linux/sfp.h               |  5 ++-
+ 8 files changed, 71 insertions(+), 25 deletions(-)
+
+diff --git a/drivers/net/phy/marvell-88x2222.c b/drivers/net/phy/marvell-88x2222.c
+index d8b31d4d2a73..ae285e4225d6 100644
+--- a/drivers/net/phy/marvell-88x2222.c
++++ b/drivers/net/phy/marvell-88x2222.c
+@@ -478,6 +478,7 @@ static int mv2222_config_init(struct phy_device *phydev)
+
+ static int mv2222_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ {
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	struct phy_device *phydev = upstream;
+ 	phy_interface_t sfp_interface;
+ 	struct mv2222_data *priv;
+@@ -489,7 +490,7 @@ static int mv2222_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ 	priv = (struct mv2222_data *)phydev->priv;
+ 	dev = &phydev->mdio.dev;
+
+-	sfp_parse_support(phydev->sfp_bus, id, sfp_supported);
++	sfp_parse_support(phydev->sfp_bus, id, sfp_supported, interfaces);
+ 	sfp_interface = sfp_select_interface(phydev->sfp_bus, sfp_supported);
+
+ 	dev_info(dev, "%s SFP module inserted\n", phy_modes(sfp_interface));
+diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
+index 4d726ee03ce2..288befc9f44b 100644
+--- a/drivers/net/phy/marvell.c
++++ b/drivers/net/phy/marvell.c
+@@ -2806,6 +2806,7 @@ static int marvell_probe(struct phy_device *phydev)
+
+ static int m88e1510_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ {
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	struct phy_device *phydev = upstream;
+ 	phy_interface_t interface;
+ 	struct device *dev;
+@@ -2817,7 +2818,7 @@ static int m88e1510_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+
+ 	dev = &phydev->mdio.dev;
+
+-	sfp_parse_support(phydev->sfp_bus, id, supported);
++	sfp_parse_support(phydev->sfp_bus, id, supported, interfaces);
+ 	interface = sfp_select_interface(phydev->sfp_bus, supported);
+
+ 	dev_info(dev, "%s SFP module inserted\n", phy_modes(interface));
+diff --git a/drivers/net/phy/marvell10g.c b/drivers/net/phy/marvell10g.c
+index b16e67b352bf..c07d51907418 100644
+--- a/drivers/net/phy/marvell10g.c
++++ b/drivers/net/phy/marvell10g.c
+@@ -473,9 +473,10 @@ static int mv3310_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)
+ {
+ 	struct phy_device *phydev = upstream;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(support) = { 0, };
++	DECLARE_PHY_INTERFACE_MASK(interfaces);
+ 	phy_interface_t iface;
+
+-	sfp_parse_support(phydev->sfp_bus, id, support);
++	sfp_parse_support(phydev->sfp_bus, id, support, interfaces);
+ 	iface = sfp_select_interface(phydev->sfp_bus, support);
+
+ 	if (iface != PHY_INTERFACE_MODE_10GBASER) {
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index f1fad9e18d03..7d0b7a2e69d8 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -77,6 +77,7 @@ struct phylink {
+
+ 	struct sfp_bus *sfp_bus;
+ 	bool sfp_may_have_phy;
++	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);
+ 	u8 sfp_port;
+ };
+@@ -2385,7 +2386,8 @@ static int phylink_sfp_module_insert(void *upstream,
+ 	ASSERT_RTNL();
+
+ 	linkmode_zero(support);
+-	sfp_parse_support(pl->sfp_bus, id, support);
++	phy_interface_zero(pl->sfp_interfaces);
++	sfp_parse_support(pl->sfp_bus, id, support, pl->sfp_interfaces);
+ 	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
+
+ 	/* If this module may have a PHY connecting later, defer until later */
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 22dba5895ef6..98af41843cce 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -145,12 +145,14 @@ EXPORT_SYMBOL_GPL(sfp_may_have_phy);
+  * @bus: a pointer to the &struct sfp_bus structure for the sfp module
+  * @id: a pointer to the module's &struct sfp_eeprom_id
+  * @support: pointer to an array of unsigned long for the ethtool support mask
++ * @interfaces: pointer to an array of unsigned long for phy interface modes
++ *		mask
+  *
+  * Parse the EEPROM identification information and derive the supported
+  * ethtool link modes for the module.
+  */
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support)
++		       unsigned long *support, unsigned long *interfaces)
+ {
+ 	unsigned int br_min, br_nom, br_max;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(modes) = { 0, };
+@@ -177,27 +179,41 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	}
+
+ 	/* Set ethtool support from the compliance fields. */
+-	if (id->base.e10g_base_sr)
++	if (id->base.e10g_base_sr) {
+ 		phylink_set(modes, 10000baseSR_Full);
+-	if (id->base.e10g_base_lr)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lr) {
+ 		phylink_set(modes, 10000baseLR_Full);
+-	if (id->base.e10g_base_lrm)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_lrm) {
+ 		phylink_set(modes, 10000baseLRM_Full);
+-	if (id->base.e10g_base_er)
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
++	if (id->base.e10g_base_er) {
+ 		phylink_set(modes, 10000baseER_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++	}
+ 	if (id->base.e1000_base_sx ||
+ 	    id->base.e1000_base_lx ||
+-	    id->base.e1000_base_cx)
++	    id->base.e1000_base_cx) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+ 	if (id->base.e1000_base_t) {
+ 		phylink_set(modes, 1000baseT_Half);
+ 		phylink_set(modes, 1000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		__set_bit(PHY_INTERFACE_MODE_SGMII, interfaces);
+ 	}
+
+ 	/* 1000Base-PX or 1000Base-BX10 */
+ 	if ((id->base.e_base_px || id->base.e_base_bx10) &&
+-	    br_min <= 1300 && br_max >= 1200)
++	    br_min <= 1300 && br_max >= 1200) {
+ 		phylink_set(modes, 1000baseX_Full);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++	}
+
+ 	/* 100Base-FX, 100Base-LX, 100Base-PX, 100Base-BX10 */
+ 	if (id->base.e100_base_fx || id->base.e100_base_lx)
+@@ -210,21 +226,30 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	 */
+ 	if ((id->base.sfp_ct_passive || id->base.sfp_ct_active) && br_nom) {
+ 		/* This may look odd, but some manufacturers use 12000MBd */
+-		if (br_min <= 12000 && br_max >= 10300)
++		if (br_min <= 12000 && br_max >= 10300) {
+ 			phylink_set(modes, 10000baseCR_Full);
+-		if (br_min <= 3200 && br_max >= 3100)
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
++		if (br_min <= 3200 && br_max >= 3100) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (br_min <= 1300 && br_max >= 1200)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_passive) {
+-		if (id->base.passive.sff8431_app_e)
++		if (id->base.passive.sff8431_app_e) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
++		}
+ 	}
+ 	if (id->base.sfp_ct_active) {
+ 		if (id->base.active.sff8431_app_e ||
+ 		    id->base.active.sff8431_lim) {
+ 			phylink_set(modes, 10000baseCR_Full);
++			__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		}
+ 	}
+
+@@ -249,12 +274,15 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	case SFF8024_ECC_10GBASE_T_SFI:
+ 	case SFF8024_ECC_10GBASE_T_SR:
+ 		phylink_set(modes, 10000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);
+ 		break;
+ 	case SFF8024_ECC_5GBASE_T:
+ 		phylink_set(modes, 5000baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_5GBASER, interfaces);
+ 		break;
+ 	case SFF8024_ECC_2_5GBASE_T:
+ 		phylink_set(modes, 2500baseT_Full);
++		__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ 		break;
+ 	default:
+ 		dev_warn(bus->sfp_dev,
+@@ -267,10 +295,14 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (id->base.fc_speed_100 ||
+ 	    id->base.fc_speed_200 ||
+ 	    id->base.fc_speed_400) {
+-		if (id->base.br_nominal >= 31)
++		if (id->base.br_nominal >= 31) {
+ 			phylink_set(modes, 2500baseX_Full);
+-		if (id->base.br_nominal >= 12)
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
++		if (id->base.br_nominal >= 12) {
+ 			phylink_set(modes, 1000baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
+ 	}
+
+ 	/* If we haven't discovered any modes that this module supports, try
+@@ -283,14 +315,18 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	 * 2500BASE-X, so we allow some slack here.
+ 	 */
+ 	if (bitmap_empty(modes, __ETHTOOL_LINK_MODE_MASK_NBITS) && br_nom) {
+-		if (br_min <= 1300 && br_max >= 1200)
++		if (br_min <= 1300 && br_max >= 1200) {
+ 			phylink_set(modes, 1000baseX_Full);
+-		if (br_min <= 3200 && br_max >= 2500)
++			__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
++		}
++		if (br_min <= 3200 && br_max >= 2500) {
+ 			phylink_set(modes, 2500baseX_Full);
++			__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
++		}
+ 	}
+
+ 	if (bus->sfp_quirk && bus->sfp_quirk->modes)
+-		bus->sfp_quirk->modes(id, modes);
++		bus->sfp_quirk->modes(id, modes, interfaces);
+
+ 	linkmode_or(support, support, modes);
+
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 49e69f1d9b1b..02c55fdae8be 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -333,13 +333,15 @@ static void sfp_fixup_halny_gsfp(struct sfp *sfp)
+ }
+
+ static void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,
+-				unsigned long *modes)
++				unsigned long *modes, unsigned long *interfaces)
+ {
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);
++	__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);
+ }
+
+ static void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,
+-				      unsigned long *modes)
++				      unsigned long *modes,
++				      unsigned long *interfaces)
+ {
+ 	/* Ubiquiti U-Fiber Instant module claims that support all transceiver
+ 	 * types including 10G Ethernet which is not truth. So clear all claimed
+@@ -347,6 +349,7 @@ static void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,
+ 	 */
+ 	linkmode_zero(modes);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);
++	__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);
+ }
+
+ static const struct sfp_quirk sfp_quirks[] = {
+diff --git a/drivers/net/phy/sfp.h b/drivers/net/phy/sfp.h
+index 7ad06deae76c..6cf1643214d3 100644
+--- a/drivers/net/phy/sfp.h
++++ b/drivers/net/phy/sfp.h
+@@ -9,7 +9,8 @@ struct sfp;
+ struct sfp_quirk {
+ 	const char *vendor;
+ 	const char *part;
+-	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes);
++	void (*modes)(const struct sfp_eeprom_id *id, unsigned long *modes,
++		      unsigned long *interfaces);
+ 	void (*fixup)(struct sfp *sfp);
+ };
+
+diff --git a/include/linux/sfp.h b/include/linux/sfp.h
+index 302094b855fb..d1f343853b6c 100644
+--- a/include/linux/sfp.h
++++ b/include/linux/sfp.h
+@@ -535,7 +535,7 @@ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support);
+ bool sfp_may_have_phy(struct sfp_bus *bus, const struct sfp_eeprom_id *id);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+-		       unsigned long *support);
++		       unsigned long *support, unsigned long *interfaces);
+ phy_interface_t sfp_select_interface(struct sfp_bus *bus,
+ 				     unsigned long *link_modes);
+
+@@ -568,7 +568,8 @@ static inline bool sfp_may_have_phy(struct sfp_bus *bus,
+
+ static inline void sfp_parse_support(struct sfp_bus *bus,
+ 				     const struct sfp_eeprom_id *id,
+-				     unsigned long *support)
++				     unsigned long *support,
++				     unsigned long *interfaces)
+ {
+ }
+
+--
+2.35.1
+
diff --git a/target/linux/mvebu/patches-5.15/706-TurrisSFP-12-net-phylink-use-phy_interface_t-bitmaps-for-optical-.patch b/target/linux/mvebu/patches-5.15/706-TurrisSFP-12-net-phylink-use-phy_interface_t-bitmaps-for-optical-.patch
new file mode 100644
index 0000000000..c1adcacf27
--- /dev/null
+++ b/target/linux/mvebu/patches-5.15/706-TurrisSFP-12-net-phylink-use-phy_interface_t-bitmaps-for-optical-.patch
@@ -0,0 +1,203 @@
+From c069d5a6e0a41c84d49f870340757910c652cf21 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 3 Mar 2020 12:12:43 +0000
+Subject: [PATCH 12/12] net: phylink: use phy_interface_t bitmaps for optical
+ modules
+
+Where a MAC provides a phy_interface_t bitmap, use these bitmaps to
+select the operating interface mode for optical SFP modules, rather
+than using the linkmode bitmaps.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[ rebased, added 5GBASER into preference array ]
+---
+ drivers/net/phy/phylink.c | 138 ++++++++++++++++++++++++++++++++++----
+ 1 file changed, 124 insertions(+), 14 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 7d0b7a2e69d8..4861924303ee 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -2296,6 +2296,42 @@ static void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)
+ 	pl->netdev->sfp_bus = NULL;
+ }
+
++static const phy_interface_t phylink_sfp_interface_preference[] = {
++	PHY_INTERFACE_MODE_USXGMII,
++	PHY_INTERFACE_MODE_10GBASER,
++	PHY_INTERFACE_MODE_5GBASER,
++	PHY_INTERFACE_MODE_2500BASEX,
++	PHY_INTERFACE_MODE_SGMII,
++	PHY_INTERFACE_MODE_1000BASEX,
++	PHY_INTERFACE_MODE_100BASEX,
++};
++
++static phy_interface_t phylink_select_interface(struct phylink *pl,
++						const unsigned long *intf,
++						const char *intf_name)
++{
++	DECLARE_PHY_INTERFACE_MASK(u);
++	phy_interface_t interface;
++	size_t i;
++
++	phy_interface_and(u, intf, pl->config->supported_interfaces);
++
++	interface = PHY_INTERFACE_MODE_NA;
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)
++		if (test_bit(phylink_sfp_interface_preference[i], u)) {
++			interface = phylink_sfp_interface_preference[i];
++			break;
++		}
++
++	phylink_dbg(pl, "interfaces=[mac=%*pbl %s=%*pbl] selected %d (%s)\n",
++		    (int)PHY_INTERFACE_MODE_MAX,
++		    pl->config->supported_interfaces,
++		    intf_name, (int)PHY_INTERFACE_MODE_MAX, intf,
++		    interface, phy_modes(interface));
++
++	return interface;
++}
++
+ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 			      const unsigned long *supported,
+ 			      const unsigned long *advertising)
+@@ -2377,25 +2413,102 @@ static int phylink_sfp_config(struct phylink *pl, u8 mode,
+ 	return ret;
+ }
+
++static int phylink_sfp_config_nophy(struct phylink *pl)
++{
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(support);
++	struct phylink_link_state config;
++	phy_interface_t interface;
++	bool changed;
++	int ret;
++
++	if (phy_interface_empty(pl->config->supported_interfaces))
++		return phylink_sfp_config(pl, MLO_AN_INBAND,
++					  pl->sfp_support, pl->sfp_support);
++
++	memset(&config, 0, sizeof(config));
++	linkmode_copy(config.advertising, pl->sfp_support);
++	config.interface = PHY_INTERFACE_MODE_NA;
++	config.speed = SPEED_UNKNOWN;
++	config.duplex = DUPLEX_UNKNOWN;
++	config.pause = MLO_PAUSE_AN;
++	config.an_enabled = true;
++
++	/* Get the full range of supported link modes */
++	ret = phylink_validate(pl, pl->sfp_support, &config);
++	if (ret) {
++		phylink_err(pl,
++			    "initial validation with support %*pb failed: %d\n",
++			    __ETHTOOL_LINK_MODE_MASK_NBITS, support, ret);
++		return ret;
++	}
++
++	interface = phylink_select_interface(pl, pl->sfp_interfaces, "sfp");
++	if (interface == PHY_INTERFACE_MODE_NA)
++		return -EINVAL;
++
++	linkmode_copy(support, pl->sfp_support);
++	config.interface = interface;
++
++	/* Ignore errors if we're expecting a PHY to attach later */
++	ret = phylink_validate(pl, support, &config);
++	if (ret) {
++		phylink_err(pl, "validation with support %*pb failed: %d\n",
++			    __ETHTOOL_LINK_MODE_MASK_NBITS, support, ret);
++		return ret;
++	}
++
++	phylink_dbg(pl, "requesting link mode %s/%s with support %*pb\n",
++		    phylink_an_mode_str(MLO_AN_INBAND),
++		    phy_modes(config.interface),
++		    __ETHTOOL_LINK_MODE_MASK_NBITS, pl->sfp_support);
++
++	changed = !linkmode_equal(pl->supported, pl->sfp_support) ||
++		  !linkmode_equal(pl->link_config.advertising,
++				  config.advertising);
++	if (changed) {
++		linkmode_copy(pl->supported, pl->sfp_support);
++		linkmode_copy(pl->link_config.advertising, config.advertising);
++	}
++
++	if (pl->cur_link_an_mode != MLO_AN_INBAND ||
++	    pl->link_config.interface != config.interface) {
++		pl->link_config.interface = config.interface;
++		pl->cur_link_an_mode = MLO_AN_INBAND;
++
++		changed = true;
++
++		phylink_info(pl, "switched to %s/%s link mode\n",
++			     phylink_an_mode_str(MLO_AN_INBAND),
++			     phy_modes(config.interface));
++	}
++
++	pl->link_port = pl->sfp_port;
++
++	if (changed && !test_bit(PHYLINK_DISABLE_STOPPED,
++				 &pl->phylink_disable_state))
++		phylink_mac_initial_config(pl, false);
++
++	return 0;
++}
++
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+ 	struct phylink *pl = upstream;
+-	unsigned long *support = pl->sfp_support;
+
+ 	ASSERT_RTNL();
+
+-	linkmode_zero(support);
++	linkmode_zero(pl->sfp_support);
+ 	phy_interface_zero(pl->sfp_interfaces);
+-	sfp_parse_support(pl->sfp_bus, id, support, pl->sfp_interfaces);
+-	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, support);
++	sfp_parse_support(pl->sfp_bus, id, pl->sfp_support, pl->sfp_interfaces);
++	pl->sfp_port = sfp_parse_port(pl->sfp_bus, id, pl->sfp_support);
+
+ 	/* If this module may have a PHY connecting later, defer until later */
+ 	pl->sfp_may_have_phy = sfp_may_have_phy(pl->sfp_bus, id);
+ 	if (pl->sfp_may_have_phy)
+ 		return 0;
+
+-	return phylink_sfp_config(pl, MLO_AN_INBAND, support, support);
++	return phylink_sfp_config_nophy(pl);
+ }
+
+ static int phylink_sfp_module_start(void *upstream)
+@@ -2414,8 +2527,7 @@ static int phylink_sfp_module_start(void *upstream)
+ 	if (!pl->sfp_may_have_phy)
+ 		return 0;
+
+-	return phylink_sfp_config(pl, MLO_AN_INBAND,
+-				  pl->sfp_support, pl->sfp_support);
++	return phylink_sfp_config_nophy(pl);
+ }
+
+ static void phylink_sfp_module_stop(void *upstream)
+@@ -2867,13 +2979,11 @@ EXPORT_SYMBOL_GPL(phylink_mii_c45_pcs_get_state);
+
+ static int __init phylink_init(void)
+ {
+-	__set_bit(PHY_INTERFACE_MODE_USXGMII, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_10GBASER, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_5GBASER, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_2500BASEX, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_SGMII, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_1000BASEX, phylink_sfp_interfaces);
+-	__set_bit(PHY_INTERFACE_MODE_100BASEX, phylink_sfp_interfaces);
++	int i;
++
++	for (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); ++i)
++		__set_bit(phylink_sfp_interface_preference[i],
++			  phylink_sfp_interfaces);
+
+ 	return 0;
+ }
+--
+2.35.1
+
--
2.35.1

