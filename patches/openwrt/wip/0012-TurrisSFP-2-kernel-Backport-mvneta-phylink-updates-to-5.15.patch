From 30dce46ace422111d513009f6511c817adad4ae2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Fri, 23 Sep 2022 12:00:13 +0200
Subject: [PATCH 2/9] kernel: Backport mvneta-phylink updates to 5.15
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This backports Russell King's patch series mvneta-phylink from 5.16
  fdedb695e6a8 ("net: mvneta: populate supported_interfaces member")
  d9ca72807ecb ("net: mvneta: remove interface checks in mvneta_validate()")
  099cbfa286ab ("net: mvneta: drop use of phylink_helper_basex_speed()")
and also it's dependency by Sean Anderson
  4973056cceac ("net: convert users of bitmap_foo() to linkmode_foo()")

The original cover letter said:
  Convert mvneta to phylink supported_interfaces

  This patch series converts mvneta to use phylinks supported_interfaces
  bitmap to simplify the validate() implementation. The patches:

  1) Add the supported interface modes the supported_interfaces bitmap.
  2) Removes the checks for the interface type being supported from
     the validate callback
  3) Removes the now unnecessary checks and call to
     phylink_helper_basex_speed() to support switching between
     1000base-X and 2500base-X for SFPs

  (3) becomes possible because when asking the MAC for its complete
  support, we walk all supported interfaces which will include 1000base-X
  and 2500base-X only if the comphy is present.

Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
---
 ...-users-of-bitmap_foo-to-linkmode_foo.patch | 1009 +++++++++++++++++
 ...populate-supported_interfaces-member.patch |   53 +
 ...e-interface-checks-in-mvneta_validat.patch |   40 +
 ...op-use-of-phylink_helper_basex_speed.patch |   60 +
 4 files changed, 1162 insertions(+)
 create mode 100644 target/linux/generic/backport-5.15/776-v5.16-1-net-convert-users-of-bitmap_foo-to-linkmode_foo.patch
 create mode 100644 target/linux/generic/backport-5.15/776-v5.16-2-net-mvneta-populate-supported_interfaces-member.patch
 create mode 100644 target/linux/generic/backport-5.15/776-v5.16-3-net-mvneta-remove-interface-checks-in-mvneta_validat.patch
 create mode 100644 target/linux/generic/backport-5.15/776-v5.16-4-net-mvneta-drop-use-of-phylink_helper_basex_speed.patch

diff --git a/target/linux/generic/backport-5.15/776-v5.16-1-net-convert-users-of-bitmap_foo-to-linkmode_foo.patch b/target/linux/generic/backport-5.15/776-v5.16-1-net-convert-users-of-bitmap_foo-to-linkmode_foo.patch
new file mode 100644
index 0000000000..23d6f893a5
--- /dev/null
+++ b/target/linux/generic/backport-5.15/776-v5.16-1-net-convert-users-of-bitmap_foo-to-linkmode_foo.patch
@@ -0,0 +1,1009 @@
+From 1cd141887a4d4576e6cbfebf8b1445b2be768900 Mon Sep 17 00:00:00 2001
+From: Sean Anderson <sean.anderson@seco.com>
+Date: Fri, 22 Oct 2021 18:41:04 -0400
+Subject: [PATCH 1/4] net: convert users of bitmap_foo() to linkmode_foo()
+
+This converts instances of
+	bitmap_foo(args..., __ETHTOOL_LINK_MODE_MASK_NBITS)
+to
+	linkmode_foo(args...)
+
+I manually fixed up some lines to prevent them from being excessively
+long. Otherwise, this change was generated with the following semantic
+patch:
+
+// Generated with
+// echo linux/linkmode.h > includes
+// git grep -Flf includes include/ | cut -f 2- -d / | cat includes - \
+// | sort | uniq | tee new_includes | wc -l && mv new_includes includes
+// and repeating until the number stopped going up
+@i@
+@@
+
+(
+ #include <linux/acpi_mdio.h>
+|
+ #include <linux/brcmphy.h>
+|
+ #include <linux/dsa/loop.h>
+|
+ #include <linux/dsa/sja1105.h>
+|
+ #include <linux/ethtool.h>
+|
+ #include <linux/ethtool_netlink.h>
+|
+ #include <linux/fec.h>
+|
+ #include <linux/fs_enet_pd.h>
+|
+ #include <linux/fsl/enetc_mdio.h>
+|
+ #include <linux/fwnode_mdio.h>
+|
+ #include <linux/linkmode.h>
+|
+ #include <linux/lsm_audit.h>
+|
+ #include <linux/mdio-bitbang.h>
+|
+ #include <linux/mdio.h>
+|
+ #include <linux/mdio-mux.h>
+|
+ #include <linux/mii.h>
+|
+ #include <linux/mii_timestamper.h>
+|
+ #include <linux/mlx5/accel.h>
+|
+ #include <linux/mlx5/cq.h>
+|
+ #include <linux/mlx5/device.h>
+|
+ #include <linux/mlx5/driver.h>
+|
+ #include <linux/mlx5/eswitch.h>
+|
+ #include <linux/mlx5/fs.h>
+|
+ #include <linux/mlx5/port.h>
+|
+ #include <linux/mlx5/qp.h>
+|
+ #include <linux/mlx5/rsc_dump.h>
+|
+ #include <linux/mlx5/transobj.h>
+|
+ #include <linux/mlx5/vport.h>
+|
+ #include <linux/of_mdio.h>
+|
+ #include <linux/of_net.h>
+|
+ #include <linux/pcs-lynx.h>
+|
+ #include <linux/pcs/pcs-xpcs.h>
+|
+ #include <linux/phy.h>
+|
+ #include <linux/phy_led_triggers.h>
+|
+ #include <linux/phylink.h>
+|
+ #include <linux/platform_data/bcmgenet.h>
+|
+ #include <linux/platform_data/xilinx-ll-temac.h>
+|
+ #include <linux/pxa168_eth.h>
+|
+ #include <linux/qed/qed_eth_if.h>
+|
+ #include <linux/qed/qed_fcoe_if.h>
+|
+ #include <linux/qed/qed_if.h>
+|
+ #include <linux/qed/qed_iov_if.h>
+|
+ #include <linux/qed/qed_iscsi_if.h>
+|
+ #include <linux/qed/qed_ll2_if.h>
+|
+ #include <linux/qed/qed_nvmetcp_if.h>
+|
+ #include <linux/qed/qed_rdma_if.h>
+|
+ #include <linux/sfp.h>
+|
+ #include <linux/sh_eth.h>
+|
+ #include <linux/smsc911x.h>
+|
+ #include <linux/soc/nxp/lpc32xx-misc.h>
+|
+ #include <linux/stmmac.h>
+|
+ #include <linux/sunrpc/svc_rdma.h>
+|
+ #include <linux/sxgbe_platform.h>
+|
+ #include <net/cfg80211.h>
+|
+ #include <net/dsa.h>
+|
+ #include <net/mac80211.h>
+|
+ #include <net/selftests.h>
+|
+ #include <rdma/ib_addr.h>
+|
+ #include <rdma/ib_cache.h>
+|
+ #include <rdma/ib_cm.h>
+|
+ #include <rdma/ib_hdrs.h>
+|
+ #include <rdma/ib_mad.h>
+|
+ #include <rdma/ib_marshall.h>
+|
+ #include <rdma/ib_pack.h>
+|
+ #include <rdma/ib_pma.h>
+|
+ #include <rdma/ib_sa.h>
+|
+ #include <rdma/ib_smi.h>
+|
+ #include <rdma/ib_umem.h>
+|
+ #include <rdma/ib_umem_odp.h>
+|
+ #include <rdma/ib_verbs.h>
+|
+ #include <rdma/iw_cm.h>
+|
+ #include <rdma/mr_pool.h>
+|
+ #include <rdma/opa_addr.h>
+|
+ #include <rdma/opa_port_info.h>
+|
+ #include <rdma/opa_smi.h>
+|
+ #include <rdma/opa_vnic.h>
+|
+ #include <rdma/rdma_cm.h>
+|
+ #include <rdma/rdma_cm_ib.h>
+|
+ #include <rdma/rdmavt_cq.h>
+|
+ #include <rdma/rdma_vt.h>
+|
+ #include <rdma/rdmavt_qp.h>
+|
+ #include <rdma/rw.h>
+|
+ #include <rdma/tid_rdma_defs.h>
+|
+ #include <rdma/uverbs_ioctl.h>
+|
+ #include <rdma/uverbs_named_ioctl.h>
+|
+ #include <rdma/uverbs_std_types.h>
+|
+ #include <rdma/uverbs_types.h>
+|
+ #include <soc/mscc/ocelot.h>
+|
+ #include <soc/mscc/ocelot_ptp.h>
+|
+ #include <soc/mscc/ocelot_vcap.h>
+|
+ #include <trace/events/ib_mad.h>
+|
+ #include <trace/events/rdma_core.h>
+|
+ #include <trace/events/rdma.h>
+|
+ #include <trace/events/rpcrdma.h>
+|
+ #include <uapi/linux/ethtool.h>
+|
+ #include <uapi/linux/ethtool_netlink.h>
+|
+ #include <uapi/linux/mdio.h>
+|
+ #include <uapi/linux/mii.h>
+)
+
+@depends on i@
+expression list args;
+@@
+
+(
+- bitmap_zero(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_zero(args)
+|
+- bitmap_copy(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_copy(args)
+|
+- bitmap_and(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_and(args)
+|
+- bitmap_or(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_or(args)
+|
+- bitmap_empty(args, ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_empty(args)
+|
+- bitmap_andnot(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_andnot(args)
+|
+- bitmap_equal(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_equal(args)
+|
+- bitmap_intersects(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_intersects(args)
+|
+- bitmap_subset(args, __ETHTOOL_LINK_MODE_MASK_NBITS)
++ linkmode_subset(args)
+)
+
+Add missing linux/mii.h include to mellanox. -DaveM
+
+Signed-off-by: Sean Anderson <sean.anderson@seco.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/b53/b53_common.c              |  6 ++----
+ drivers/net/dsa/bcm_sf2.c                     |  8 +++----
+ drivers/net/dsa/hirschmann/hellcreek.c        |  6 ++----
+ drivers/net/dsa/lantiq_gswip.c                | 14 ++++++-------
+ drivers/net/dsa/microchip/ksz8795.c           |  8 +++----
+ drivers/net/dsa/mv88e6xxx/chip.c              |  5 ++---
+ drivers/net/dsa/ocelot/felix_vsc9959.c        |  8 +++----
+ drivers/net/dsa/ocelot/seville_vsc9953.c      |  8 +++----
+ drivers/net/dsa/qca/ar9331.c                  | 10 ++++-----
+ drivers/net/dsa/sja1105/sja1105_main.c        |  7 +++----
+ drivers/net/dsa/xrs700x/xrs700x.c             |  8 +++----
+ drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c  |  8 +++----
+ drivers/net/ethernet/atheros/ag71xx.c         |  8 +++----
+ drivers/net/ethernet/cadence/macb_main.c      | 11 +++++-----
+ .../net/ethernet/freescale/enetc/enetc_pf.c   |  8 +++----
+ .../net/ethernet/huawei/hinic/hinic_ethtool.c | 10 ++++-----
+ .../net/ethernet/intel/ixgbe/ixgbe_ethtool.c  |  5 ++---
+ drivers/net/ethernet/marvell/mvneta.c         | 10 ++++-----
+ .../net/ethernet/marvell/mvpp2/mvpp2_main.c   |  7 +++----
+ .../marvell/octeontx2/nic/otx2_ethtool.c      |  5 ++---
+ drivers/net/ethernet/marvell/pxa168_eth.c     |  3 +--
+ .../net/ethernet/mellanox/mlx4/en_ethtool.c   | 21 +++++++------------
+ .../microchip/sparx5/sparx5_phylink.c         |  7 +++----
+ drivers/net/ethernet/mscc/ocelot_net.c        |  7 +++----
+ .../ethernet/pensando/ionic/ionic_ethtool.c   |  3 +--
+ .../net/ethernet/xilinx/xilinx_axienet_main.c |  8 +++----
+ drivers/net/pcs/pcs-xpcs.c                    |  2 +-
+ drivers/net/phy/sfp-bus.c                     |  2 +-
+ net/ethtool/ioctl.c                           |  7 +++----
+ 29 files changed, 87 insertions(+), 133 deletions(-)
+
+diff --git a/drivers/net/dsa/b53/b53_common.c b/drivers/net/dsa/b53/b53_common.c
+index a967de4fcc90..b32f25b42323 100644
+--- a/drivers/net/dsa/b53/b53_common.c
++++ b/drivers/net/dsa/b53/b53_common.c
+@@ -1343,10 +1343,8 @@ void b53_phylink_validate(struct dsa_switch *ds, int port,
+ 		phylink_set(mask, 100baseT_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	phylink_helper_basex_speed(state);
+ }
+diff --git a/drivers/net/dsa/bcm_sf2.c b/drivers/net/dsa/bcm_sf2.c
+index d76b2377d66e..564f797a32aa 100644
+--- a/drivers/net/dsa/bcm_sf2.c
++++ b/drivers/net/dsa/bcm_sf2.c
+@@ -686,7 +686,7 @@ static void bcm_sf2_sw_validate(struct dsa_switch *ds, int port,
+ 	    state->interface != PHY_INTERFACE_MODE_GMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_INTERNAL &&
+ 	    state->interface != PHY_INTERFACE_MODE_MOCA) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		if (port != core_readl(priv, CORE_IMP0_PRT_ID))
+ 			dev_err(ds->dev,
+ 				"Unsupported interface: %d for port %d\n",
+@@ -714,10 +714,8 @@ static void bcm_sf2_sw_validate(struct dsa_switch *ds, int port,
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void bcm_sf2_sw_mac_config(struct dsa_switch *ds, int port,
+diff --git a/drivers/net/dsa/hirschmann/hellcreek.c b/drivers/net/dsa/hirschmann/hellcreek.c
+index 950a54ec4b59..b2bab460d2e9 100644
+--- a/drivers/net/dsa/hirschmann/hellcreek.c
++++ b/drivers/net/dsa/hirschmann/hellcreek.c
+@@ -1476,10 +1476,8 @@ static void hellcreek_phylink_validate(struct dsa_switch *ds, int port,
+ 	else
+ 		phylink_set(mask, 1000baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static int
+diff --git a/drivers/net/dsa/lantiq_gswip.c b/drivers/net/dsa/lantiq_gswip.c
+index 2240a3d35122..4599e958fa05 100644
+--- a/drivers/net/dsa/lantiq_gswip.c
++++ b/drivers/net/dsa/lantiq_gswip.c
+@@ -1452,10 +1452,8 @@ static void gswip_phylink_set_capab(unsigned long *supported,
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void gswip_xrx200_phylink_validate(struct dsa_switch *ds, int port,
+@@ -1483,7 +1481,7 @@ static void gswip_xrx200_phylink_validate(struct dsa_switch *ds, int port,
+ 			goto unsupported;
+ 		break;
+ 	default:
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		dev_err(ds->dev, "Unsupported port: %i\n", port);
+ 		return;
+ 	}
+@@ -1493,7 +1491,7 @@ static void gswip_xrx200_phylink_validate(struct dsa_switch *ds, int port,
+ 	return;
+ 
+ unsupported:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ 	dev_err(ds->dev, "Unsupported interface '%s' for port %d\n",
+ 		phy_modes(state->interface), port);
+ }
+@@ -1523,7 +1521,7 @@ static void gswip_xrx300_phylink_validate(struct dsa_switch *ds, int port,
+ 			goto unsupported;
+ 		break;
+ 	default:
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		dev_err(ds->dev, "Unsupported port: %i\n", port);
+ 		return;
+ 	}
+@@ -1533,7 +1531,7 @@ static void gswip_xrx300_phylink_validate(struct dsa_switch *ds, int port,
+ 	return;
+ 
+ unsupported:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ 	dev_err(ds->dev, "Unsupported interface '%s' for port %d\n",
+ 		phy_modes(state->interface), port);
+ }
+diff --git a/drivers/net/dsa/microchip/ksz8795.c b/drivers/net/dsa/microchip/ksz8795.c
+index c5142f86a3c7..43fc3087aeb3 100644
+--- a/drivers/net/dsa/microchip/ksz8795.c
++++ b/drivers/net/dsa/microchip/ksz8795.c
+@@ -1542,15 +1542,13 @@ static void ksz8_validate(struct dsa_switch *ds, int port,
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	return;
+ 
+ unsupported:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ 	dev_err(ds->dev, "Unsupported interface: %s, port: %d\n",
+ 		phy_modes(state->interface), port);
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index cad98ab421d7..d2751f73246b 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -683,9 +683,8 @@ static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
+ 	if (chip->info->ops->phylink_validate)
+ 		chip->info->ops->phylink_validate(chip, port, mask, state);
+ 
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
+ 	 * to advertise both, only report advertising at 2500BaseX.
+diff --git a/drivers/net/dsa/ocelot/felix_vsc9959.c b/drivers/net/dsa/ocelot/felix_vsc9959.c
+index 5ba7e5c820dd..aa3b7655a89f 100644
+--- a/drivers/net/dsa/ocelot/felix_vsc9959.c
++++ b/drivers/net/dsa/ocelot/felix_vsc9959.c
+@@ -944,7 +944,7 @@ static void vsc9959_phylink_validate(struct ocelot *ocelot, int port,
+ 
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != ocelot_port->phy_mode) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -966,10 +966,8 @@ static void vsc9959_phylink_validate(struct ocelot *ocelot, int port,
+ 		phylink_set(mask, 2500baseX_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static int vsc9959_prevalidate_phy_mode(struct ocelot *ocelot, int port,
+diff --git a/drivers/net/dsa/ocelot/seville_vsc9953.c b/drivers/net/dsa/ocelot/seville_vsc9953.c
+index 05e4e75c0107..40d6d1f2c724 100644
+--- a/drivers/net/dsa/ocelot/seville_vsc9953.c
++++ b/drivers/net/dsa/ocelot/seville_vsc9953.c
+@@ -1000,7 +1000,7 @@ static void vsc9953_phylink_validate(struct ocelot *ocelot, int port,
+ 
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != ocelot_port->phy_mode) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -1019,10 +1019,8 @@ static void vsc9953_phylink_validate(struct ocelot *ocelot, int port,
+ 		phylink_set(mask, 2500baseX_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static int vsc9953_prevalidate_phy_mode(struct ocelot *ocelot, int port,
+diff --git a/drivers/net/dsa/qca/ar9331.c b/drivers/net/dsa/qca/ar9331.c
+index 5d476f452396..c39de2a4c1fe 100644
+--- a/drivers/net/dsa/qca/ar9331.c
++++ b/drivers/net/dsa/qca/ar9331.c
+@@ -522,7 +522,7 @@ static void ar9331_sw_phylink_validate(struct dsa_switch *ds, int port,
+ 			goto unsupported;
+ 		break;
+ 	default:
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		dev_err(ds->dev, "Unsupported port: %i\n", port);
+ 		return;
+ 	}
+@@ -536,15 +536,13 @@ static void ar9331_sw_phylink_validate(struct dsa_switch *ds, int port,
+ 	phylink_set(mask, 100baseT_Half);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	return;
+ 
+ unsupported:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ 	dev_err(ds->dev, "Unsupported interface: %d, port: %d\n",
+ 		state->interface, port);
+ }
+diff --git a/drivers/net/dsa/sja1105/sja1105_main.c b/drivers/net/dsa/sja1105/sja1105_main.c
+index 1a2a7536ff8a..3e33d3b6fc59 100644
+--- a/drivers/net/dsa/sja1105/sja1105_main.c
++++ b/drivers/net/dsa/sja1105/sja1105_main.c
+@@ -1360,7 +1360,7 @@ static void sja1105_phylink_validate(struct dsa_switch *ds, int port,
+ 	 */
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    sja1105_phy_mode_mismatch(priv, port, state->interface)) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -1380,9 +1380,8 @@ static void sja1105_phylink_validate(struct dsa_switch *ds, int port,
+ 		phylink_set(mask, 2500baseX_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static int
+diff --git a/drivers/net/dsa/xrs700x/xrs700x.c b/drivers/net/dsa/xrs700x/xrs700x.c
+index cf363d5a3002..e79a336c6eb2 100644
+--- a/drivers/net/dsa/xrs700x/xrs700x.c
++++ b/drivers/net/dsa/xrs700x/xrs700x.c
+@@ -457,7 +457,7 @@ static void xrs700x_phylink_validate(struct dsa_switch *ds, int port,
+ 		phylink_set(mask, 1000baseT_Full);
+ 		break;
+ 	default:
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		dev_err(ds->dev, "Unsupported port: %i\n", port);
+ 		return;
+ 	}
+@@ -468,10 +468,8 @@ static void xrs700x_phylink_validate(struct dsa_switch *ds, int port,
+ 	phylink_set(mask, 10baseT_Full);
+ 	phylink_set(mask, 100baseT_Full);
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void xrs700x_mac_link_up(struct dsa_switch *ds, int port,
+diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+index bafc51c34e0b..94879cf8b420 100644
+--- a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
++++ b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+@@ -369,9 +369,8 @@ static int xgbe_set_link_ksettings(struct net_device *netdev,
+ 		  __ETHTOOL_LINK_MODE_MASK_NBITS, cmd->link_modes.advertising,
+ 		  __ETHTOOL_LINK_MODE_MASK_NBITS, lks->link_modes.supported);
+ 
+-	bitmap_and(advertising,
+-		   cmd->link_modes.advertising, lks->link_modes.supported,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(advertising, cmd->link_modes.advertising,
++		     lks->link_modes.supported);
+ 
+ 	if ((cmd->base.autoneg == AUTONEG_ENABLE) &&
+ 	    bitmap_empty(advertising, __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+@@ -384,8 +383,7 @@ static int xgbe_set_link_ksettings(struct net_device *netdev,
+ 	pdata->phy.autoneg = cmd->base.autoneg;
+ 	pdata->phy.speed = speed;
+ 	pdata->phy.duplex = cmd->base.duplex;
+-	bitmap_copy(lks->link_modes.advertising, advertising,
+-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_copy(lks->link_modes.advertising, advertising);
+ 
+ 	if (cmd->base.autoneg == AUTONEG_ENABLE)
+ 		XGBE_SET_ADV(lks, Autoneg);
+diff --git a/drivers/net/ethernet/atheros/ag71xx.c b/drivers/net/ethernet/atheros/ag71xx.c
+index 416a5c99db5a..d754bfc4f18f 100644
+--- a/drivers/net/ethernet/atheros/ag71xx.c
++++ b/drivers/net/ethernet/atheros/ag71xx.c
+@@ -1082,14 +1082,12 @@ static void ag71xx_mac_validate(struct phylink_config *config,
+ 		phylink_set(mask, 1000baseX_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	return;
+ unsupported:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ }
+ 
+ static void ag71xx_mac_pcs_get_state(struct phylink_config *config,
+diff --git a/drivers/net/ethernet/cadence/macb_main.c b/drivers/net/ethernet/cadence/macb_main.c
+index 3ca3f9d0fd9b..c6f28b084646 100644
+--- a/drivers/net/ethernet/cadence/macb_main.c
++++ b/drivers/net/ethernet/cadence/macb_main.c
+@@ -523,21 +523,21 @@ static void macb_validate(struct phylink_config *config,
+ 	    state->interface != PHY_INTERFACE_MODE_SGMII &&
+ 	    state->interface != PHY_INTERFACE_MODE_10GBASER &&
+ 	    !phy_interface_mode_is_rgmii(state->interface)) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	if (!macb_is_gem(bp) &&
+ 	    (state->interface == PHY_INTERFACE_MODE_GMII ||
+ 	     phy_interface_mode_is_rgmii(state->interface))) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_10GBASER &&
+ 	    !(bp->caps & MACB_CAPS_HIGH_SPEED &&
+ 	      bp->caps & MACB_CAPS_PCS)) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -576,9 +576,8 @@ static void macb_validate(struct phylink_config *config,
+ 			phylink_set(mask, 1000baseT_Half);
+ 	}
+ out:
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void macb_usx_pcs_link_up(struct phylink_pcs *pcs, unsigned int mode,
+diff --git a/drivers/net/ethernet/freescale/enetc/enetc_pf.c b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+index d522bd5c90b4..1c318a932460 100644
+--- a/drivers/net/ethernet/freescale/enetc/enetc_pf.c
++++ b/drivers/net/ethernet/freescale/enetc/enetc_pf.c
+@@ -940,7 +940,7 @@ static void enetc_pl_mac_validate(struct phylink_config *config,
+ 	    state->interface != PHY_INTERFACE_MODE_2500BASEX &&
+ 	    state->interface != PHY_INTERFACE_MODE_USXGMII &&
+ 	    !phy_interface_mode_is_rgmii(state->interface)) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -963,10 +963,8 @@ static void enetc_pl_mac_validate(struct phylink_config *config,
+ 		phylink_set(mask, 2500baseX_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void enetc_pl_mac_config(struct phylink_config *config,
+diff --git a/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c b/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
+index b431c300ef1b..a85667078b72 100644
+--- a/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
++++ b/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c
+@@ -322,12 +322,10 @@ static int hinic_get_link_ksettings(struct net_device *netdev,
+ 		}
+ 	}
+ 
+-	bitmap_copy(link_ksettings->link_modes.supported,
+-		    (unsigned long *)&settings.supported,
+-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_copy(link_ksettings->link_modes.advertising,
+-		    (unsigned long *)&settings.advertising,
+-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_copy(link_ksettings->link_modes.supported,
++		      (unsigned long *)&settings.supported);
++	linkmode_copy(link_ksettings->link_modes.advertising,
++		      (unsigned long *)&settings.advertising);
+ 
+ 	return 0;
+ }
+diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+index beda8e0ef7d4..8362822316a9 100644
+--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
++++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+@@ -467,9 +467,8 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
+ 		 * this function does not support duplex forcing, but can
+ 		 * limit the advertising of the adapter to the specified speed
+ 		 */
+-		if (!bitmap_subset(cmd->link_modes.advertising,
+-				   cmd->link_modes.supported,
+-				   __ETHTOOL_LINK_MODE_MASK_NBITS))
++		if (!linkmode_subset(cmd->link_modes.advertising,
++				     cmd->link_modes.supported))
+ 			return -EINVAL;
+ 
+ 		/* only allow one speed at a time if no autoneg */
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 7eb13fbf58e3..f2e959997e48 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3862,14 +3862,14 @@ static void mvneta_validate(struct phylink_config *config,
+ 	 */
+ 	if (phy_interface_mode_is_8023z(state->interface)) {
+ 		if (!phylink_test(state->advertising, Autoneg)) {
+-			bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++			linkmode_zero(supported);
+ 			return;
+ 		}
+ 	} else if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 		   state->interface != PHY_INTERFACE_MODE_QSGMII &&
+ 		   state->interface != PHY_INTERFACE_MODE_SGMII &&
+ 		   !phy_interface_mode_is_rgmii(state->interface)) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -3898,10 +3898,8 @@ static void mvneta_validate(struct phylink_config *config,
+ 		phylink_set(mask, 100baseT_Full);
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
+ 	 * to advertise both, only report advertising at 2500BaseX.
+diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+index 2baa909290b3..c963115558cb 100644
+--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
++++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+@@ -6347,15 +6347,14 @@ static void mvpp2_phylink_validate(struct phylink_config *config,
+ 		goto empty_set;
+ 	}
+ 
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ 
+ 	phylink_helper_basex_speed(state);
+ 	return;
+ 
+ empty_set:
+-	bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(supported);
+ }
+ 
+ static void mvpp2_xlg_config(struct mvpp2_port *port, unsigned int mode,
+diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+index dbfa3bc39e34..4c882ceaeb1f 100644
+--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
++++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c
+@@ -1168,9 +1168,8 @@ static int otx2_set_link_ksettings(struct net_device *netdev,
+ 	otx2_get_link_ksettings(netdev, &cur_ks);
+ 
+ 	/* Check requested modes against supported modes by hardware */
+-	if (!bitmap_subset(cmd->link_modes.advertising,
+-			   cur_ks.link_modes.supported,
+-			   __ETHTOOL_LINK_MODE_MASK_NBITS))
++	if (!linkmode_subset(cmd->link_modes.advertising,
++			     cur_ks.link_modes.supported))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&mbox->lock);
+diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
+index fab53c9b8380..572061164f1f 100644
+--- a/drivers/net/ethernet/marvell/pxa168_eth.c
++++ b/drivers/net/ethernet/marvell/pxa168_eth.c
+@@ -977,8 +977,7 @@ static int pxa168_init_phy(struct net_device *dev)
+ 	cmd.base.phy_address = pep->phy_addr;
+ 	cmd.base.speed = pep->phy_speed;
+ 	cmd.base.duplex = pep->phy_duplex;
+-	bitmap_copy(cmd.link_modes.advertising, PHY_BASIC_FEATURES,
+-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_copy(cmd.link_modes.advertising, PHY_BASIC_FEATURES);
+ 	cmd.base.autoneg = AUTONEG_ENABLE;
+ 
+ 	if (cmd.base.speed != 0)
+diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+index c3cffb32fb06..4be2bc8f74f1 100644
+--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
++++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+@@ -39,6 +39,7 @@
+ #include <linux/in.h>
+ #include <net/ip.h>
+ #include <linux/bitmap.h>
++#include <linux/mii.h>
+ 
+ #include "mlx4_en.h"
+ #include "en_port.h"
+@@ -643,10 +644,8 @@ static unsigned long *ptys2ethtool_link_mode(struct ptys2ethtool_config *cfg,
+ 		unsigned int i;						\
+ 		cfg = &ptys2ethtool_map[reg_];				\
+ 		cfg->speed = speed_;					\
+-		bitmap_zero(cfg->supported,				\
+-			    __ETHTOOL_LINK_MODE_MASK_NBITS);		\
+-		bitmap_zero(cfg->advertised,				\
+-			    __ETHTOOL_LINK_MODE_MASK_NBITS);		\
++		linkmode_zero(cfg->supported);				\
++		linkmode_zero(cfg->advertised);				\
+ 		for (i = 0 ; i < ARRAY_SIZE(modes) ; ++i) {		\
+ 			__set_bit(modes[i], cfg->supported);		\
+ 			__set_bit(modes[i], cfg->advertised);		\
+@@ -702,10 +701,8 @@ static void ptys2ethtool_update_link_modes(unsigned long *link_modes,
+ 	int i;
+ 	for (i = 0; i < MLX4_LINK_MODES_SZ; i++) {
+ 		if (eth_proto & MLX4_PROT_MASK(i))
+-			bitmap_or(link_modes, link_modes,
+-				  ptys2ethtool_link_mode(&ptys2ethtool_map[i],
+-							 report),
+-				  __ETHTOOL_LINK_MODE_MASK_NBITS);
++			linkmode_or(link_modes, link_modes,
++				    ptys2ethtool_link_mode(&ptys2ethtool_map[i], report));
+ 	}
+ }
+ 
+@@ -716,11 +713,9 @@ static u32 ethtool2ptys_link_modes(const unsigned long *link_modes,
+ 	u32 ptys_modes = 0;
+ 
+ 	for (i = 0; i < MLX4_LINK_MODES_SZ; i++) {
+-		if (bitmap_intersects(
+-			    ptys2ethtool_link_mode(&ptys2ethtool_map[i],
+-						   report),
+-			    link_modes,
+-			    __ETHTOOL_LINK_MODE_MASK_NBITS))
++		ulong *map_mode = ptys2ethtool_link_mode(&ptys2ethtool_map[i],
++							 report);
++		if (linkmode_intersects(map_mode, link_modes))
+ 			ptys_modes |= 1 << i;
+ 	}
+ 	return ptys_modes;
+diff --git a/drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c b/drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
+index af70e2795125..fb74752de0ca 100644
+--- a/drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
++++ b/drivers/net/ethernet/microchip/sparx5/sparx5_phylink.c
+@@ -92,12 +92,11 @@ static void sparx5_phylink_validate(struct phylink_config *config,
+ 		}
+ 		break;
+ 	default:
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void sparx5_phylink_mac_config(struct phylink_config *config,
+diff --git a/drivers/net/ethernet/mscc/ocelot_net.c b/drivers/net/ethernet/mscc/ocelot_net.c
+index c08c56e07b1d..6a8e391ecadd 100644
+--- a/drivers/net/ethernet/mscc/ocelot_net.c
++++ b/drivers/net/ethernet/mscc/ocelot_net.c
+@@ -1509,7 +1509,7 @@ static void vsc7514_phylink_validate(struct phylink_config *config,
+ 
+ 	if (state->interface != PHY_INTERFACE_MODE_NA &&
+ 	    state->interface != ocelot_port->phy_mode) {
+-		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(supported);
+ 		return;
+ 	}
+ 
+@@ -1528,9 +1528,8 @@ static void vsc7514_phylink_validate(struct phylink_config *config,
+ 	phylink_set(mask, 2500baseT_Full);
+ 	phylink_set(mask, 2500baseX_Full);
+ 
+-	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void vsc7514_phylink_mac_config(struct phylink_config *config,
+diff --git a/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c b/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
+index 3de1a03839e2..620fc13b5781 100644
+--- a/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
++++ b/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c
+@@ -228,8 +228,7 @@ static int ionic_get_link_ksettings(struct net_device *netdev,
+ 		break;
+ 	}
+ 
+-	bitmap_copy(ks->link_modes.advertising, ks->link_modes.supported,
+-		    __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_copy(ks->link_modes.advertising, ks->link_modes.supported);
+ 
+ 	ethtool_link_ksettings_add_link_mode(ks, supported, FEC_BASER);
+ 	ethtool_link_ksettings_add_link_mode(ks, supported, FEC_RS);
+diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+index fbbbcfe0e891..4cf0994f624c 100644
+--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
++++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+@@ -1565,7 +1565,7 @@ static void axienet_validate(struct phylink_config *config,
+ 			netdev_warn(ndev, "Cannot use PHY mode %s, supported: %s\n",
+ 				    phy_modes(state->interface),
+ 				    phy_modes(lp->phy_mode));
+-			bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++			linkmode_zero(supported);
+ 			return;
+ 		}
+ 	}
+@@ -1598,10 +1598,8 @@ static void axienet_validate(struct phylink_config *config,
+ 		break;
+ 	}
+ 
+-	bitmap_and(supported, supported, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
+-	bitmap_and(state->advertising, state->advertising, mask,
+-		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_and(supported, supported, mask);
++	linkmode_and(state->advertising, state->advertising, mask);
+ }
+ 
+ static void axienet_mac_pcs_get_state(struct phylink_config *config,
+diff --git a/drivers/net/pcs/pcs-xpcs.c b/drivers/net/pcs/pcs-xpcs.c
+index fd4cbf8a55ad..ec75cf81c3af 100644
+--- a/drivers/net/pcs/pcs-xpcs.c
++++ b/drivers/net/pcs/pcs-xpcs.c
+@@ -646,7 +646,7 @@ void xpcs_validate(struct dw_xpcs *xpcs, unsigned long *supported,
+ 	if (state->interface == PHY_INTERFACE_MODE_NA)
+ 		return;
+ 
+-	bitmap_zero(xpcs_supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(xpcs_supported);
+ 
+ 	compat = xpcs_find_compat(xpcs->id, state->interface);
+ 
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 4566348a6d05..0a9099c77694 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -286,7 +286,7 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 	if (bus->sfp_quirk && bus->sfp_quirk->modes)
+ 		bus->sfp_quirk->modes(id, modes);
+ 
+-	bitmap_or(support, support, modes, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_or(support, support, modes);
+ 
+ 	phylink_set(support, Autoneg);
+ 	phylink_set(support, Pause);
+diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
+index e4983f473a3c..b4aa3bbcf3c7 100644
+--- a/net/ethtool/ioctl.c
++++ b/net/ethtool/ioctl.c
+@@ -335,7 +335,7 @@ EXPORT_SYMBOL(ethtool_intersect_link_masks);
+ void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
+ 					     u32 legacy_u32)
+ {
+-	bitmap_zero(dst, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	linkmode_zero(dst);
+ 	dst[0] = legacy_u32;
+ }
+ EXPORT_SYMBOL(ethtool_convert_legacy_u32_to_link_mode);
+@@ -350,11 +350,10 @@ bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
+ 	if (__ETHTOOL_LINK_MODE_MASK_NBITS > 32) {
+ 		__ETHTOOL_DECLARE_LINK_MODE_MASK(ext);
+ 
+-		bitmap_zero(ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		linkmode_zero(ext);
+ 		bitmap_fill(ext, 32);
+ 		bitmap_complement(ext, ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+-		if (bitmap_intersects(ext, src,
+-				      __ETHTOOL_LINK_MODE_MASK_NBITS)) {
++		if (linkmode_intersects(ext, src)) {
+ 			/* src mask goes beyond bit 31 */
+ 			retval = false;
+ 		}
+-- 
+2.35.1
+
diff --git a/target/linux/generic/backport-5.15/776-v5.16-2-net-mvneta-populate-supported_interfaces-member.patch b/target/linux/generic/backport-5.15/776-v5.16-2-net-mvneta-populate-supported_interfaces-member.patch
new file mode 100644
index 0000000000..b755bd79a9
--- /dev/null
+++ b/target/linux/generic/backport-5.15/776-v5.16-2-net-mvneta-populate-supported_interfaces-member.patch
@@ -0,0 +1,53 @@
+From c7c29985c548c24efe90e337c575b475bc5e8c13 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Wed, 27 Oct 2021 10:03:43 +0100
+Subject: [PATCH 2/4] net: mvneta: populate supported_interfaces member
+
+Populate the phy_interface_t bitmap for the Marvell mvneta driver with
+interfaces modes supported by the MAC.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index f2e959997e48..1056b4845ec4 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -5308,6 +5308,31 @@ static int mvneta_probe(struct platform_device *pdev)
+ 
+ 	pp->phylink_config.dev = &dev->dev;
+ 	pp->phylink_config.type = PHYLINK_NETDEV;
++	phy_interface_set_rgmii(pp->phylink_config.supported_interfaces);
++	__set_bit(PHY_INTERFACE_MODE_QSGMII,
++		  pp->phylink_config.supported_interfaces);
++	if (comphy) {
++		/* If a COMPHY is present, we can support any of the serdes
++		 * modes and switch between them.
++		 */
++		__set_bit(PHY_INTERFACE_MODE_SGMII,
++			  pp->phylink_config.supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX,
++			  pp->phylink_config.supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_2500BASEX,
++			  pp->phylink_config.supported_interfaces);
++	} else if (phy_mode == PHY_INTERFACE_MODE_2500BASEX) {
++		/* No COMPHY, with only 2500BASE-X mode supported */
++		__set_bit(PHY_INTERFACE_MODE_2500BASEX,
++			  pp->phylink_config.supported_interfaces);
++	} else if (phy_mode == PHY_INTERFACE_MODE_1000BASEX ||
++		   phy_mode == PHY_INTERFACE_MODE_SGMII) {
++		/* No COMPHY, we can switch between 1000BASE-X and SGMII */
++		__set_bit(PHY_INTERFACE_MODE_1000BASEX,
++			  pp->phylink_config.supported_interfaces);
++		__set_bit(PHY_INTERFACE_MODE_SGMII,
++			  pp->phylink_config.supported_interfaces);
++	}
+ 
+ 	phylink = phylink_create(&pp->phylink_config, pdev->dev.fwnode,
+ 				 phy_mode, &mvneta_phylink_ops);
+-- 
+2.35.1
+
diff --git a/target/linux/generic/backport-5.15/776-v5.16-3-net-mvneta-remove-interface-checks-in-mvneta_validat.patch b/target/linux/generic/backport-5.15/776-v5.16-3-net-mvneta-remove-interface-checks-in-mvneta_validat.patch
new file mode 100644
index 0000000000..14c34f2e0e
--- /dev/null
+++ b/target/linux/generic/backport-5.15/776-v5.16-3-net-mvneta-remove-interface-checks-in-mvneta_validat.patch
@@ -0,0 +1,40 @@
+From 10639f59c410911bb4a14e903d109dd426f2858c Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Wed, 27 Oct 2021 10:03:48 +0100
+Subject: [PATCH 3/4] net: mvneta: remove interface checks in mvneta_validate()
+
+As phylink checks the interface mode against the supported_interfaces
+bitmap, we no longer need to validate the interface mode in the
+validation function. Remove this to simplify it.
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 11 ++---------
+ 1 file changed, 2 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 1056b4845ec4..c13d4beb570f 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3860,15 +3860,8 @@ static void mvneta_validate(struct phylink_config *config,
+ 	 * "Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...
+ 	 * When <PortType> = 1 (1000BASE-X) this field must be set to 1."
+ 	 */
+-	if (phy_interface_mode_is_8023z(state->interface)) {
+-		if (!phylink_test(state->advertising, Autoneg)) {
+-			linkmode_zero(supported);
+-			return;
+-		}
+-	} else if (state->interface != PHY_INTERFACE_MODE_NA &&
+-		   state->interface != PHY_INTERFACE_MODE_QSGMII &&
+-		   state->interface != PHY_INTERFACE_MODE_SGMII &&
+-		   !phy_interface_mode_is_rgmii(state->interface)) {
++	if (phy_interface_mode_is_8023z(state->interface) &&
++	    !phylink_test(state->advertising, Autoneg)) {
+ 		linkmode_zero(supported);
+ 		return;
+ 	}
+-- 
+2.35.1
+
diff --git a/target/linux/generic/backport-5.15/776-v5.16-4-net-mvneta-drop-use-of-phylink_helper_basex_speed.patch b/target/linux/generic/backport-5.15/776-v5.16-4-net-mvneta-drop-use-of-phylink_helper_basex_speed.patch
new file mode 100644
index 0000000000..0b8fbbdeca
--- /dev/null
+++ b/target/linux/generic/backport-5.15/776-v5.16-4-net-mvneta-drop-use-of-phylink_helper_basex_speed.patch
@@ -0,0 +1,60 @@
+From 0e09bb9ae49bcb121c353861f440e7a9ede3b378 Mon Sep 17 00:00:00 2001
+From: "Russell King (Oracle)" <rmk+kernel@armlinux.org.uk>
+Date: Wed, 27 Oct 2021 10:03:53 +0100
+Subject: [PATCH 4/4] net: mvneta: drop use of phylink_helper_basex_speed()
+
+Now that we have a better method to select SFP interface modes, we
+no longer need to use phylink_helper_basex_speed() in a driver's
+validation function, and we can also get rid of our hack to indicate
+both 1000base-X and 2500base-X if the comphy is present to make that
+work. Remove this hack and use of phylink_helper_basex_speed().
+
+Signed-off-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 12 +++---------
+ 1 file changed, 3 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index c13d4beb570f..51fe2de0215e 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3851,8 +3851,6 @@ static void mvneta_validate(struct phylink_config *config,
+ 			    unsigned long *supported,
+ 			    struct phylink_link_state *state)
+ {
+-	struct net_device *ndev = to_net_dev(config->dev);
+-	struct mvneta_port *pp = netdev_priv(ndev);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	/* We only support QSGMII, SGMII, 802.3z and RGMII modes.
+@@ -3874,11 +3872,12 @@ static void mvneta_validate(struct phylink_config *config,
+ 	phylink_set(mask, Pause);
+ 
+ 	/* Half-duplex at speeds higher than 100Mbit is unsupported */
+-	if (pp->comphy || state->interface != PHY_INTERFACE_MODE_2500BASEX) {
++	if (state->interface != PHY_INTERFACE_MODE_2500BASEX) {
+ 		phylink_set(mask, 1000baseT_Full);
+ 		phylink_set(mask, 1000baseX_Full);
+ 	}
+-	if (pp->comphy || state->interface == PHY_INTERFACE_MODE_2500BASEX) {
++
++	if (state->interface == PHY_INTERFACE_MODE_2500BASEX) {
+ 		phylink_set(mask, 2500baseT_Full);
+ 		phylink_set(mask, 2500baseX_Full);
+ 	}
+@@ -3893,11 +3892,6 @@ static void mvneta_validate(struct phylink_config *config,
+ 
+ 	linkmode_and(supported, supported, mask);
+ 	linkmode_and(state->advertising, state->advertising, mask);
+-
+-	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
+-	 * to advertise both, only report advertising at 2500BaseX.
+-	 */
+-	phylink_helper_basex_speed(state);
+ }
+ 
+ static void mvneta_mac_pcs_get_state(struct phylink_config *config,
+-- 
+2.35.1
+
-- 
2.35.1

